// Code generated from VerilogParser.g4 by ANTLR 4.9.2. DO NOT EDIT.

package verilog // VerilogParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 320, 4406,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 4, 257, 9, 257, 4, 258, 9, 258, 4, 259, 9, 259,
	4, 260, 9, 260, 4, 261, 9, 261, 4, 262, 9, 262, 4, 263, 9, 263, 4, 264,
	9, 264, 4, 265, 9, 265, 4, 266, 9, 266, 4, 267, 9, 267, 4, 268, 9, 268,
	4, 269, 9, 269, 4, 270, 9, 270, 4, 271, 9, 271, 4, 272, 9, 272, 4, 273,
	9, 273, 4, 274, 9, 274, 4, 275, 9, 275, 4, 276, 9, 276, 4, 277, 9, 277,
	4, 278, 9, 278, 4, 279, 9, 279, 4, 280, 9, 280, 4, 281, 9, 281, 4, 282,
	9, 282, 4, 283, 9, 283, 4, 284, 9, 284, 4, 285, 9, 285, 4, 286, 9, 286,
	4, 287, 9, 287, 4, 288, 9, 288, 4, 289, 9, 289, 4, 290, 9, 290, 4, 291,
	9, 291, 4, 292, 9, 292, 4, 293, 9, 293, 4, 294, 9, 294, 4, 295, 9, 295,
	4, 296, 9, 296, 4, 297, 9, 297, 4, 298, 9, 298, 4, 299, 9, 299, 4, 300,
	9, 300, 4, 301, 9, 301, 4, 302, 9, 302, 4, 303, 9, 303, 4, 304, 9, 304,
	4, 305, 9, 305, 4, 306, 9, 306, 4, 307, 9, 307, 4, 308, 9, 308, 4, 309,
	9, 309, 4, 310, 9, 310, 4, 311, 9, 311, 4, 312, 9, 312, 4, 313, 9, 313,
	4, 314, 9, 314, 4, 315, 9, 315, 4, 316, 9, 316, 4, 317, 9, 317, 4, 318,
	9, 318, 4, 319, 9, 319, 4, 320, 9, 320, 4, 321, 9, 321, 4, 322, 9, 322,
	4, 323, 9, 323, 4, 324, 9, 324, 4, 325, 9, 325, 4, 326, 9, 326, 4, 327,
	9, 327, 4, 328, 9, 328, 4, 329, 9, 329, 4, 330, 9, 330, 4, 331, 9, 331,
	4, 332, 9, 332, 4, 333, 9, 333, 4, 334, 9, 334, 3, 2, 3, 2, 3, 2, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 7, 4, 682, 10, 4,
	12, 4, 14, 4, 685, 11, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 693,
	10, 5, 3, 5, 7, 5, 696, 10, 5, 12, 5, 14, 5, 699, 11, 5, 3, 5, 3, 5, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 5, 6, 718, 10, 6, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 9, 3,
	9, 3, 9, 7, 9, 728, 10, 9, 12, 9, 14, 9, 731, 11, 9, 3, 10, 3, 10, 7, 10,
	735, 10, 10, 12, 10, 14, 10, 738, 11, 10, 3, 11, 3, 11, 3, 11, 3, 11, 5,
	11, 744, 10, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 752,
	10, 12, 3, 12, 3, 12, 3, 12, 5, 12, 757, 10, 12, 3, 13, 3, 13, 7, 13, 761,
	10, 13, 12, 13, 14, 13, 764, 11, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3, 15,
	7, 15, 771, 10, 15, 12, 15, 14, 15, 774, 11, 15, 3, 15, 3, 15, 3, 15, 5,
	15, 779, 10, 15, 3, 15, 3, 15, 5, 15, 783, 10, 15, 3, 15, 3, 15, 7, 15,
	787, 10, 15, 12, 15, 14, 15, 790, 11, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3,
	17, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 801, 10, 17, 12, 17, 14, 17, 804,
	11, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 18, 7, 18, 812, 10, 18, 12,
	18, 14, 18, 815, 11, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 19, 7, 19,
	823, 10, 19, 12, 19, 14, 19, 826, 11, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5,
	19, 832, 10, 19, 3, 20, 5, 20, 835, 10, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	5, 20, 841, 10, 20, 3, 20, 3, 20, 5, 20, 845, 10, 20, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 7, 21, 852, 10, 21, 12, 21, 14, 21, 855, 11, 21, 3, 21,
	3, 21, 5, 21, 859, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 872, 10, 22, 3, 23, 7, 23, 875,
	10, 23, 12, 23, 14, 23, 878, 11, 23, 3, 23, 3, 23, 7, 23, 882, 10, 23,
	12, 23, 14, 23, 885, 11, 23, 3, 23, 3, 23, 7, 23, 889, 10, 23, 12, 23,
	14, 23, 892, 11, 23, 3, 23, 5, 23, 895, 10, 23, 3, 24, 3, 24, 3, 24, 3,
	24, 3, 24, 7, 24, 902, 10, 24, 12, 24, 14, 24, 905, 11, 24, 3, 24, 3, 24,
	7, 24, 909, 10, 24, 12, 24, 14, 24, 912, 11, 24, 3, 24, 3, 24, 7, 24, 916,
	10, 24, 12, 24, 14, 24, 919, 11, 24, 3, 24, 3, 24, 7, 24, 923, 10, 24,
	12, 24, 14, 24, 926, 11, 24, 3, 24, 3, 24, 7, 24, 930, 10, 24, 12, 24,
	14, 24, 933, 11, 24, 3, 24, 5, 24, 936, 10, 24, 3, 25, 7, 25, 939, 10,
	25, 12, 25, 14, 25, 942, 11, 25, 3, 25, 3, 25, 7, 25, 946, 10, 25, 12,
	25, 14, 25, 949, 11, 25, 3, 25, 3, 25, 7, 25, 953, 10, 25, 12, 25, 14,
	25, 956, 11, 25, 3, 25, 3, 25, 7, 25, 960, 10, 25, 12, 25, 14, 25, 963,
	11, 25, 3, 25, 3, 25, 7, 25, 967, 10, 25, 12, 25, 14, 25, 970, 11, 25,
	3, 25, 3, 25, 7, 25, 974, 10, 25, 12, 25, 14, 25, 977, 11, 25, 3, 25, 3,
	25, 7, 25, 981, 10, 25, 12, 25, 14, 25, 984, 11, 25, 3, 25, 3, 25, 7, 25,
	988, 10, 25, 12, 25, 14, 25, 991, 11, 25, 3, 25, 5, 25, 994, 10, 25, 3,
	26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26,
	1006, 10, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28, 5, 28, 1014, 10,
	28, 3, 28, 5, 28, 1017, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 1042, 10, 28, 3, 29,
	3, 29, 3, 29, 3, 30, 3, 30, 5, 30, 1049, 10, 30, 3, 30, 5, 30, 1052, 10,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 5, 30, 1067, 10, 30, 3, 31, 3, 31, 5, 31, 1071, 10,
	31, 3, 31, 3, 31, 3, 31, 3, 32, 3, 32, 5, 32, 1078, 10, 32, 3, 32, 5, 32,
	1081, 10, 32, 3, 32, 5, 32, 1084, 10, 32, 3, 32, 3, 32, 3, 33, 3, 33, 5,
	33, 1090, 10, 33, 3, 33, 5, 33, 1093, 10, 33, 3, 33, 5, 33, 1096, 10, 33,
	3, 33, 3, 33, 3, 34, 3, 34, 5, 34, 1102, 10, 34, 3, 34, 5, 34, 1105, 10,
	34, 3, 34, 5, 34, 1108, 10, 34, 3, 34, 3, 34, 3, 34, 5, 34, 1113, 10, 34,
	3, 34, 5, 34, 1116, 10, 34, 3, 34, 5, 34, 1119, 10, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 5, 34, 1125, 10, 34, 3, 34, 5, 34, 1128, 10, 34, 3, 34, 3, 34,
	3, 34, 5, 34, 1133, 10, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 1140,
	10, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 5, 41, 1168, 10, 41, 3, 41,
	5, 41, 1171, 10, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 5, 42, 1178, 10,
	42, 3, 42, 5, 42, 1181, 10, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42,
	1188, 10, 42, 3, 42, 5, 42, 1191, 10, 42, 3, 42, 5, 42, 1194, 10, 42, 3,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 1201, 10, 42, 3, 42, 5, 42, 1204,
	10, 42, 3, 42, 5, 42, 1207, 10, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42,
	5, 42, 1214, 10, 42, 3, 42, 5, 42, 1217, 10, 42, 3, 42, 5, 42, 1220, 10,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 1227, 10, 42, 3, 42, 5, 42,
	1230, 10, 42, 3, 42, 5, 42, 1233, 10, 42, 3, 42, 3, 42, 5, 42, 1237, 10,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 1244, 10, 42, 3, 42, 5, 42,
	1247, 10, 42, 3, 42, 5, 42, 1250, 10, 42, 3, 42, 3, 42, 5, 42, 1254, 10,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 1261, 10, 42, 3, 42, 5, 42,
	1264, 10, 42, 3, 42, 5, 42, 1267, 10, 42, 3, 42, 3, 42, 5, 42, 1271, 10,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 1278, 10, 42, 3, 42, 5, 42,
	1281, 10, 42, 3, 42, 3, 42, 5, 42, 1285, 10, 42, 3, 42, 3, 42, 3, 42, 5,
	42, 1290, 10, 42, 3, 43, 3, 43, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45, 5, 45,
	1299, 10, 45, 3, 45, 3, 45, 3, 45, 7, 45, 1304, 10, 45, 12, 45, 14, 45,
	1307, 11, 45, 5, 45, 1309, 10, 45, 3, 46, 3, 46, 3, 46, 5, 46, 1314, 10,
	46, 3, 46, 3, 46, 3, 46, 7, 46, 1319, 10, 46, 12, 46, 14, 46, 1322, 11,
	46, 5, 46, 1324, 10, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47,
	3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3,
	47, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 1348, 10, 47, 3, 48, 3, 48, 3, 49,
	3, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5,
	50, 1363, 10, 50, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51,
	3, 51, 5, 51, 1374, 10, 51, 5, 51, 1376, 10, 51, 3, 51, 3, 51, 5, 51, 1380,
	10, 51, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 5, 52, 1389, 10,
	52, 3, 52, 3, 52, 5, 52, 1393, 10, 52, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53,
	1399, 10, 53, 3, 54, 3, 54, 3, 54, 7, 54, 1404, 10, 54, 12, 54, 14, 54,
	1407, 11, 54, 5, 54, 1409, 10, 54, 3, 54, 3, 54, 3, 54, 3, 54, 7, 54, 1415,
	10, 54, 12, 54, 14, 54, 1418, 11, 54, 5, 54, 1420, 10, 54, 7, 54, 1422,
	10, 54, 12, 54, 14, 54, 1425, 11, 54, 3, 55, 3, 55, 3, 55, 7, 55, 1430,
	10, 55, 12, 55, 14, 55, 1433, 11, 55, 5, 55, 1435, 10, 55, 3, 55, 3, 55,
	3, 55, 3, 55, 7, 55, 1441, 10, 55, 12, 55, 14, 55, 1444, 11, 55, 5, 55,
	1446, 10, 55, 7, 55, 1448, 10, 55, 12, 55, 14, 55, 1451, 11, 55, 3, 56,
	3, 56, 3, 56, 7, 56, 1456, 10, 56, 12, 56, 14, 56, 1459, 11, 56, 3, 57,
	3, 57, 3, 57, 7, 57, 1464, 10, 57, 12, 57, 14, 57, 1467, 11, 57, 3, 58,
	3, 58, 3, 58, 7, 58, 1472, 10, 58, 12, 58, 14, 58, 1475, 11, 58, 3, 59,
	3, 59, 3, 59, 7, 59, 1480, 10, 59, 12, 59, 14, 59, 1483, 11, 59, 3, 60,
	3, 60, 3, 60, 7, 60, 1488, 10, 60, 12, 60, 14, 60, 1491, 11, 60, 3, 61,
	3, 61, 3, 61, 7, 61, 1496, 10, 61, 12, 61, 14, 61, 1499, 11, 61, 3, 62,
	3, 62, 3, 62, 7, 62, 1504, 10, 62, 12, 62, 14, 62, 1507, 11, 62, 3, 63,
	3, 63, 3, 63, 5, 63, 1512, 10, 63, 3, 63, 3, 63, 3, 63, 3, 63, 5, 63, 1518,
	10, 63, 7, 63, 1520, 10, 63, 12, 63, 14, 63, 1523, 11, 63, 3, 64, 3, 64,
	3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3,
	66, 5, 66, 1538, 10, 66, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67,
	5, 67, 1547, 10, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 1562, 10, 67, 3, 67, 3, 67,
	3, 67, 5, 67, 1567, 10, 67, 3, 68, 3, 68, 3, 69, 3, 69, 3, 70, 3, 70, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72,
	3, 72, 3, 73, 3, 73, 5, 73, 1589, 10, 73, 3, 73, 5, 73, 1592, 10, 73, 3,
	73, 5, 73, 1595, 10, 73, 3, 73, 3, 73, 3, 73, 7, 73, 1600, 10, 73, 12,
	73, 14, 73, 1603, 11, 73, 3, 73, 5, 73, 1606, 10, 73, 3, 73, 3, 73, 3,
	73, 3, 73, 5, 73, 1612, 10, 73, 3, 73, 5, 73, 1615, 10, 73, 3, 73, 5, 73,
	1618, 10, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 7, 73, 1626, 10,
	73, 12, 73, 14, 73, 1629, 11, 73, 3, 73, 5, 73, 1632, 10, 73, 3, 73, 3,
	73, 5, 73, 1636, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 1642, 10, 74,
	3, 75, 3, 75, 3, 75, 7, 75, 1647, 10, 75, 12, 75, 14, 75, 1650, 11, 75,
	3, 76, 7, 76, 1653, 10, 76, 12, 76, 14, 76, 1656, 11, 76, 3, 76, 3, 76,
	3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 1665, 10, 77, 3, 78, 3, 78, 5,
	78, 1669, 10, 78, 3, 78, 3, 78, 3, 78, 7, 78, 1674, 10, 78, 12, 78, 14,
	78, 1677, 11, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 1684, 10, 78,
	3, 78, 3, 78, 3, 78, 5, 78, 1689, 10, 78, 3, 78, 3, 78, 3, 78, 7, 78, 1694,
	10, 78, 12, 78, 14, 78, 1697, 11, 78, 3, 78, 3, 78, 3, 78, 5, 78, 1702,
	10, 78, 3, 79, 3, 79, 7, 79, 1706, 10, 79, 12, 79, 14, 79, 1709, 11, 79,
	3, 79, 3, 79, 3, 79, 5, 79, 1714, 10, 79, 3, 80, 3, 80, 3, 80, 7, 80, 1719,
	10, 80, 12, 80, 14, 80, 1722, 11, 80, 3, 81, 7, 81, 1725, 10, 81, 12, 81,
	14, 81, 1728, 11, 81, 3, 81, 3, 81, 3, 82, 3, 82, 5, 82, 1734, 10, 82,
	3, 82, 5, 82, 1737, 10, 82, 3, 82, 5, 82, 1740, 10, 82, 3, 82, 5, 82, 1743,
	10, 82, 3, 82, 3, 82, 5, 82, 1747, 10, 82, 3, 82, 5, 82, 1750, 10, 82,
	5, 82, 1752, 10, 82, 3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 85, 7, 85, 1760,
	10, 85, 12, 85, 14, 85, 1763, 11, 85, 3, 85, 3, 85, 7, 85, 1767, 10, 85,
	12, 85, 14, 85, 1770, 11, 85, 3, 85, 3, 85, 7, 85, 1774, 10, 85, 12, 85,
	14, 85, 1777, 11, 85, 3, 85, 3, 85, 7, 85, 1781, 10, 85, 12, 85, 14, 85,
	1784, 11, 85, 3, 85, 3, 85, 7, 85, 1788, 10, 85, 12, 85, 14, 85, 1791,
	11, 85, 3, 85, 3, 85, 7, 85, 1795, 10, 85, 12, 85, 14, 85, 1798, 11, 85,
	3, 85, 3, 85, 7, 85, 1802, 10, 85, 12, 85, 14, 85, 1805, 11, 85, 3, 85,
	3, 85, 7, 85, 1809, 10, 85, 12, 85, 14, 85, 1812, 11, 85, 3, 85, 5, 85,
	1815, 10, 85, 3, 86, 3, 86, 5, 86, 1819, 10, 86, 3, 86, 5, 86, 1822, 10,
	86, 3, 86, 3, 86, 3, 86, 3, 87, 3, 87, 3, 87, 7, 87, 1830, 10, 87, 12,
	87, 14, 87, 1833, 11, 87, 3, 88, 3, 88, 3, 88, 3, 88, 7, 88, 1839, 10,
	88, 12, 88, 14, 88, 1842, 11, 88, 5, 88, 1844, 10, 88, 3, 89, 3, 89, 5,
	89, 1848, 10, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1853, 10, 89, 12, 89, 14,
	89, 1856, 11, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1862, 10, 89, 3, 89,
	3, 89, 3, 89, 7, 89, 1867, 10, 89, 12, 89, 14, 89, 1870, 11, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1878, 10, 89, 12, 89, 14, 89,
	1881, 11, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1887, 10, 89, 3, 89, 3,
	89, 3, 89, 7, 89, 1892, 10, 89, 12, 89, 14, 89, 1895, 11, 89, 3, 89, 3,
	89, 3, 89, 3, 89, 5, 89, 1901, 10, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1906,
	10, 89, 12, 89, 14, 89, 1909, 11, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89,
	1915, 10, 89, 3, 89, 5, 89, 1918, 10, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1923,
	10, 89, 12, 89, 14, 89, 1926, 11, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89,
	1932, 10, 89, 3, 89, 5, 89, 1935, 10, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1940,
	10, 89, 12, 89, 14, 89, 1943, 11, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89,
	1949, 10, 89, 3, 89, 5, 89, 1952, 10, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1957,
	10, 89, 12, 89, 14, 89, 1960, 11, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89,
	1966, 10, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1971, 10, 89, 12, 89, 14, 89,
	1974, 11, 89, 3, 89, 3, 89, 5, 89, 1978, 10, 89, 3, 90, 5, 90, 1981, 10,
	90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90,
	3, 91, 5, 91, 1994, 10, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3,
	91, 3, 91, 3, 92, 5, 92, 2005, 10, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92,
	3, 92, 3, 92, 3, 92, 3, 93, 5, 93, 2016, 10, 93, 3, 93, 3, 93, 3, 93, 3,
	93, 3, 93, 3, 93, 7, 93, 2024, 10, 93, 12, 93, 14, 93, 2027, 11, 93, 3,
	93, 3, 93, 3, 94, 5, 94, 2032, 10, 94, 3, 94, 3, 94, 3, 94, 3, 94, 7, 94,
	2038, 10, 94, 12, 94, 14, 94, 2041, 11, 94, 3, 94, 3, 94, 3, 94, 3, 94,
	3, 95, 5, 95, 2048, 10, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3,
	96, 5, 96, 2057, 10, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96,
	3, 96, 3, 97, 5, 97, 2068, 10, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 98, 3,
	98, 5, 98, 2076, 10, 98, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99,
	3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 5, 99, 2094,
	10, 99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100,
	3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 5, 100,
	2112, 10, 100, 3, 101, 3, 101, 3, 102, 3, 102, 3, 103, 3, 103, 3, 104,
	3, 104, 3, 105, 3, 105, 3, 106, 3, 106, 3, 107, 3, 107, 3, 108, 3, 108,
	3, 109, 3, 109, 3, 110, 3, 110, 3, 111, 3, 111, 3, 112, 3, 112, 3, 113,
	3, 113, 3, 114, 3, 114, 5, 114, 2142, 10, 114, 3, 114, 3, 114, 3, 114,
	7, 114, 2147, 10, 114, 12, 114, 14, 114, 2150, 11, 114, 3, 114, 3, 114,
	3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 116, 3, 116, 3, 116, 7, 116,
	2162, 10, 116, 12, 116, 14, 116, 2165, 11, 116, 3, 116, 3, 116, 3, 116,
	7, 116, 2170, 10, 116, 12, 116, 14, 116, 2173, 11, 116, 5, 116, 2175, 10,
	116, 3, 117, 3, 117, 3, 118, 3, 118, 3, 118, 3, 118, 5, 118, 2183, 10,
	118, 3, 118, 3, 118, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 120, 3,
	120, 5, 120, 2194, 10, 120, 3, 121, 3, 121, 3, 121, 7, 121, 2199, 10, 121,
	12, 121, 14, 121, 2202, 11, 121, 3, 121, 3, 121, 3, 121, 7, 121, 2207,
	10, 121, 12, 121, 14, 121, 2210, 11, 121, 5, 121, 2212, 10, 121, 3, 122,
	7, 122, 2215, 10, 122, 12, 122, 14, 122, 2218, 11, 122, 3, 122, 5, 122,
	2221, 10, 122, 3, 123, 7, 123, 2224, 10, 123, 12, 123, 14, 123, 2227, 11,
	123, 3, 123, 3, 123, 3, 123, 3, 123, 5, 123, 2233, 10, 123, 3, 123, 3,
	123, 3, 124, 3, 124, 7, 124, 2239, 10, 124, 12, 124, 14, 124, 2242, 11,
	124, 3, 124, 3, 124, 3, 125, 3, 125, 5, 125, 2248, 10, 125, 3, 126, 3,
	126, 3, 126, 3, 126, 3, 126, 5, 126, 2255, 10, 126, 3, 127, 3, 127, 3,
	127, 3, 127, 3, 127, 3, 127, 3, 127, 5, 127, 2264, 10, 127, 3, 128, 3,
	128, 3, 128, 3, 128, 3, 128, 3, 128, 7, 128, 2272, 10, 128, 12, 128, 14,
	128, 2275, 11, 128, 3, 128, 3, 128, 3, 129, 3, 129, 3, 129, 7, 129, 2282,
	10, 129, 12, 129, 14, 129, 2285, 11, 129, 3, 129, 3, 129, 3, 129, 3, 129,
	3, 129, 5, 129, 2292, 10, 129, 3, 129, 5, 129, 2295, 10, 129, 3, 130, 3,
	130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3,
	131, 3, 131, 3, 131, 3, 131, 3, 132, 3, 132, 3, 132, 5, 132, 2314, 10,
	132, 3, 132, 7, 132, 2317, 10, 132, 12, 132, 14, 132, 2320, 11, 132, 3,
	132, 3, 132, 3, 133, 3, 133, 5, 133, 2326, 10, 133, 3, 133, 5, 133, 2329,
	10, 133, 3, 133, 3, 133, 3, 133, 3, 134, 3, 134, 3, 134, 7, 134, 2337,
	10, 134, 12, 134, 14, 134, 2340, 11, 134, 3, 135, 3, 135, 3, 135, 3, 135,
	3, 136, 3, 136, 3, 136, 3, 137, 3, 137, 3, 137, 3, 138, 3, 138, 3, 138,
	5, 138, 2355, 10, 138, 3, 138, 3, 138, 3, 139, 3, 139, 3, 139, 5, 139,
	2362, 10, 139, 3, 139, 3, 139, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140,
	3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 3, 140, 5, 140, 2378, 10,
	140, 3, 141, 3, 141, 3, 141, 3, 141, 3, 142, 3, 142, 7, 142, 2386, 10,
	142, 12, 142, 14, 142, 2389, 11, 142, 3, 142, 5, 142, 2392, 10, 142, 3,
	143, 3, 143, 3, 143, 3, 143, 7, 143, 2398, 10, 143, 12, 143, 14, 143, 2401,
	11, 143, 5, 143, 2403, 10, 143, 3, 143, 7, 143, 2406, 10, 143, 12, 143,
	14, 143, 2409, 11, 143, 3, 143, 3, 143, 3, 144, 3, 144, 3, 144, 3, 144,
	3, 145, 3, 145, 3, 145, 3, 145, 7, 145, 2421, 10, 145, 12, 145, 14, 145,
	2424, 11, 145, 5, 145, 2426, 10, 145, 3, 145, 7, 145, 2429, 10, 145, 12,
	145, 14, 145, 2432, 11, 145, 3, 145, 3, 145, 3, 146, 3, 146, 3, 146, 3,
	146, 7, 146, 2440, 10, 146, 12, 146, 14, 146, 2443, 11, 146, 5, 146, 2445,
	10, 146, 3, 146, 7, 146, 2448, 10, 146, 12, 146, 14, 146, 2451, 11, 146,
	3, 146, 3, 146, 3, 147, 7, 147, 2456, 10, 147, 12, 147, 14, 147, 2459,
	11, 147, 3, 147, 3, 147, 3, 147, 3, 147, 7, 147, 2465, 10, 147, 12, 147,
	14, 147, 2468, 11, 147, 3, 147, 3, 147, 7, 147, 2472, 10, 147, 12, 147,
	14, 147, 2475, 11, 147, 3, 147, 3, 147, 7, 147, 2479, 10, 147, 12, 147,
	14, 147, 2482, 11, 147, 3, 147, 3, 147, 7, 147, 2486, 10, 147, 12, 147,
	14, 147, 2489, 11, 147, 3, 147, 3, 147, 7, 147, 2493, 10, 147, 12, 147,
	14, 147, 2496, 11, 147, 3, 147, 3, 147, 7, 147, 2500, 10, 147, 12, 147,
	14, 147, 2503, 11, 147, 3, 147, 3, 147, 3, 147, 3, 147, 7, 147, 2509, 10,
	147, 12, 147, 14, 147, 2512, 11, 147, 3, 147, 3, 147, 7, 147, 2516, 10,
	147, 12, 147, 14, 147, 2519, 11, 147, 3, 147, 3, 147, 3, 147, 3, 147, 7,
	147, 2525, 10, 147, 12, 147, 14, 147, 2528, 11, 147, 3, 147, 3, 147, 7,
	147, 2532, 10, 147, 12, 147, 14, 147, 2535, 11, 147, 3, 147, 3, 147, 7,
	147, 2539, 10, 147, 12, 147, 14, 147, 2542, 11, 147, 3, 147, 3, 147, 7,
	147, 2546, 10, 147, 12, 147, 14, 147, 2549, 11, 147, 3, 147, 3, 147, 7,
	147, 2553, 10, 147, 12, 147, 14, 147, 2556, 11, 147, 3, 147, 5, 147, 2559,
	10, 147, 3, 148, 3, 148, 7, 148, 2563, 10, 148, 12, 148, 14, 148, 2566,
	11, 148, 3, 148, 5, 148, 2569, 10, 148, 3, 149, 7, 149, 2572, 10, 149,
	12, 149, 14, 149, 2575, 11, 149, 3, 149, 3, 149, 3, 149, 3, 149, 7, 149,
	2581, 10, 149, 12, 149, 14, 149, 2584, 11, 149, 3, 149, 3, 149, 7, 149,
	2588, 10, 149, 12, 149, 14, 149, 2591, 11, 149, 3, 149, 3, 149, 7, 149,
	2595, 10, 149, 12, 149, 14, 149, 2598, 11, 149, 3, 149, 3, 149, 7, 149,
	2602, 10, 149, 12, 149, 14, 149, 2605, 11, 149, 3, 149, 3, 149, 7, 149,
	2609, 10, 149, 12, 149, 14, 149, 2612, 11, 149, 3, 149, 3, 149, 7, 149,
	2616, 10, 149, 12, 149, 14, 149, 2619, 11, 149, 3, 149, 5, 149, 2622, 10,
	149, 3, 150, 3, 150, 3, 150, 3, 150, 3, 150, 3, 150, 3, 150, 3, 150, 5,
	150, 2632, 10, 150, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3, 151, 3,
	151, 5, 151, 2641, 10, 151, 3, 152, 3, 152, 3, 152, 3, 152, 3, 152, 3,
	152, 3, 152, 3, 152, 5, 152, 2651, 10, 152, 3, 153, 3, 153, 3, 153, 3,
	153, 3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 3, 153, 3,
	153, 5, 153, 2666, 10, 153, 3, 154, 3, 154, 3, 154, 3, 154, 3, 155, 3,
	155, 3, 155, 3, 155, 3, 155, 7, 155, 2677, 10, 155, 12, 155, 14, 155, 2680,
	11, 155, 3, 156, 3, 156, 3, 156, 3, 156, 3, 156, 5, 156, 2687, 10, 156,
	3, 157, 3, 157, 3, 157, 3, 158, 3, 158, 3, 158, 3, 158, 3, 158, 3, 158,
	3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 5, 159, 2705, 10,
	159, 3, 159, 5, 159, 2708, 10, 159, 3, 160, 3, 160, 3, 160, 3, 160, 3,
	160, 3, 160, 3, 160, 3, 160, 3, 160, 3, 160, 3, 160, 3, 160, 7, 160, 2722,
	10, 160, 12, 160, 14, 160, 2725, 11, 160, 3, 160, 3, 160, 5, 160, 2729,
	10, 160, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 5, 161,
	2738, 10, 161, 3, 161, 5, 161, 2741, 10, 161, 3, 162, 3, 162, 3, 162, 3,
	162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 7,
	162, 2755, 10, 162, 12, 162, 14, 162, 2758, 11, 162, 3, 162, 3, 162, 5,
	162, 2762, 10, 162, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 7,
	163, 2770, 10, 163, 12, 163, 14, 163, 2773, 11, 163, 3, 163, 3, 163, 3,
	163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 7, 163, 2783, 10, 163, 12,
	163, 14, 163, 2786, 11, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3, 163, 3,
	163, 3, 163, 3, 163, 7, 163, 2796, 10, 163, 12, 163, 14, 163, 2799, 11,
	163, 3, 163, 3, 163, 5, 163, 2803, 10, 163, 3, 164, 3, 164, 3, 164, 7,
	164, 2808, 10, 164, 12, 164, 14, 164, 2811, 11, 164, 3, 164, 3, 164, 3,
	164, 3, 164, 3, 164, 5, 164, 2818, 10, 164, 3, 164, 5, 164, 2821, 10, 164,
	3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 7, 165, 2829, 10, 165,
	12, 165, 14, 165, 2832, 11, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165,
	3, 165, 3, 165, 3, 165, 7, 165, 2842, 10, 165, 12, 165, 14, 165, 2845,
	11, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165,
	7, 165, 2855, 10, 165, 12, 165, 14, 165, 2858, 11, 165, 3, 165, 3, 165,
	5, 165, 2862, 10, 165, 3, 166, 3, 166, 3, 166, 7, 166, 2867, 10, 166, 12,
	166, 14, 166, 2870, 11, 166, 3, 166, 3, 166, 3, 166, 3, 166, 3, 166, 5,
	166, 2877, 10, 166, 3, 166, 5, 166, 2880, 10, 166, 3, 167, 3, 167, 3, 167,
	3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167,
	3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167, 3, 167,
	3, 167, 3, 167, 3, 167, 5, 167, 2906, 10, 167, 3, 168, 3, 168, 3, 168,
	3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168,
	3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168, 3, 168,
	3, 168, 3, 168, 3, 168, 5, 168, 2932, 10, 168, 3, 169, 3, 169, 3, 169,
	3, 169, 3, 169, 7, 169, 2939, 10, 169, 12, 169, 14, 169, 2942, 11, 169,
	5, 169, 2944, 10, 169, 3, 169, 5, 169, 2947, 10, 169, 3, 169, 3, 169, 3,
	170, 3, 170, 3, 170, 3, 170, 3, 170, 7, 170, 2956, 10, 170, 12, 170, 14,
	170, 2959, 11, 170, 5, 170, 2961, 10, 170, 3, 170, 5, 170, 2964, 10, 170,
	3, 170, 3, 170, 3, 171, 3, 171, 7, 171, 2970, 10, 171, 12, 171, 14, 171,
	2973, 11, 171, 3, 171, 3, 171, 3, 172, 3, 172, 3, 172, 3, 172, 3, 172,
	5, 172, 2982, 10, 172, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173,
	3, 173, 3, 173, 5, 173, 2992, 10, 173, 3, 174, 3, 174, 3, 174, 3, 174,
	3, 174, 3, 174, 3, 174, 3, 174, 5, 174, 3002, 10, 174, 3, 175, 3, 175,
	3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 5, 175, 3013, 10,
	175, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 3, 176, 5,
	176, 3023, 10, 176, 3, 177, 3, 177, 5, 177, 3027, 10, 177, 3, 177, 3, 177,
	3, 177, 3, 178, 3, 178, 3, 178, 5, 178, 3035, 10, 178, 3, 178, 3, 178,
	3, 178, 3, 178, 3, 178, 3, 179, 3, 179, 3, 179, 7, 179, 3045, 10, 179,
	12, 179, 14, 179, 3048, 11, 179, 3, 180, 3, 180, 3, 180, 7, 180, 3053,
	10, 180, 12, 180, 14, 180, 3056, 11, 180, 3, 181, 3, 181, 3, 181, 3, 181,
	3, 181, 3, 181, 3, 181, 3, 181, 3, 181, 3, 181, 3, 181, 5, 181, 3069, 10,
	181, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3,
	182, 3, 182, 3, 182, 5, 182, 3082, 10, 182, 3, 183, 3, 183, 5, 183, 3086,
	10, 183, 3, 184, 3, 184, 5, 184, 3090, 10, 184, 3, 185, 3, 185, 3, 185,
	3, 185, 3, 185, 5, 185, 3097, 10, 185, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186,
	3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 5, 186, 3146, 10,
	186, 3, 187, 3, 187, 3, 188, 3, 188, 3, 189, 3, 189, 3, 190, 3, 190, 3,
	191, 3, 191, 3, 192, 3, 192, 3, 193, 3, 193, 3, 194, 3, 194, 3, 195, 3,
	195, 3, 196, 3, 196, 3, 197, 3, 197, 3, 198, 3, 198, 3, 199, 3, 199, 3,
	200, 3, 200, 3, 201, 3, 201, 3, 202, 3, 202, 3, 203, 3, 203, 3, 204, 3,
	204, 3, 204, 3, 204, 3, 204, 3, 204, 3, 204, 3, 204, 5, 204, 3190, 10,
	204, 3, 205, 3, 205, 5, 205, 3194, 10, 205, 3, 205, 3, 205, 3, 205, 3,
	205, 5, 205, 3200, 10, 205, 3, 205, 3, 205, 3, 205, 3, 205, 3, 206, 3,
	206, 5, 206, 3208, 10, 206, 3, 206, 3, 206, 3, 206, 3, 206, 5, 206, 3214,
	10, 206, 3, 206, 3, 206, 3, 206, 3, 206, 3, 207, 3, 207, 3, 208, 3, 208,
	3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209,
	3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 5, 209, 3238, 10, 209, 3, 210,
	3, 210, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211, 3, 211,
	3, 211, 3, 211, 3, 211, 3, 211, 5, 211, 3254, 10, 211, 3, 212, 3, 212,
	3, 212, 3, 212, 3, 212, 3, 212, 3, 212, 3, 212, 3, 212, 5, 212, 3265, 10,
	212, 5, 212, 3267, 10, 212, 3, 212, 3, 212, 3, 212, 3, 213, 3, 213, 3,
	213, 3, 213, 3, 213, 3, 213, 3, 213, 3, 213, 3, 213, 5, 213, 3281, 10,
	213, 5, 213, 3283, 10, 213, 3, 213, 3, 213, 3, 213, 3, 214, 3, 214, 3,
	214, 3, 214, 3, 214, 3, 214, 3, 214, 3, 214, 3, 214, 3, 214, 3, 214, 5,
	214, 3299, 10, 214, 3, 214, 3, 214, 5, 214, 3303, 10, 214, 3, 214, 3, 214,
	5, 214, 3307, 10, 214, 3, 214, 3, 214, 5, 214, 3311, 10, 214, 3, 214, 3,
	214, 5, 214, 3315, 10, 214, 5, 214, 3317, 10, 214, 5, 214, 3319, 10, 214,
	5, 214, 3321, 10, 214, 5, 214, 3323, 10, 214, 5, 214, 3325, 10, 214, 3,
	214, 3, 214, 3, 214, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3,
	215, 3, 215, 3, 215, 5, 215, 3339, 10, 215, 5, 215, 3341, 10, 215, 3, 215,
	3, 215, 3, 215, 3, 216, 3, 216, 3, 216, 3, 216, 3, 216, 3, 216, 3, 216,
	3, 216, 3, 216, 5, 216, 3355, 10, 216, 5, 216, 3357, 10, 216, 3, 216, 3,
	216, 3, 216, 3, 217, 3, 217, 3, 217, 3, 217, 3, 217, 3, 217, 3, 217, 3,
	217, 3, 217, 3, 217, 3, 217, 5, 217, 3373, 10, 217, 3, 217, 3, 217, 5,
	217, 3377, 10, 217, 3, 217, 3, 217, 5, 217, 3381, 10, 217, 3, 217, 3, 217,
	5, 217, 3385, 10, 217, 3, 217, 3, 217, 5, 217, 3389, 10, 217, 5, 217, 3391,
	10, 217, 5, 217, 3393, 10, 217, 5, 217, 3395, 10, 217, 5, 217, 3397, 10,
	217, 5, 217, 3399, 10, 217, 3, 217, 3, 217, 3, 217, 3, 218, 3, 218, 3,
	218, 3, 218, 3, 218, 3, 218, 3, 218, 3, 218, 3, 218, 5, 218, 3413, 10,
	218, 5, 218, 3415, 10, 218, 3, 218, 3, 218, 3, 218, 3, 219, 3, 219, 3,
	219, 3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 5, 219, 3429, 10,
	219, 3, 219, 3, 219, 5, 219, 3433, 10, 219, 3, 219, 3, 219, 5, 219, 3437,
	10, 219, 5, 219, 3439, 10, 219, 5, 219, 3441, 10, 219, 5, 219, 3443, 10,
	219, 3, 219, 3, 219, 3, 219, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3,
	220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 5, 220, 3459, 10, 220, 3,
	220, 3, 220, 5, 220, 3463, 10, 220, 3, 220, 3, 220, 5, 220, 3467, 10, 220,
	5, 220, 3469, 10, 220, 5, 220, 3471, 10, 220, 5, 220, 3473, 10, 220, 3,
	220, 3, 220, 3, 220, 3, 221, 3, 221, 3, 221, 3, 221, 3, 221, 3, 221, 3,
	221, 5, 221, 3485, 10, 221, 5, 221, 3487, 10, 221, 3, 221, 3, 221, 3, 221,
	3, 222, 3, 222, 3, 222, 3, 222, 3, 222, 3, 222, 3, 222, 3, 222, 3, 222,
	5, 222, 3501, 10, 222, 5, 222, 3503, 10, 222, 3, 222, 3, 222, 3, 222, 3,
	223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3,
	223, 3, 223, 5, 223, 3519, 10, 223, 5, 223, 3521, 10, 223, 3, 223, 3, 223,
	3, 223, 3, 224, 3, 224, 3, 225, 3, 225, 3, 226, 3, 226, 3, 227, 3, 227,
	3, 227, 3, 227, 3, 227, 3, 227, 5, 227, 3538, 10, 227, 3, 228, 3, 228,
	3, 228, 3, 228, 3, 228, 3, 228, 5, 228, 3546, 10, 228, 3, 229, 3, 229,
	3, 230, 3, 230, 3, 231, 3, 231, 3, 232, 3, 232, 3, 233, 3, 233, 3, 234,
	3, 234, 3, 235, 3, 235, 3, 236, 3, 236, 3, 237, 3, 237, 3, 238, 5, 238,
	3567, 10, 238, 3, 238, 3, 238, 3, 238, 5, 238, 3572, 10, 238, 3, 239, 3,
	239, 3, 239, 3, 239, 5, 239, 3578, 10, 239, 3, 240, 3, 240, 3, 241, 3,
	241, 5, 241, 3584, 10, 241, 3, 242, 3, 242, 3, 242, 3, 242, 3, 242, 5,
	242, 3591, 10, 242, 3, 242, 3, 242, 3, 243, 3, 243, 3, 243, 3, 243, 3,
	243, 5, 243, 3600, 10, 243, 3, 244, 3, 244, 3, 244, 3, 244, 3, 244, 3,
	244, 3, 244, 3, 244, 3, 244, 3, 244, 3, 244, 3, 244, 3, 244, 3, 244, 3,
	244, 3, 244, 3, 244, 3, 244, 3, 244, 5, 244, 3621, 10, 244, 3, 245, 3,
	245, 3, 246, 3, 246, 3, 246, 3, 246, 7, 246, 3629, 10, 246, 12, 246, 14,
	246, 3632, 11, 246, 3, 246, 3, 246, 3, 247, 3, 247, 3, 247, 3, 247, 7,
	247, 3640, 10, 247, 12, 247, 14, 247, 3643, 11, 247, 3, 247, 3, 247, 3,
	248, 3, 248, 3, 248, 3, 248, 3, 248, 3, 249, 3, 249, 3, 249, 3, 249, 7,
	249, 3656, 10, 249, 12, 249, 14, 249, 3659, 11, 249, 3, 249, 3, 249, 3,
	250, 3, 250, 3, 250, 3, 250, 3, 250, 3, 251, 3, 251, 3, 251, 3, 251, 3,
	251, 3, 252, 3, 252, 3, 252, 3, 252, 7, 252, 3677, 10, 252, 12, 252, 14,
	252, 3680, 11, 252, 3, 252, 3, 252, 3, 253, 3, 253, 3, 253, 3, 253, 3,
	253, 3, 253, 3, 253, 3, 253, 3, 253, 7, 253, 3693, 10, 253, 12, 253, 14,
	253, 3696, 11, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3,
	253, 3, 253, 7, 253, 3706, 10, 253, 12, 253, 14, 253, 3709, 11, 253, 3,
	253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 3,
	253, 5, 253, 3721, 10, 253, 3, 254, 3, 254, 3, 254, 3, 254, 7, 254, 3727,
	10, 254, 12, 254, 14, 254, 3730, 11, 254, 3, 254, 3, 254, 3, 255, 3, 255,
	3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 7, 255, 3743, 10,
	255, 12, 255, 14, 255, 3746, 11, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3,
	255, 3, 255, 3, 255, 3, 255, 7, 255, 3756, 10, 255, 12, 255, 14, 255, 3759,
	11, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255, 3, 255,
	3, 255, 3, 255, 5, 255, 3771, 10, 255, 3, 256, 3, 256, 7, 256, 3775, 10,
	256, 12, 256, 14, 256, 3778, 11, 256, 3, 256, 3, 256, 3, 256, 3, 256, 7,
	256, 3784, 10, 256, 12, 256, 14, 256, 3787, 11, 256, 5, 256, 3789, 10,
	256, 3, 256, 3, 256, 3, 257, 3, 257, 7, 257, 3795, 10, 257, 12, 257, 14,
	257, 3798, 11, 257, 3, 257, 3, 257, 3, 257, 3, 257, 7, 257, 3804, 10, 257,
	12, 257, 14, 257, 3807, 11, 257, 5, 257, 3809, 10, 257, 3, 257, 3, 257,
	3, 258, 3, 258, 3, 258, 3, 258, 3, 258, 7, 258, 3818, 10, 258, 12, 258,
	14, 258, 3821, 11, 258, 5, 258, 3823, 10, 258, 3, 258, 5, 258, 3826, 10,
	258, 3, 259, 3, 259, 7, 259, 3830, 10, 259, 12, 259, 14, 259, 3833, 11,
	259, 3, 259, 3, 259, 3, 259, 3, 259, 7, 259, 3839, 10, 259, 12, 259, 14,
	259, 3842, 11, 259, 5, 259, 3844, 10, 259, 3, 259, 3, 259, 3, 260, 3, 260,
	3, 261, 3, 261, 3, 262, 3, 262, 3, 263, 3, 263, 3, 263, 3, 263, 3, 263,
	3, 263, 3, 263, 5, 263, 3861, 10, 263, 3, 264, 3, 264, 3, 264, 3, 264,
	3, 264, 3, 264, 3, 264, 3, 264, 3, 264, 3, 264, 3, 264, 3, 264, 3, 264,
	3, 264, 3, 264, 5, 264, 3878, 10, 264, 3, 265, 3, 265, 3, 266, 3, 266,
	3, 266, 7, 266, 3885, 10, 266, 12, 266, 14, 266, 3888, 11, 266, 3, 266,
	3, 266, 3, 266, 3, 266, 7, 266, 3894, 10, 266, 12, 266, 14, 266, 3897,
	11, 266, 3, 266, 3, 266, 3, 266, 3, 266, 7, 266, 3903, 10, 266, 12, 266,
	14, 266, 3906, 11, 266, 3, 267, 3, 267, 7, 267, 3910, 10, 267, 12, 267,
	14, 267, 3913, 11, 267, 3, 267, 3, 267, 3, 267, 3, 267, 5, 267, 3919, 10,
	267, 3, 268, 3, 268, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 5,
	269, 3929, 10, 269, 3, 270, 3, 270, 3, 270, 7, 270, 3934, 10, 270, 12,
	270, 14, 270, 3937, 11, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 271, 3,
	271, 3, 271, 7, 271, 3946, 10, 271, 12, 271, 14, 271, 3949, 11, 271, 3,
	271, 3, 271, 5, 271, 3953, 10, 271, 3, 271, 3, 271, 7, 271, 3957, 10, 271,
	12, 271, 14, 271, 3960, 11, 271, 3, 271, 3, 271, 3, 271, 3, 271, 7, 271,
	3966, 10, 271, 12, 271, 14, 271, 3969, 11, 271, 3, 271, 3, 271, 3, 271,
	3, 271, 7, 271, 3975, 10, 271, 12, 271, 14, 271, 3978, 11, 271, 3, 272,
	3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 5, 272, 3986, 10, 272, 3, 273,
	3, 273, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274,
	3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 3, 274, 5, 274, 4005, 10,
	274, 3, 275, 3, 275, 3, 276, 3, 276, 3, 276, 3, 276, 3, 276, 3, 276, 3,
	276, 3, 276, 3, 276, 3, 276, 3, 276, 5, 276, 4020, 10, 276, 3, 277, 3,
	277, 3, 277, 3, 277, 3, 277, 3, 277, 3, 277, 3, 277, 3, 277, 3, 277, 3,
	277, 5, 277, 4033, 10, 277, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3,
	278, 3, 278, 6, 278, 4042, 10, 278, 13, 278, 14, 278, 4043, 3, 278, 3,
	278, 3, 278, 3, 278, 3, 278, 6, 278, 4051, 10, 278, 13, 278, 14, 278, 4052,
	3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278,
	3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278, 3, 278,
	5, 278, 4073, 10, 278, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279,
	3, 279, 3, 279, 3, 279, 7, 279, 4084, 10, 279, 12, 279, 14, 279, 4087,
	11, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279,
	7, 279, 4097, 10, 279, 12, 279, 14, 279, 4100, 11, 279, 3, 279, 3, 279,
	3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 5, 279,
	4112, 10, 279, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280,
	3, 280, 3, 280, 7, 280, 4123, 10, 280, 12, 280, 14, 280, 4126, 11, 280,
	3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 7, 280,
	4136, 10, 280, 12, 280, 14, 280, 4139, 11, 280, 3, 280, 3, 280, 3, 280,
	3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 5, 280, 4151, 10,
	280, 3, 281, 3, 281, 3, 281, 3, 281, 3, 281, 3, 281, 3, 281, 3, 281, 3,
	281, 3, 281, 3, 281, 3, 281, 3, 281, 3, 281, 3, 281, 5, 281, 4168, 10,
	281, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3,
	282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3,
	282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3,
	282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3,
	282, 3, 282, 5, 282, 4207, 10, 282, 3, 283, 3, 283, 3, 283, 3, 283, 3,
	283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 5,
	283, 4222, 10, 283, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 3,
	284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 5, 284, 4237, 10,
	284, 3, 285, 3, 285, 3, 286, 3, 286, 3, 286, 3, 286, 3, 286, 7, 286, 4246,
	10, 286, 12, 286, 14, 286, 4249, 11, 286, 3, 286, 3, 286, 3, 286, 3, 287,
	3, 287, 3, 287, 3, 287, 3, 287, 5, 287, 4259, 10, 287, 3, 288, 3, 288,
	3, 289, 3, 289, 5, 289, 4265, 10, 289, 3, 290, 3, 290, 3, 291, 3, 291,
	3, 292, 3, 292, 3, 293, 3, 293, 5, 293, 4275, 10, 293, 3, 294, 3, 294,
	3, 294, 3, 294, 3, 294, 7, 294, 4282, 10, 294, 12, 294, 14, 294, 4285,
	11, 294, 3, 295, 3, 295, 3, 296, 3, 296, 3, 297, 3, 297, 3, 298, 3, 298,
	3, 299, 3, 299, 3, 300, 3, 300, 3, 301, 3, 301, 3, 302, 3, 302, 3, 303,
	3, 303, 3, 304, 3, 304, 5, 304, 4307, 10, 304, 3, 305, 3, 305, 3, 306,
	3, 306, 3, 307, 3, 307, 3, 308, 3, 308, 3, 309, 3, 309, 3, 310, 3, 310,
	3, 311, 3, 311, 3, 312, 3, 312, 3, 313, 3, 313, 3, 314, 3, 314, 3, 315,
	3, 315, 3, 316, 3, 316, 3, 317, 3, 317, 3, 318, 3, 318, 3, 319, 3, 319,
	3, 320, 3, 320, 3, 321, 3, 321, 5, 321, 4343, 10, 321, 3, 322, 3, 322,
	3, 322, 5, 322, 4348, 10, 322, 3, 323, 3, 323, 3, 324, 3, 324, 3, 325,
	3, 325, 3, 326, 3, 326, 3, 327, 3, 327, 3, 328, 3, 328, 3, 329, 3, 329,
	3, 330, 3, 330, 3, 331, 3, 331, 3, 332, 3, 332, 3, 333, 3, 333, 3, 333,
	3, 333, 5, 333, 4374, 10, 333, 3, 333, 3, 333, 3, 333, 3, 333, 3, 333,
	5, 333, 4381, 10, 333, 7, 333, 4383, 10, 333, 12, 333, 14, 333, 4386, 11,
	333, 3, 334, 3, 334, 3, 334, 3, 334, 5, 334, 4392, 10, 334, 3, 334, 3,
	334, 3, 334, 3, 334, 3, 334, 5, 334, 4399, 10, 334, 7, 334, 4401, 10, 334,
	12, 334, 14, 334, 4404, 11, 334, 3, 334, 2, 2, 335, 2, 4, 6, 8, 10, 12,
	14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
	50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
	86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
	118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146,
	148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176,
	178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206,
	208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236,
	238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266,
	268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296,
	298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326,
	328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356,
	358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386,
	388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416,
	418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446,
	448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476,
	478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506,
	508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536,
	538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566,
	568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596,
	598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624, 626,
	628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656,
	658, 660, 662, 664, 666, 2, 24, 3, 2, 3, 4, 4, 2, 98, 98, 122, 122, 6,
	2, 106, 107, 115, 119, 124, 124, 128, 129, 4, 2, 59, 59, 110, 110, 6, 2,
	81, 81, 104, 104, 106, 106, 125, 125, 6, 2, 82, 82, 105, 105, 107, 107,
	126, 126, 4, 2, 56, 57, 76, 76, 5, 2, 59, 59, 88, 89, 110, 110, 4, 2, 24,
	24, 87, 87, 4, 2, 17, 18, 73, 74, 5, 2, 69, 69, 78, 78, 93, 94, 7, 2, 10,
	10, 67, 67, 70, 70, 75, 75, 130, 131, 4, 2, 16, 16, 72, 72, 4, 2, 96, 97,
	113, 114, 4, 2, 95, 95, 112, 112, 4, 2, 68, 68, 79, 79, 3, 2, 251, 252,
	5, 2, 295, 296, 298, 299, 307, 308, 3, 2, 290, 294, 3, 2, 300, 301, 3,
	2, 220, 246, 5, 2, 146, 147, 150, 160, 162, 219, 2, 4748, 2, 668, 3, 2,
	2, 2, 4, 671, 3, 2, 2, 2, 6, 676, 3, 2, 2, 2, 8, 688, 3, 2, 2, 2, 10, 717,
	3, 2, 2, 2, 12, 719, 3, 2, 2, 2, 14, 721, 3, 2, 2, 2, 16, 724, 3, 2, 2,
	2, 18, 732, 3, 2, 2, 2, 20, 739, 3, 2, 2, 2, 22, 747, 3, 2, 2, 2, 24, 762,
	3, 2, 2, 2, 26, 767, 3, 2, 2, 2, 28, 772, 3, 2, 2, 2, 30, 793, 3, 2, 2,
	2, 32, 795, 3, 2, 2, 2, 34, 807, 3, 2, 2, 2, 36, 831, 3, 2, 2, 2, 38, 844,
	3, 2, 2, 2, 40, 858, 3, 2, 2, 2, 42, 871, 3, 2, 2, 2, 44, 894, 3, 2, 2,
	2, 46, 935, 3, 2, 2, 2, 48, 993, 3, 2, 2, 2, 50, 1005, 3, 2, 2, 2, 52,
	1007, 3, 2, 2, 2, 54, 1041, 3, 2, 2, 2, 56, 1043, 3, 2, 2, 2, 58, 1066,
	3, 2, 2, 2, 60, 1068, 3, 2, 2, 2, 62, 1075, 3, 2, 2, 2, 64, 1087, 3, 2,
	2, 2, 66, 1139, 3, 2, 2, 2, 68, 1141, 3, 2, 2, 2, 70, 1145, 3, 2, 2, 2,
	72, 1149, 3, 2, 2, 2, 74, 1153, 3, 2, 2, 2, 76, 1157, 3, 2, 2, 2, 78, 1161,
	3, 2, 2, 2, 80, 1165, 3, 2, 2, 2, 82, 1289, 3, 2, 2, 2, 84, 1291, 3, 2,
	2, 2, 86, 1293, 3, 2, 2, 2, 88, 1308, 3, 2, 2, 2, 90, 1323, 3, 2, 2, 2,
	92, 1347, 3, 2, 2, 2, 94, 1349, 3, 2, 2, 2, 96, 1351, 3, 2, 2, 2, 98, 1362,
	3, 2, 2, 2, 100, 1379, 3, 2, 2, 2, 102, 1392, 3, 2, 2, 2, 104, 1398, 3,
	2, 2, 2, 106, 1400, 3, 2, 2, 2, 108, 1426, 3, 2, 2, 2, 110, 1452, 3, 2,
	2, 2, 112, 1460, 3, 2, 2, 2, 114, 1468, 3, 2, 2, 2, 116, 1476, 3, 2, 2,
	2, 118, 1484, 3, 2, 2, 2, 120, 1492, 3, 2, 2, 2, 122, 1500, 3, 2, 2, 2,
	124, 1508, 3, 2, 2, 2, 126, 1524, 3, 2, 2, 2, 128, 1528, 3, 2, 2, 2, 130,
	1537, 3, 2, 2, 2, 132, 1566, 3, 2, 2, 2, 134, 1568, 3, 2, 2, 2, 136, 1570,
	3, 2, 2, 2, 138, 1572, 3, 2, 2, 2, 140, 1574, 3, 2, 2, 2, 142, 1580, 3,
	2, 2, 2, 144, 1635, 3, 2, 2, 2, 146, 1641, 3, 2, 2, 2, 148, 1643, 3, 2,
	2, 2, 150, 1654, 3, 2, 2, 2, 152, 1664, 3, 2, 2, 2, 154, 1701, 3, 2, 2,
	2, 156, 1713, 3, 2, 2, 2, 158, 1715, 3, 2, 2, 2, 160, 1726, 3, 2, 2, 2,
	162, 1751, 3, 2, 2, 2, 164, 1753, 3, 2, 2, 2, 166, 1756, 3, 2, 2, 2, 168,
	1814, 3, 2, 2, 2, 170, 1816, 3, 2, 2, 2, 172, 1826, 3, 2, 2, 2, 174, 1843,
	3, 2, 2, 2, 176, 1977, 3, 2, 2, 2, 178, 1980, 3, 2, 2, 2, 180, 1993, 3,
	2, 2, 2, 182, 2004, 3, 2, 2, 2, 184, 2015, 3, 2, 2, 2, 186, 2031, 3, 2,
	2, 2, 188, 2047, 3, 2, 2, 2, 190, 2056, 3, 2, 2, 2, 192, 2067, 3, 2, 2,
	2, 194, 2073, 3, 2, 2, 2, 196, 2093, 3, 2, 2, 2, 198, 2111, 3, 2, 2, 2,
	200, 2113, 3, 2, 2, 2, 202, 2115, 3, 2, 2, 2, 204, 2117, 3, 2, 2, 2, 206,
	2119, 3, 2, 2, 2, 208, 2121, 3, 2, 2, 2, 210, 2123, 3, 2, 2, 2, 212, 2125,
	3, 2, 2, 2, 214, 2127, 3, 2, 2, 2, 216, 2129, 3, 2, 2, 2, 218, 2131, 3,
	2, 2, 2, 220, 2133, 3, 2, 2, 2, 222, 2135, 3, 2, 2, 2, 224, 2137, 3, 2,
	2, 2, 226, 2139, 3, 2, 2, 2, 228, 2153, 3, 2, 2, 2, 230, 2174, 3, 2, 2,
	2, 232, 2176, 3, 2, 2, 2, 234, 2178, 3, 2, 2, 2, 236, 2186, 3, 2, 2, 2,
	238, 2191, 3, 2, 2, 2, 240, 2211, 3, 2, 2, 2, 242, 2216, 3, 2, 2, 2, 244,
	2225, 3, 2, 2, 2, 246, 2236, 3, 2, 2, 2, 248, 2247, 3, 2, 2, 2, 250, 2254,
	3, 2, 2, 2, 252, 2256, 3, 2, 2, 2, 254, 2265, 3, 2, 2, 2, 256, 2294, 3,
	2, 2, 2, 258, 2296, 3, 2, 2, 2, 260, 2306, 3, 2, 2, 2, 262, 2310, 3, 2,
	2, 2, 264, 2323, 3, 2, 2, 2, 266, 2333, 3, 2, 2, 2, 268, 2341, 3, 2, 2,
	2, 270, 2345, 3, 2, 2, 2, 272, 2348, 3, 2, 2, 2, 274, 2351, 3, 2, 2, 2,
	276, 2358, 3, 2, 2, 2, 278, 2377, 3, 2, 2, 2, 280, 2379, 3, 2, 2, 2, 282,
	2391, 3, 2, 2, 2, 284, 2393, 3, 2, 2, 2, 286, 2412, 3, 2, 2, 2, 288, 2416,
	3, 2, 2, 2, 290, 2435, 3, 2, 2, 2, 292, 2558, 3, 2, 2, 2, 294, 2568, 3,
	2, 2, 2, 296, 2621, 3, 2, 2, 2, 298, 2631, 3, 2, 2, 2, 300, 2640, 3, 2,
	2, 2, 302, 2650, 3, 2, 2, 2, 304, 2665, 3, 2, 2, 2, 306, 2667, 3, 2, 2,
	2, 308, 2671, 3, 2, 2, 2, 310, 2686, 3, 2, 2, 2, 312, 2688, 3, 2, 2, 2,
	314, 2691, 3, 2, 2, 2, 316, 2707, 3, 2, 2, 2, 318, 2709, 3, 2, 2, 2, 320,
	2740, 3, 2, 2, 2, 322, 2742, 3, 2, 2, 2, 324, 2802, 3, 2, 2, 2, 326, 2820,
	3, 2, 2, 2, 328, 2861, 3, 2, 2, 2, 330, 2879, 3, 2, 2, 2, 332, 2905, 3,
	2, 2, 2, 334, 2931, 3, 2, 2, 2, 336, 2933, 3, 2, 2, 2, 338, 2950, 3, 2,
	2, 2, 340, 2967, 3, 2, 2, 2, 342, 2981, 3, 2, 2, 2, 344, 2991, 3, 2, 2,
	2, 346, 3001, 3, 2, 2, 2, 348, 3012, 3, 2, 2, 2, 350, 3022, 3, 2, 2, 2,
	352, 3024, 3, 2, 2, 2, 354, 3031, 3, 2, 2, 2, 356, 3041, 3, 2, 2, 2, 358,
	3049, 3, 2, 2, 2, 360, 3068, 3, 2, 2, 2, 362, 3081, 3, 2, 2, 2, 364, 3085,
	3, 2, 2, 2, 366, 3089, 3, 2, 2, 2, 368, 3096, 3, 2, 2, 2, 370, 3145, 3,
	2, 2, 2, 372, 3147, 3, 2, 2, 2, 374, 3149, 3, 2, 2, 2, 376, 3151, 3, 2,
	2, 2, 378, 3153, 3, 2, 2, 2, 380, 3155, 3, 2, 2, 2, 382, 3157, 3, 2, 2,
	2, 384, 3159, 3, 2, 2, 2, 386, 3161, 3, 2, 2, 2, 388, 3163, 3, 2, 2, 2,
	390, 3165, 3, 2, 2, 2, 392, 3167, 3, 2, 2, 2, 394, 3169, 3, 2, 2, 2, 396,
	3171, 3, 2, 2, 2, 398, 3173, 3, 2, 2, 2, 400, 3175, 3, 2, 2, 2, 402, 3177,
	3, 2, 2, 2, 404, 3179, 3, 2, 2, 2, 406, 3189, 3, 2, 2, 2, 408, 3191, 3,
	2, 2, 2, 410, 3205, 3, 2, 2, 2, 412, 3219, 3, 2, 2, 2, 414, 3221, 3, 2,
	2, 2, 416, 3237, 3, 2, 2, 2, 418, 3239, 3, 2, 2, 2, 420, 3253, 3, 2, 2,
	2, 422, 3255, 3, 2, 2, 2, 424, 3271, 3, 2, 2, 2, 426, 3287, 3, 2, 2, 2,
	428, 3329, 3, 2, 2, 2, 430, 3345, 3, 2, 2, 2, 432, 3361, 3, 2, 2, 2, 434,
	3403, 3, 2, 2, 2, 436, 3419, 3, 2, 2, 2, 438, 3447, 3, 2, 2, 2, 440, 3477,
	3, 2, 2, 2, 442, 3491, 3, 2, 2, 2, 444, 3507, 3, 2, 2, 2, 446, 3525, 3,
	2, 2, 2, 448, 3527, 3, 2, 2, 2, 450, 3529, 3, 2, 2, 2, 452, 3537, 3, 2,
	2, 2, 454, 3545, 3, 2, 2, 2, 456, 3547, 3, 2, 2, 2, 458, 3549, 3, 2, 2,
	2, 460, 3551, 3, 2, 2, 2, 462, 3553, 3, 2, 2, 2, 464, 3555, 3, 2, 2, 2,
	466, 3557, 3, 2, 2, 2, 468, 3559, 3, 2, 2, 2, 470, 3561, 3, 2, 2, 2, 472,
	3563, 3, 2, 2, 2, 474, 3566, 3, 2, 2, 2, 476, 3573, 3, 2, 2, 2, 478, 3579,
	3, 2, 2, 2, 480, 3583, 3, 2, 2, 2, 482, 3585, 3, 2, 2, 2, 484, 3599, 3,
	2, 2, 2, 486, 3620, 3, 2, 2, 2, 488, 3622, 3, 2, 2, 2, 490, 3624, 3, 2,
	2, 2, 492, 3635, 3, 2, 2, 2, 494, 3646, 3, 2, 2, 2, 496, 3651, 3, 2, 2,
	2, 498, 3662, 3, 2, 2, 2, 500, 3667, 3, 2, 2, 2, 502, 3672, 3, 2, 2, 2,
	504, 3720, 3, 2, 2, 2, 506, 3722, 3, 2, 2, 2, 508, 3770, 3, 2, 2, 2, 510,
	3772, 3, 2, 2, 2, 512, 3792, 3, 2, 2, 2, 514, 3812, 3, 2, 2, 2, 516, 3827,
	3, 2, 2, 2, 518, 3847, 3, 2, 2, 2, 520, 3849, 3, 2, 2, 2, 522, 3851, 3,
	2, 2, 2, 524, 3860, 3, 2, 2, 2, 526, 3877, 3, 2, 2, 2, 528, 3879, 3, 2,
	2, 2, 530, 3881, 3, 2, 2, 2, 532, 3918, 3, 2, 2, 2, 534, 3920, 3, 2, 2,
	2, 536, 3922, 3, 2, 2, 2, 538, 3930, 3, 2, 2, 2, 540, 3952, 3, 2, 2, 2,
	542, 3979, 3, 2, 2, 2, 544, 3987, 3, 2, 2, 2, 546, 4004, 3, 2, 2, 2, 548,
	4006, 3, 2, 2, 2, 550, 4019, 3, 2, 2, 2, 552, 4032, 3, 2, 2, 2, 554, 4072,
	3, 2, 2, 2, 556, 4111, 3, 2, 2, 2, 558, 4150, 3, 2, 2, 2, 560, 4167, 3,
	2, 2, 2, 562, 4206, 3, 2, 2, 2, 564, 4221, 3, 2, 2, 2, 566, 4236, 3, 2,
	2, 2, 568, 4238, 3, 2, 2, 2, 570, 4240, 3, 2, 2, 2, 572, 4258, 3, 2, 2,
	2, 574, 4260, 3, 2, 2, 2, 576, 4264, 3, 2, 2, 2, 578, 4266, 3, 2, 2, 2,
	580, 4268, 3, 2, 2, 2, 582, 4270, 3, 2, 2, 2, 584, 4272, 3, 2, 2, 2, 586,
	4276, 3, 2, 2, 2, 588, 4286, 3, 2, 2, 2, 590, 4288, 3, 2, 2, 2, 592, 4290,
	3, 2, 2, 2, 594, 4292, 3, 2, 2, 2, 596, 4294, 3, 2, 2, 2, 598, 4296, 3,
	2, 2, 2, 600, 4298, 3, 2, 2, 2, 602, 4300, 3, 2, 2, 2, 604, 4302, 3, 2,
	2, 2, 606, 4306, 3, 2, 2, 2, 608, 4308, 3, 2, 2, 2, 610, 4310, 3, 2, 2,
	2, 612, 4312, 3, 2, 2, 2, 614, 4314, 3, 2, 2, 2, 616, 4316, 3, 2, 2, 2,
	618, 4318, 3, 2, 2, 2, 620, 4320, 3, 2, 2, 2, 622, 4322, 3, 2, 2, 2, 624,
	4324, 3, 2, 2, 2, 626, 4326, 3, 2, 2, 2, 628, 4328, 3, 2, 2, 2, 630, 4330,
	3, 2, 2, 2, 632, 4332, 3, 2, 2, 2, 634, 4334, 3, 2, 2, 2, 636, 4336, 3,
	2, 2, 2, 638, 4338, 3, 2, 2, 2, 640, 4340, 3, 2, 2, 2, 642, 4344, 3, 2,
	2, 2, 644, 4349, 3, 2, 2, 2, 646, 4351, 3, 2, 2, 2, 648, 4353, 3, 2, 2,
	2, 650, 4355, 3, 2, 2, 2, 652, 4357, 3, 2, 2, 2, 654, 4359, 3, 2, 2, 2,
	656, 4361, 3, 2, 2, 2, 658, 4363, 3, 2, 2, 2, 660, 4365, 3, 2, 2, 2, 662,
	4367, 3, 2, 2, 2, 664, 4369, 3, 2, 2, 2, 666, 4387, 3, 2, 2, 2, 668, 669,
	7, 284, 2, 2, 669, 670, 5, 4, 3, 2, 670, 3, 3, 2, 2, 2, 671, 672, 7, 111,
	2, 2, 672, 673, 7, 303, 2, 2, 673, 674, 7, 266, 2, 2, 674, 675, 7, 303,
	2, 2, 675, 5, 3, 2, 2, 2, 676, 677, 7, 22, 2, 2, 677, 678, 5, 582, 292,
	2, 678, 679, 7, 247, 2, 2, 679, 683, 5, 8, 5, 2, 680, 682, 5, 10, 6, 2,
	681, 680, 3, 2, 2, 2, 682, 685, 3, 2, 2, 2, 683, 681, 3, 2, 2, 2, 683,
	684, 3, 2, 2, 2, 684, 686, 3, 2, 2, 2, 685, 683, 3, 2, 2, 2, 686, 687,
	7, 35, 2, 2, 687, 7, 3, 2, 2, 2, 688, 697, 7, 29, 2, 2, 689, 690, 5, 622,
	312, 2, 690, 691, 7, 250, 2, 2, 691, 693, 3, 2, 2, 2, 692, 689, 3, 2, 2,
	2, 692, 693, 3, 2, 2, 2, 693, 694, 3, 2, 2, 2, 694, 696, 5, 580, 291, 2,
	695, 692, 3, 2, 2, 2, 696, 699, 3, 2, 2, 2, 697, 695, 3, 2, 2, 2, 697,
	698, 3, 2, 2, 2, 698, 700, 3, 2, 2, 2, 699, 697, 3, 2, 2, 2, 700, 701,
	7, 247, 2, 2, 701, 9, 3, 2, 2, 2, 702, 703, 5, 12, 7, 2, 703, 704, 5, 18,
	10, 2, 704, 718, 3, 2, 2, 2, 705, 706, 5, 14, 8, 2, 706, 707, 5, 18, 10,
	2, 707, 718, 3, 2, 2, 2, 708, 709, 5, 14, 8, 2, 709, 710, 5, 22, 12, 2,
	710, 718, 3, 2, 2, 2, 711, 712, 5, 20, 11, 2, 712, 713, 5, 18, 10, 2, 713,
	718, 3, 2, 2, 2, 714, 715, 5, 20, 11, 2, 715, 716, 5, 22, 12, 2, 716, 718,
	3, 2, 2, 2, 717, 702, 3, 2, 2, 2, 717, 705, 3, 2, 2, 2, 717, 708, 3, 2,
	2, 2, 717, 711, 3, 2, 2, 2, 717, 714, 3, 2, 2, 2, 718, 11, 3, 2, 2, 2,
	719, 720, 7, 26, 2, 2, 720, 13, 3, 2, 2, 2, 721, 722, 7, 58, 2, 2, 722,
	723, 5, 16, 9, 2, 723, 15, 3, 2, 2, 2, 724, 729, 5, 656, 329, 2, 725, 726,
	7, 250, 2, 2, 726, 728, 5, 620, 311, 2, 727, 725, 3, 2, 2, 2, 728, 731,
	3, 2, 2, 2, 729, 727, 3, 2, 2, 2, 729, 730, 3, 2, 2, 2, 730, 17, 3, 2,
	2, 2, 731, 729, 3, 2, 2, 2, 732, 736, 7, 62, 2, 2, 733, 735, 5, 622, 312,
	2, 734, 733, 3, 2, 2, 2, 735, 738, 3, 2, 2, 2, 736, 734, 3, 2, 2, 2, 736,
	737, 3, 2, 2, 2, 737, 19, 3, 2, 2, 2, 738, 736, 3, 2, 2, 2, 739, 743, 7,
	23, 2, 2, 740, 741, 5, 622, 312, 2, 741, 742, 7, 250, 2, 2, 742, 744, 3,
	2, 2, 2, 743, 740, 3, 2, 2, 2, 743, 744, 3, 2, 2, 2, 744, 745, 3, 2, 2,
	2, 745, 746, 5, 580, 291, 2, 746, 21, 3, 2, 2, 2, 747, 751, 7, 121, 2,
	2, 748, 749, 5, 622, 312, 2, 749, 750, 7, 250, 2, 2, 750, 752, 3, 2, 2,
	2, 751, 748, 3, 2, 2, 2, 751, 752, 3, 2, 2, 2, 752, 753, 3, 2, 2, 2, 753,
	756, 5, 580, 291, 2, 754, 755, 7, 248, 2, 2, 755, 757, 7, 22, 2, 2, 756,
	754, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 757, 23, 3, 2, 2, 2, 758, 761, 5,
	2, 2, 2, 759, 761, 5, 26, 14, 2, 760, 758, 3, 2, 2, 2, 760, 759, 3, 2,
	2, 2, 761, 764, 3, 2, 2, 2, 762, 760, 3, 2, 2, 2, 762, 763, 3, 2, 2, 2,
	763, 765, 3, 2, 2, 2, 764, 762, 3, 2, 2, 2, 765, 766, 7, 2, 2, 3, 766,
	25, 3, 2, 2, 2, 767, 768, 5, 28, 15, 2, 768, 27, 3, 2, 2, 2, 769, 771,
	5, 570, 286, 2, 770, 769, 3, 2, 2, 2, 771, 774, 3, 2, 2, 2, 772, 770, 3,
	2, 2, 2, 772, 773, 3, 2, 2, 2, 773, 775, 3, 2, 2, 2, 774, 772, 3, 2, 2,
	2, 775, 776, 5, 30, 16, 2, 776, 778, 5, 626, 314, 2, 777, 779, 5, 32, 17,
	2, 778, 777, 3, 2, 2, 2, 778, 779, 3, 2, 2, 2, 779, 782, 3, 2, 2, 2, 780,
	783, 5, 36, 19, 2, 781, 783, 5, 34, 18, 2, 782, 780, 3, 2, 2, 2, 782, 781,
	3, 2, 2, 2, 782, 783, 3, 2, 2, 2, 783, 784, 3, 2, 2, 2, 784, 788, 7, 247,
	2, 2, 785, 787, 5, 46, 24, 2, 786, 785, 3, 2, 2, 2, 787, 790, 3, 2, 2,
	2, 788, 786, 3, 2, 2, 2, 788, 789, 3, 2, 2, 2, 789, 791, 3, 2, 2, 2, 790,
	788, 3, 2, 2, 2, 791, 792, 7, 5, 2, 2, 792, 29, 3, 2, 2, 2, 793, 794, 9,
	2, 2, 2, 794, 31, 3, 2, 2, 2, 795, 796, 7, 264, 2, 2, 796, 797, 7, 256,
	2, 2, 797, 802, 5, 58, 30, 2, 798, 799, 7, 253, 2, 2, 799, 801, 5, 58,
	30, 2, 800, 798, 3, 2, 2, 2, 801, 804, 3, 2, 2, 2, 802, 800, 3, 2, 2, 2,
	802, 803, 3, 2, 2, 2, 803, 805, 3, 2, 2, 2, 804, 802, 3, 2, 2, 2, 805,
	806, 7, 257, 2, 2, 806, 33, 3, 2, 2, 2, 807, 808, 7, 256, 2, 2, 808, 813,
	5, 38, 20, 2, 809, 810, 7, 253, 2, 2, 810, 812, 5, 38, 20, 2, 811, 809,
	3, 2, 2, 2, 812, 815, 3, 2, 2, 2, 813, 811, 3, 2, 2, 2, 813, 814, 3, 2,
	2, 2, 814, 816, 3, 2, 2, 2, 815, 813, 3, 2, 2, 2, 816, 817, 7, 257, 2,
	2, 817, 35, 3, 2, 2, 2, 818, 819, 7, 256, 2, 2, 819, 824, 5, 44, 23, 2,
	820, 821, 7, 253, 2, 2, 821, 823, 5, 44, 23, 2, 822, 820, 3, 2, 2, 2, 823,
	826, 3, 2, 2, 2, 824, 822, 3, 2, 2, 2, 824, 825, 3, 2, 2, 2, 825, 827,
	3, 2, 2, 2, 826, 824, 3, 2, 2, 2, 827, 828, 7, 257, 2, 2, 828, 832, 3,
	2, 2, 2, 829, 830, 7, 256, 2, 2, 830, 832, 7, 257, 2, 2, 831, 818, 3, 2,
	2, 2, 831, 829, 3, 2, 2, 2, 832, 37, 3, 2, 2, 2, 833, 835, 5, 40, 21, 2,
	834, 833, 3, 2, 2, 2, 834, 835, 3, 2, 2, 2, 835, 845, 3, 2, 2, 2, 836,
	837, 7, 250, 2, 2, 837, 838, 5, 636, 319, 2, 838, 840, 7, 256, 2, 2, 839,
	841, 5, 40, 21, 2, 840, 839, 3, 2, 2, 2, 840, 841, 3, 2, 2, 2, 841, 842,
	3, 2, 2, 2, 842, 843, 7, 257, 2, 2, 843, 845, 3, 2, 2, 2, 844, 834, 3,
	2, 2, 2, 844, 836, 3, 2, 2, 2, 845, 39, 3, 2, 2, 2, 846, 859, 5, 42, 22,
	2, 847, 848, 7, 260, 2, 2, 848, 853, 5, 42, 22, 2, 849, 850, 7, 253, 2,
	2, 850, 852, 5, 42, 22, 2, 851, 849, 3, 2, 2, 2, 852, 855, 3, 2, 2, 2,
	853, 851, 3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854, 856, 3, 2, 2, 2, 855,
	853, 3, 2, 2, 2, 856, 857, 7, 261, 2, 2, 857, 859, 3, 2, 2, 2, 858, 846,
	3, 2, 2, 2, 858, 847, 3, 2, 2, 2, 859, 41, 3, 2, 2, 2, 860, 872, 5, 636,
	319, 2, 861, 862, 5, 636, 319, 2, 862, 863, 7, 258, 2, 2, 863, 864, 5,
	522, 262, 2, 864, 865, 7, 259, 2, 2, 865, 872, 3, 2, 2, 2, 866, 867, 5,
	636, 319, 2, 867, 868, 7, 258, 2, 2, 868, 869, 5, 546, 274, 2, 869, 870,
	7, 259, 2, 2, 870, 872, 3, 2, 2, 2, 871, 860, 3, 2, 2, 2, 871, 861, 3,
	2, 2, 2, 871, 866, 3, 2, 2, 2, 872, 43, 3, 2, 2, 2, 873, 875, 5, 570, 286,
	2, 874, 873, 3, 2, 2, 2, 875, 878, 3, 2, 2, 2, 876, 874, 3, 2, 2, 2, 876,
	877, 3, 2, 2, 2, 877, 879, 3, 2, 2, 2, 878, 876, 3, 2, 2, 2, 879, 895,
	5, 62, 32, 2, 880, 882, 5, 570, 286, 2, 881, 880, 3, 2, 2, 2, 882, 885,
	3, 2, 2, 2, 883, 881, 3, 2, 2, 2, 883, 884, 3, 2, 2, 2, 884, 886, 3, 2,
	2, 2, 885, 883, 3, 2, 2, 2, 886, 895, 5, 64, 33, 2, 887, 889, 5, 570, 286,
	2, 888, 887, 3, 2, 2, 2, 889, 892, 3, 2, 2, 2, 890, 888, 3, 2, 2, 2, 890,
	891, 3, 2, 2, 2, 891, 893, 3, 2, 2, 2, 892, 890, 3, 2, 2, 2, 893, 895,
	5, 66, 34, 2, 894, 876, 3, 2, 2, 2, 894, 883, 3, 2, 2, 2, 894, 890, 3,
	2, 2, 2, 895, 45, 3, 2, 2, 2, 896, 936, 5, 48, 25, 2, 897, 898, 5, 44,
	23, 2, 898, 899, 7, 247, 2, 2, 899, 936, 3, 2, 2, 2, 900, 902, 5, 570,
	286, 2, 901, 900, 3, 2, 2, 2, 902, 905, 3, 2, 2, 2, 903, 901, 3, 2, 2,
	2, 903, 904, 3, 2, 2, 2, 904, 906, 3, 2, 2, 2, 905, 903, 3, 2, 2, 2, 906,
	936, 5, 246, 124, 2, 907, 909, 5, 570, 286, 2, 908, 907, 3, 2, 2, 2, 909,
	912, 3, 2, 2, 2, 910, 908, 3, 2, 2, 2, 910, 911, 3, 2, 2, 2, 911, 913,
	3, 2, 2, 2, 912, 910, 3, 2, 2, 2, 913, 936, 5, 54, 28, 2, 914, 916, 5,
	570, 286, 2, 915, 914, 3, 2, 2, 2, 916, 919, 3, 2, 2, 2, 917, 915, 3, 2,
	2, 2, 917, 918, 3, 2, 2, 2, 918, 920, 3, 2, 2, 2, 919, 917, 3, 2, 2, 2,
	920, 936, 5, 56, 29, 2, 921, 923, 5, 570, 286, 2, 922, 921, 3, 2, 2, 2,
	923, 926, 3, 2, 2, 2, 924, 922, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925,
	927, 3, 2, 2, 2, 926, 924, 3, 2, 2, 2, 927, 936, 5, 340, 171, 2, 928, 930,
	5, 570, 286, 2, 929, 928, 3, 2, 2, 2, 930, 933, 3, 2, 2, 2, 931, 929, 3,
	2, 2, 2, 931, 932, 3, 2, 2, 2, 932, 934, 3, 2, 2, 2, 933, 931, 3, 2, 2,
	2, 934, 936, 5, 60, 31, 2, 935, 896, 3, 2, 2, 2, 935, 897, 3, 2, 2, 2,
	935, 903, 3, 2, 2, 2, 935, 910, 3, 2, 2, 2, 935, 917, 3, 2, 2, 2, 935,
	924, 3, 2, 2, 2, 935, 931, 3, 2, 2, 2, 936, 47, 3, 2, 2, 2, 937, 939, 5,
	570, 286, 2, 938, 937, 3, 2, 2, 2, 939, 942, 3, 2, 2, 2, 940, 938, 3, 2,
	2, 2, 940, 941, 3, 2, 2, 2, 941, 943, 3, 2, 2, 2, 942, 940, 3, 2, 2, 2,
	943, 994, 5, 50, 26, 2, 944, 946, 5, 570, 286, 2, 945, 944, 3, 2, 2, 2,
	946, 949, 3, 2, 2, 2, 947, 945, 3, 2, 2, 2, 947, 948, 3, 2, 2, 2, 948,
	950, 3, 2, 2, 2, 949, 947, 3, 2, 2, 2, 950, 994, 5, 54, 28, 2, 951, 953,
	5, 570, 286, 2, 952, 951, 3, 2, 2, 2, 953, 956, 3, 2, 2, 2, 954, 952, 3,
	2, 2, 2, 954, 955, 3, 2, 2, 2, 955, 957, 3, 2, 2, 2, 956, 954, 3, 2, 2,
	2, 957, 994, 5, 52, 27, 2, 958, 960, 5, 570, 286, 2, 959, 958, 3, 2, 2,
	2, 960, 963, 3, 2, 2, 2, 961, 959, 3, 2, 2, 2, 961, 962, 3, 2, 2, 2, 962,
	964, 3, 2, 2, 2, 963, 961, 3, 2, 2, 2, 964, 994, 5, 264, 133, 2, 965, 967,
	5, 570, 286, 2, 966, 965, 3, 2, 2, 2, 967, 970, 3, 2, 2, 2, 968, 966, 3,
	2, 2, 2, 968, 969, 3, 2, 2, 2, 969, 971, 3, 2, 2, 2, 970, 968, 3, 2, 2,
	2, 971, 994, 5, 176, 89, 2, 972, 974, 5, 570, 286, 2, 973, 972, 3, 2, 2,
	2, 974, 977, 3, 2, 2, 2, 975, 973, 3, 2, 2, 2, 975, 976, 3, 2, 2, 2, 976,
	978, 3, 2, 2, 2, 977, 975, 3, 2, 2, 2, 978, 994, 5, 226, 114, 2, 979, 981,
	5, 570, 286, 2, 980, 979, 3, 2, 2, 2, 981, 984, 3, 2, 2, 2, 982, 980, 3,
	2, 2, 2, 982, 983, 3, 2, 2, 2, 983, 985, 3, 2, 2, 2, 984, 982, 3, 2, 2,
	2, 985, 994, 5, 270, 136, 2, 986, 988, 5, 570, 286, 2, 987, 986, 3, 2,
	2, 2, 988, 991, 3, 2, 2, 2, 989, 987, 3, 2, 2, 2, 989, 990, 3, 2, 2, 2,
	990, 992, 3, 2, 2, 2, 991, 989, 3, 2, 2, 2, 992, 994, 5, 272, 137, 2, 993,
	940, 3, 2, 2, 2, 993, 947, 3, 2, 2, 2, 993, 954, 3, 2, 2, 2, 993, 961,
	3, 2, 2, 2, 993, 968, 3, 2, 2, 2, 993, 975, 3, 2, 2, 2, 993, 982, 3, 2,
	2, 2, 993, 989, 3, 2, 2, 2, 994, 49, 3, 2, 2, 2, 995, 1006, 5, 82, 42,
	2, 996, 1006, 5, 80, 41, 2, 997, 1006, 5, 72, 37, 2, 998, 1006, 5, 76,
	39, 2, 999, 1006, 5, 74, 38, 2, 1000, 1006, 5, 78, 40, 2, 1001, 1006, 5,
	68, 35, 2, 1002, 1006, 5, 70, 36, 2, 1003, 1006, 5, 154, 78, 2, 1004, 1006,
	5, 144, 73, 2, 1005, 995, 3, 2, 2, 2, 1005, 996, 3, 2, 2, 2, 1005, 997,
	3, 2, 2, 2, 1005, 998, 3, 2, 2, 2, 1005, 999, 3, 2, 2, 2, 1005, 1000, 3,
	2, 2, 2, 1005, 1001, 3, 2, 2, 2, 1005, 1002, 3, 2, 2, 2, 1005, 1003, 3,
	2, 2, 2, 1005, 1004, 3, 2, 2, 2, 1006, 51, 3, 2, 2, 2, 1007, 1008, 7, 28,
	2, 2, 1008, 1009, 5, 116, 59, 2, 1009, 1010, 7, 247, 2, 2, 1010, 53, 3,
	2, 2, 2, 1011, 1013, 7, 65, 2, 2, 1012, 1014, 7, 100, 2, 2, 1013, 1012,
	3, 2, 2, 2, 1013, 1014, 3, 2, 2, 2, 1014, 1016, 3, 2, 2, 2, 1015, 1017,
	5, 142, 72, 2, 1016, 1015, 3, 2, 2, 2, 1016, 1017, 3, 2, 2, 2, 1017, 1018,
	3, 2, 2, 2, 1018, 1019, 5, 116, 59, 2, 1019, 1020, 7, 247, 2, 2, 1020,
	1042, 3, 2, 2, 2, 1021, 1022, 7, 65, 2, 2, 1022, 1023, 7, 59, 2, 2, 1023,
	1024, 5, 116, 59, 2, 1024, 1025, 7, 247, 2, 2, 1025, 1042, 3, 2, 2, 2,
	1026, 1027, 7, 65, 2, 2, 1027, 1028, 7, 88, 2, 2, 1028, 1029, 5, 116, 59,
	2, 1029, 1030, 7, 247, 2, 2, 1030, 1042, 3, 2, 2, 2, 1031, 1032, 7, 65,
	2, 2, 1032, 1033, 7, 89, 2, 2, 1033, 1034, 5, 116, 59, 2, 1034, 1035, 7,
	247, 2, 2, 1035, 1042, 3, 2, 2, 2, 1036, 1037, 7, 65, 2, 2, 1037, 1038,
	7, 110, 2, 2, 1038, 1039, 5, 116, 59, 2, 1039, 1040, 7, 247, 2, 2, 1040,
	1042, 3, 2, 2, 2, 1041, 1011, 3, 2, 2, 2, 1041, 1021, 3, 2, 2, 2, 1041,
	1026, 3, 2, 2, 2, 1041, 1031, 3, 2, 2, 2, 1041, 1036, 3, 2, 2, 2, 1042,
	55, 3, 2, 2, 2, 1043, 1044, 5, 58, 30, 2, 1044, 1045, 7, 247, 2, 2, 1045,
	57, 3, 2, 2, 2, 1046, 1048, 7, 77, 2, 2, 1047, 1049, 7, 100, 2, 2, 1048,
	1047, 3, 2, 2, 2, 1048, 1049, 3, 2, 2, 2, 1049, 1051, 3, 2, 2, 2, 1050,
	1052, 5, 142, 72, 2, 1051, 1050, 3, 2, 2, 2, 1051, 1052, 3, 2, 2, 2, 1052,
	1053, 3, 2, 2, 2, 1053, 1067, 5, 116, 59, 2, 1054, 1055, 7, 77, 2, 2, 1055,
	1056, 7, 59, 2, 2, 1056, 1067, 5, 116, 59, 2, 1057, 1058, 7, 77, 2, 2,
	1058, 1059, 7, 88, 2, 2, 1059, 1067, 5, 116, 59, 2, 1060, 1061, 7, 77,
	2, 2, 1061, 1062, 7, 89, 2, 2, 1062, 1067, 5, 116, 59, 2, 1063, 1064, 7,
	77, 2, 2, 1064, 1065, 7, 110, 2, 2, 1065, 1067, 5, 116, 59, 2, 1066, 1046,
	3, 2, 2, 2, 1066, 1054, 3, 2, 2, 2, 1066, 1057, 3, 2, 2, 2, 1066, 1060,
	3, 2, 2, 2, 1066, 1063, 3, 2, 2, 2, 1067, 59, 3, 2, 2, 2, 1068, 1070, 7,
	103, 2, 2, 1069, 1071, 5, 142, 72, 2, 1070, 1069, 3, 2, 2, 2, 1070, 1071,
	3, 2, 2, 2, 1071, 1072, 3, 2, 2, 2, 1072, 1073, 5, 118, 60, 2, 1073, 1074,
	7, 247, 2, 2, 1074, 61, 3, 2, 2, 2, 1075, 1077, 7, 56, 2, 2, 1076, 1078,
	5, 84, 43, 2, 1077, 1076, 3, 2, 2, 2, 1077, 1078, 3, 2, 2, 2, 1078, 1080,
	3, 2, 2, 2, 1079, 1081, 7, 100, 2, 2, 1080, 1079, 3, 2, 2, 2, 1080, 1081,
	3, 2, 2, 2, 1081, 1083, 3, 2, 2, 2, 1082, 1084, 5, 142, 72, 2, 1083, 1082,
	3, 2, 2, 2, 1083, 1084, 3, 2, 2, 2, 1084, 1085, 3, 2, 2, 2, 1085, 1086,
	5, 112, 57, 2, 1086, 63, 3, 2, 2, 2, 1087, 1089, 7, 57, 2, 2, 1088, 1090,
	5, 84, 43, 2, 1089, 1088, 3, 2, 2, 2, 1089, 1090, 3, 2, 2, 2, 1090, 1092,
	3, 2, 2, 2, 1091, 1093, 7, 100, 2, 2, 1092, 1091, 3, 2, 2, 2, 1092, 1093,
	3, 2, 2, 2, 1093, 1095, 3, 2, 2, 2, 1094, 1096, 5, 142, 72, 2, 1095, 1094,
	3, 2, 2, 2, 1095, 1096, 3, 2, 2, 2, 1096, 1097, 3, 2, 2, 2, 1097, 1098,
	5, 112, 57, 2, 1098, 65, 3, 2, 2, 2, 1099, 1101, 7, 76, 2, 2, 1100, 1102,
	5, 84, 43, 2, 1101, 1100, 3, 2, 2, 2, 1101, 1102, 3, 2, 2, 2, 1102, 1104,
	3, 2, 2, 2, 1103, 1105, 7, 100, 2, 2, 1104, 1103, 3, 2, 2, 2, 1104, 1105,
	3, 2, 2, 2, 1105, 1107, 3, 2, 2, 2, 1106, 1108, 5, 142, 72, 2, 1107, 1106,
	3, 2, 2, 2, 1107, 1108, 3, 2, 2, 2, 1108, 1109, 3, 2, 2, 2, 1109, 1140,
	5, 112, 57, 2, 1110, 1112, 7, 76, 2, 2, 1111, 1113, 7, 90, 2, 2, 1112,
	1111, 3, 2, 2, 2, 1112, 1113, 3, 2, 2, 2, 1113, 1115, 3, 2, 2, 2, 1114,
	1116, 7, 100, 2, 2, 1115, 1114, 3, 2, 2, 2, 1115, 1116, 3, 2, 2, 2, 1116,
	1118, 3, 2, 2, 2, 1117, 1119, 5, 142, 72, 2, 1118, 1117, 3, 2, 2, 2, 1118,
	1119, 3, 2, 2, 2, 1119, 1120, 3, 2, 2, 2, 1120, 1140, 5, 112, 57, 2, 1121,
	1122, 7, 76, 2, 2, 1122, 1124, 7, 90, 2, 2, 1123, 1125, 7, 100, 2, 2, 1124,
	1123, 3, 2, 2, 2, 1124, 1125, 3, 2, 2, 2, 1125, 1127, 3, 2, 2, 2, 1126,
	1128, 5, 142, 72, 2, 1127, 1126, 3, 2, 2, 2, 1127, 1128, 3, 2, 2, 2, 1128,
	1129, 3, 2, 2, 2, 1129, 1140, 5, 124, 63, 2, 1130, 1132, 7, 76, 2, 2, 1131,
	1133, 5, 86, 44, 2, 1132, 1131, 3, 2, 2, 2, 1132, 1133, 3, 2, 2, 2, 1133,
	1134, 3, 2, 2, 2, 1134, 1140, 5, 112, 57, 2, 1135, 1136, 7, 76, 2, 2, 1136,
	1137, 5, 86, 44, 2, 1137, 1138, 5, 124, 63, 2, 1138, 1140, 3, 2, 2, 2,
	1139, 1099, 3, 2, 2, 2, 1139, 1110, 3, 2, 2, 2, 1139, 1121, 3, 2, 2, 2,
	1139, 1130, 3, 2, 2, 2, 1139, 1135, 3, 2, 2, 2, 1140, 67, 3, 2, 2, 2, 1141,
	1142, 7, 42, 2, 2, 1142, 1143, 5, 106, 54, 2, 1143, 1144, 7, 247, 2, 2,
	1144, 69, 3, 2, 2, 2, 1145, 1146, 7, 51, 2, 2, 1146, 1147, 5, 110, 56,
	2, 1147, 1148, 7, 247, 2, 2, 1148, 71, 3, 2, 2, 2, 1149, 1150, 7, 59, 2,
	2, 1150, 1151, 5, 122, 62, 2, 1151, 1152, 7, 247, 2, 2, 1152, 73, 3, 2,
	2, 2, 1153, 1154, 7, 110, 2, 2, 1154, 1155, 5, 122, 62, 2, 1155, 1156,
	7, 247, 2, 2, 1156, 75, 3, 2, 2, 2, 1157, 1158, 7, 88, 2, 2, 1158, 1159,
	5, 120, 61, 2, 1159, 1160, 7, 247, 2, 2, 1160, 77, 3, 2, 2, 2, 1161, 1162,
	7, 89, 2, 2, 1162, 1163, 5, 120, 61, 2, 1163, 1164, 7, 247, 2, 2, 1164,
	79, 3, 2, 2, 2, 1165, 1167, 7, 90, 2, 2, 1166, 1168, 7, 100, 2, 2, 1167,
	1166, 3, 2, 2, 2, 1167, 1168, 3, 2, 2, 2, 1168, 1170, 3, 2, 2, 2, 1169,
	1171, 5, 142, 72, 2, 1170, 1169, 3, 2, 2, 2, 1170, 1171, 3, 2, 2, 2, 1171,
	1172, 3, 2, 2, 2, 1172, 1173, 5, 122, 62, 2, 1173, 1174, 7, 247, 2, 2,
	1174, 81, 3, 2, 2, 2, 1175, 1177, 5, 84, 43, 2, 1176, 1178, 7, 100, 2,
	2, 1177, 1176, 3, 2, 2, 2, 1177, 1178, 3, 2, 2, 2, 1178, 1180, 3, 2, 2,
	2, 1179, 1181, 5, 100, 51, 2, 1180, 1179, 3, 2, 2, 2, 1180, 1181, 3, 2,
	2, 2, 1181, 1182, 3, 2, 2, 2, 1182, 1183, 5, 108, 55, 2, 1183, 1184, 7,
	247, 2, 2, 1184, 1290, 3, 2, 2, 2, 1185, 1187, 5, 84, 43, 2, 1186, 1188,
	5, 92, 47, 2, 1187, 1186, 3, 2, 2, 2, 1187, 1188, 3, 2, 2, 2, 1188, 1190,
	3, 2, 2, 2, 1189, 1191, 7, 100, 2, 2, 1190, 1189, 3, 2, 2, 2, 1190, 1191,
	3, 2, 2, 2, 1191, 1193, 3, 2, 2, 2, 1192, 1194, 5, 100, 51, 2, 1193, 1192,
	3, 2, 2, 2, 1193, 1194, 3, 2, 2, 2, 1194, 1195, 3, 2, 2, 2, 1195, 1196,
	5, 114, 58, 2, 1196, 1197, 7, 247, 2, 2, 1197, 1290, 3, 2, 2, 2, 1198,
	1200, 7, 120, 2, 2, 1199, 1201, 5, 92, 47, 2, 1200, 1199, 3, 2, 2, 2, 1200,
	1201, 3, 2, 2, 2, 1201, 1203, 3, 2, 2, 2, 1202, 1204, 7, 100, 2, 2, 1203,
	1202, 3, 2, 2, 2, 1203, 1204, 3, 2, 2, 2, 1204, 1206, 3, 2, 2, 2, 1205,
	1207, 5, 100, 51, 2, 1206, 1205, 3, 2, 2, 2, 1206, 1207, 3, 2, 2, 2, 1207,
	1208, 3, 2, 2, 2, 1208, 1209, 5, 114, 58, 2, 1209, 1210, 7, 247, 2, 2,
	1210, 1290, 3, 2, 2, 2, 1211, 1213, 7, 120, 2, 2, 1212, 1214, 5, 98, 50,
	2, 1213, 1212, 3, 2, 2, 2, 1213, 1214, 3, 2, 2, 2, 1214, 1216, 3, 2, 2,
	2, 1215, 1217, 7, 100, 2, 2, 1216, 1215, 3, 2, 2, 2, 1216, 1217, 3, 2,
	2, 2, 1217, 1219, 3, 2, 2, 2, 1218, 1220, 5, 100, 51, 2, 1219, 1218, 3,
	2, 2, 2, 1219, 1220, 3, 2, 2, 2, 1220, 1221, 3, 2, 2, 2, 1221, 1222, 5,
	108, 55, 2, 1222, 1223, 7, 247, 2, 2, 1223, 1290, 3, 2, 2, 2, 1224, 1226,
	7, 120, 2, 2, 1225, 1227, 5, 98, 50, 2, 1226, 1225, 3, 2, 2, 2, 1226, 1227,
	3, 2, 2, 2, 1227, 1229, 3, 2, 2, 2, 1228, 1230, 9, 3, 2, 2, 1229, 1228,
	3, 2, 2, 2, 1229, 1230, 3, 2, 2, 2, 1230, 1232, 3, 2, 2, 2, 1231, 1233,
	7, 100, 2, 2, 1232, 1231, 3, 2, 2, 2, 1232, 1233, 3, 2, 2, 2, 1233, 1234,
	3, 2, 2, 2, 1234, 1236, 5, 142, 72, 2, 1235, 1237, 5, 100, 51, 2, 1236,
	1235, 3, 2, 2, 2, 1236, 1237, 3, 2, 2, 2, 1237, 1238, 3, 2, 2, 2, 1238,
	1239, 5, 108, 55, 2, 1239, 1240, 7, 247, 2, 2, 1240, 1290, 3, 2, 2, 2,
	1241, 1243, 7, 120, 2, 2, 1242, 1244, 5, 92, 47, 2, 1243, 1242, 3, 2, 2,
	2, 1243, 1244, 3, 2, 2, 2, 1244, 1246, 3, 2, 2, 2, 1245, 1247, 9, 3, 2,
	2, 1246, 1245, 3, 2, 2, 2, 1246, 1247, 3, 2, 2, 2, 1247, 1249, 3, 2, 2,
	2, 1248, 1250, 7, 100, 2, 2, 1249, 1248, 3, 2, 2, 2, 1249, 1250, 3, 2,
	2, 2, 1250, 1251, 3, 2, 2, 2, 1251, 1253, 5, 142, 72, 2, 1252, 1254, 5,
	100, 51, 2, 1253, 1252, 3, 2, 2, 2, 1253, 1254, 3, 2, 2, 2, 1254, 1255,
	3, 2, 2, 2, 1255, 1256, 5, 114, 58, 2, 1256, 1257, 7, 247, 2, 2, 1257,
	1290, 3, 2, 2, 2, 1258, 1260, 5, 84, 43, 2, 1259, 1261, 5, 92, 47, 2, 1260,
	1259, 3, 2, 2, 2, 1260, 1261, 3, 2, 2, 2, 1261, 1263, 3, 2, 2, 2, 1262,
	1264, 9, 3, 2, 2, 1263, 1262, 3, 2, 2, 2, 1263, 1264, 3, 2, 2, 2, 1264,
	1266, 3, 2, 2, 2, 1265, 1267, 7, 100, 2, 2, 1266, 1265, 3, 2, 2, 2, 1266,
	1267, 3, 2, 2, 2, 1267, 1268, 3, 2, 2, 2, 1268, 1270, 5, 142, 72, 2, 1269,
	1271, 5, 100, 51, 2, 1270, 1269, 3, 2, 2, 2, 1270, 1271, 3, 2, 2, 2, 1271,
	1272, 3, 2, 2, 2, 1272, 1273, 5, 114, 58, 2, 1273, 1274, 7, 247, 2, 2,
	1274, 1290, 3, 2, 2, 2, 1275, 1277, 5, 84, 43, 2, 1276, 1278, 9, 3, 2,
	2, 1277, 1276, 3, 2, 2, 2, 1277, 1278, 3, 2, 2, 2, 1278, 1280, 3, 2, 2,
	2, 1279, 1281, 7, 100, 2, 2, 1280, 1279, 3, 2, 2, 2, 1280, 1281, 3, 2,
	2, 2, 1281, 1282, 3, 2, 2, 2, 1282, 1284, 5, 142, 72, 2, 1283, 1285, 5,
	100, 51, 2, 1284, 1283, 3, 2, 2, 2, 1284, 1285, 3, 2, 2, 2, 1285, 1286,
	3, 2, 2, 2, 1286, 1287, 5, 108, 55, 2, 1287, 1288, 7, 247, 2, 2, 1288,
	1290, 3, 2, 2, 2, 1289, 1175, 3, 2, 2, 2, 1289, 1185, 3, 2, 2, 2, 1289,
	1198, 3, 2, 2, 2, 1289, 1211, 3, 2, 2, 2, 1289, 1224, 3, 2, 2, 2, 1289,
	1241, 3, 2, 2, 2, 1289, 1258, 3, 2, 2, 2, 1289, 1275, 3, 2, 2, 2, 1290,
	83, 3, 2, 2, 2, 1291, 1292, 9, 4, 2, 2, 1292, 85, 3, 2, 2, 2, 1293, 1294,
	9, 5, 2, 2, 1294, 87, 3, 2, 2, 2, 1295, 1298, 5, 638, 320, 2, 1296, 1297,
	7, 267, 2, 2, 1297, 1299, 5, 522, 262, 2, 1298, 1296, 3, 2, 2, 2, 1298,
	1299, 3, 2, 2, 2, 1299, 1309, 3, 2, 2, 2, 1300, 1301, 5, 638, 320, 2, 1301,
	1305, 5, 140, 71, 2, 1302, 1304, 5, 140, 71, 2, 1303, 1302, 3, 2, 2, 2,
	1304, 1307, 3, 2, 2, 2, 1305, 1303, 3, 2, 2, 2, 1305, 1306, 3, 2, 2, 2,
	1306, 1309, 3, 2, 2, 2, 1307, 1305, 3, 2, 2, 2, 1308, 1295, 3, 2, 2, 2,
	1308, 1300, 3, 2, 2, 2, 1309, 89, 3, 2, 2, 2, 1310, 1313, 5, 662, 332,
	2, 1311, 1312, 7, 267, 2, 2, 1312, 1314, 5, 522, 262, 2, 1313, 1311, 3,
	2, 2, 2, 1313, 1314, 3, 2, 2, 2, 1314, 1324, 3, 2, 2, 2, 1315, 1316, 5,
	662, 332, 2, 1316, 1320, 5, 140, 71, 2, 1317, 1319, 5, 140, 71, 2, 1318,
	1317, 3, 2, 2, 2, 1319, 1322, 3, 2, 2, 2, 1320, 1318, 3, 2, 2, 2, 1320,
	1321, 3, 2, 2, 2, 1321, 1324, 3, 2, 2, 2, 1322, 1320, 3, 2, 2, 2, 1323,
	1310, 3, 2, 2, 2, 1323, 1315, 3, 2, 2, 2, 1324, 91, 3, 2, 2, 2, 1325, 1326,
	5, 94, 48, 2, 1326, 1327, 7, 253, 2, 2, 1327, 1328, 5, 96, 49, 2, 1328,
	1348, 3, 2, 2, 2, 1329, 1330, 5, 96, 49, 2, 1330, 1331, 7, 253, 2, 2, 1331,
	1332, 5, 94, 48, 2, 1332, 1348, 3, 2, 2, 2, 1333, 1334, 5, 94, 48, 2, 1334,
	1335, 7, 253, 2, 2, 1335, 1336, 7, 48, 2, 2, 1336, 1348, 3, 2, 2, 2, 1337,
	1338, 5, 96, 49, 2, 1338, 1339, 7, 253, 2, 2, 1339, 1340, 7, 47, 2, 2,
	1340, 1348, 3, 2, 2, 2, 1341, 1342, 7, 47, 2, 2, 1342, 1343, 7, 253, 2,
	2, 1343, 1348, 5, 96, 49, 2, 1344, 1345, 7, 48, 2, 2, 1345, 1346, 7, 253,
	2, 2, 1346, 1348, 5, 94, 48, 2, 1347, 1325, 3, 2, 2, 2, 1347, 1329, 3,
	2, 2, 2, 1347, 1333, 3, 2, 2, 2, 1347, 1337, 3, 2, 2, 2, 1347, 1341, 3,
	2, 2, 2, 1347, 1344, 3, 2, 2, 2, 1348, 93, 3, 2, 2, 2, 1349, 1350, 9, 6,
	2, 2, 1350, 95, 3, 2, 2, 2, 1351, 1352, 9, 7, 2, 2, 1352, 97, 3, 2, 2,
	2, 1353, 1354, 7, 256, 2, 2, 1354, 1355, 7, 101, 2, 2, 1355, 1363, 7, 257,
	2, 2, 1356, 1357, 7, 256, 2, 2, 1357, 1358, 7, 66, 2, 2, 1358, 1363, 7,
	257, 2, 2, 1359, 1360, 7, 256, 2, 2, 1360, 1361, 7, 61, 2, 2, 1361, 1363,
	7, 257, 2, 2, 1362, 1353, 3, 2, 2, 2, 1362, 1356, 3, 2, 2, 2, 1362, 1359,
	3, 2, 2, 2, 1363, 99, 3, 2, 2, 2, 1364, 1365, 7, 264, 2, 2, 1365, 1380,
	5, 104, 53, 2, 1366, 1367, 7, 264, 2, 2, 1367, 1368, 7, 256, 2, 2, 1368,
	1375, 5, 104, 53, 2, 1369, 1370, 7, 253, 2, 2, 1370, 1373, 5, 104, 53,
	2, 1371, 1372, 7, 253, 2, 2, 1372, 1374, 5, 104, 53, 2, 1373, 1371, 3,
	2, 2, 2, 1373, 1374, 3, 2, 2, 2, 1374, 1376, 3, 2, 2, 2, 1375, 1369, 3,
	2, 2, 2, 1375, 1376, 3, 2, 2, 2, 1376, 1377, 3, 2, 2, 2, 1377, 1378, 7,
	257, 2, 2, 1378, 1380, 3, 2, 2, 2, 1379, 1364, 3, 2, 2, 2, 1379, 1366,
	3, 2, 2, 2, 1380, 101, 3, 2, 2, 2, 1381, 1382, 7, 264, 2, 2, 1382, 1393,
	5, 104, 53, 2, 1383, 1384, 7, 264, 2, 2, 1384, 1385, 7, 256, 2, 2, 1385,
	1388, 5, 104, 53, 2, 1386, 1387, 7, 253, 2, 2, 1387, 1389, 5, 104, 53,
	2, 1388, 1386, 3, 2, 2, 2, 1388, 1389, 3, 2, 2, 2, 1389, 1390, 3, 2, 2,
	2, 1390, 1391, 7, 257, 2, 2, 1391, 1393, 3, 2, 2, 2, 1392, 1381, 3, 2,
	2, 2, 1392, 1383, 3, 2, 2, 2, 1393, 103, 3, 2, 2, 2, 1394, 1399, 7, 291,
	2, 2, 1395, 1399, 5, 634, 318, 2, 1396, 1399, 5, 644, 323, 2, 1397, 1399,
	5, 536, 269, 2, 1398, 1394, 3, 2, 2, 2, 1398, 1395, 3, 2, 2, 2, 1398, 1396,
	3, 2, 2, 2, 1398, 1397, 3, 2, 2, 2, 1399, 105, 3, 2, 2, 2, 1400, 1408,
	5, 588, 295, 2, 1401, 1405, 5, 140, 71, 2, 1402, 1404, 5, 140, 71, 2, 1403,
	1402, 3, 2, 2, 2, 1404, 1407, 3, 2, 2, 2, 1405, 1403, 3, 2, 2, 2, 1405,
	1406, 3, 2, 2, 2, 1406, 1409, 3, 2, 2, 2, 1407, 1405, 3, 2, 2, 2, 1408,
	1401, 3, 2, 2, 2, 1408, 1409, 3, 2, 2, 2, 1409, 1423, 3, 2, 2, 2, 1410,
	1411, 7, 253, 2, 2, 1411, 1419, 5, 588, 295, 2, 1412, 1416, 5, 140, 71,
	2, 1413, 1415, 5, 140, 71, 2, 1414, 1413, 3, 2, 2, 2, 1415, 1418, 3, 2,
	2, 2, 1416, 1414, 3, 2, 2, 2, 1416, 1417, 3, 2, 2, 2, 1417, 1420, 3, 2,
	2, 2, 1418, 1416, 3, 2, 2, 2, 1419, 1412, 3, 2, 2, 2, 1419, 1420, 3, 2,
	2, 2, 1420, 1422, 3, 2, 2, 2, 1421, 1410, 3, 2, 2, 2, 1422, 1425, 3, 2,
	2, 2, 1423, 1421, 3, 2, 2, 2, 1423, 1424, 3, 2, 2, 2, 1424, 107, 3, 2,
	2, 2, 1425, 1423, 3, 2, 2, 2, 1426, 1434, 5, 630, 316, 2, 1427, 1431, 5,
	140, 71, 2, 1428, 1430, 5, 140, 71, 2, 1429, 1428, 3, 2, 2, 2, 1430, 1433,
	3, 2, 2, 2, 1431, 1429, 3, 2, 2, 2, 1431, 1432, 3, 2, 2, 2, 1432, 1435,
	3, 2, 2, 2, 1433, 1431, 3, 2, 2, 2, 1434, 1427, 3, 2, 2, 2, 1434, 1435,
	3, 2, 2, 2, 1435, 1449, 3, 2, 2, 2, 1436, 1437, 7, 253, 2, 2, 1437, 1445,
	5, 630, 316, 2, 1438, 1442, 5, 140, 71, 2, 1439, 1441, 5, 140, 71, 2, 1440,
	1439, 3, 2, 2, 2, 1441, 1444, 3, 2, 2, 2, 1442, 1440, 3, 2, 2, 2, 1442,
	1443, 3, 2, 2, 2, 1443, 1446, 3, 2, 2, 2, 1444, 1442, 3, 2, 2, 2, 1445,
	1438, 3, 2, 2, 2, 1445, 1446, 3, 2, 2, 2, 1446, 1448, 3, 2, 2, 2, 1447,
	1436, 3, 2, 2, 2, 1448, 1451, 3, 2, 2, 2, 1449, 1447, 3, 2, 2, 2, 1449,
	1450, 3, 2, 2, 2, 1450, 109, 3, 2, 2, 2, 1451, 1449, 3, 2, 2, 2, 1452,
	1457, 5, 598, 300, 2, 1453, 1454, 7, 253, 2, 2, 1454, 1456, 5, 598, 300,
	2, 1455, 1453, 3, 2, 2, 2, 1456, 1459, 3, 2, 2, 2, 1457, 1455, 3, 2, 2,
	2, 1457, 1458, 3, 2, 2, 2, 1458, 111, 3, 2, 2, 2, 1459, 1457, 3, 2, 2,
	2, 1460, 1465, 5, 636, 319, 2, 1461, 1462, 7, 253, 2, 2, 1462, 1464, 5,
	636, 319, 2, 1463, 1461, 3, 2, 2, 2, 1464, 1467, 3, 2, 2, 2, 1465, 1463,
	3, 2, 2, 2, 1465, 1466, 3, 2, 2, 2, 1466, 113, 3, 2, 2, 2, 1467, 1465,
	3, 2, 2, 2, 1468, 1473, 5, 126, 64, 2, 1469, 1470, 7, 253, 2, 2, 1470,
	1472, 5, 126, 64, 2, 1471, 1469, 3, 2, 2, 2, 1472, 1475, 3, 2, 2, 2, 1473,
	1471, 3, 2, 2, 2, 1473, 1474, 3, 2, 2, 2, 1474, 115, 3, 2, 2, 2, 1475,
	1473, 3, 2, 2, 2, 1476, 1481, 5, 128, 65, 2, 1477, 1478, 7, 253, 2, 2,
	1478, 1480, 5, 128, 65, 2, 1479, 1477, 3, 2, 2, 2, 1480, 1483, 3, 2, 2,
	2, 1481, 1479, 3, 2, 2, 2, 1481, 1482, 3, 2, 2, 2, 1482, 117, 3, 2, 2,
	2, 1483, 1481, 3, 2, 2, 2, 1484, 1489, 5, 130, 66, 2, 1485, 1486, 7, 253,
	2, 2, 1486, 1488, 5, 130, 66, 2, 1487, 1485, 3, 2, 2, 2, 1488, 1491, 3,
	2, 2, 2, 1489, 1487, 3, 2, 2, 2, 1489, 1490, 3, 2, 2, 2, 1490, 119, 3,
	2, 2, 2, 1491, 1489, 3, 2, 2, 2, 1492, 1497, 5, 88, 45, 2, 1493, 1494,
	7, 253, 2, 2, 1494, 1496, 5, 88, 45, 2, 1495, 1493, 3, 2, 2, 2, 1496, 1499,
	3, 2, 2, 2, 1497, 1495, 3, 2, 2, 2, 1497, 1498, 3, 2, 2, 2, 1498, 121,
	3, 2, 2, 2, 1499, 1497, 3, 2, 2, 2, 1500, 1505, 5, 90, 46, 2, 1501, 1502,
	7, 253, 2, 2, 1502, 1504, 5, 90, 46, 2, 1503, 1501, 3, 2, 2, 2, 1504, 1507,
	3, 2, 2, 2, 1505, 1503, 3, 2, 2, 2, 1505, 1506, 3, 2, 2, 2, 1506, 123,
	3, 2, 2, 2, 1507, 1505, 3, 2, 2, 2, 1508, 1511, 5, 636, 319, 2, 1509, 1510,
	7, 267, 2, 2, 1510, 1512, 5, 522, 262, 2, 1511, 1509, 3, 2, 2, 2, 1511,
	1512, 3, 2, 2, 2, 1512, 1521, 3, 2, 2, 2, 1513, 1514, 7, 253, 2, 2, 1514,
	1517, 5, 636, 319, 2, 1515, 1516, 7, 267, 2, 2, 1516, 1518, 5, 522, 262,
	2, 1517, 1515, 3, 2, 2, 2, 1517, 1518, 3, 2, 2, 2, 1518, 1520, 3, 2, 2,
	2, 1519, 1513, 3, 2, 2, 2, 1520, 1523, 3, 2, 2, 2, 1521, 1519, 3, 2, 2,
	2, 1521, 1522, 3, 2, 2, 2, 1522, 125, 3, 2, 2, 2, 1523, 1521, 3, 2, 2,
	2, 1524, 1525, 5, 630, 316, 2, 1525, 1526, 7, 267, 2, 2, 1526, 1527, 5,
	530, 266, 2, 1527, 127, 3, 2, 2, 2, 1528, 1529, 5, 634, 318, 2, 1529, 1530,
	7, 267, 2, 2, 1530, 1531, 5, 522, 262, 2, 1531, 129, 3, 2, 2, 2, 1532,
	1533, 5, 644, 323, 2, 1533, 1534, 7, 267, 2, 2, 1534, 1535, 5, 524, 263,
	2, 1535, 1538, 3, 2, 2, 2, 1536, 1538, 5, 132, 67, 2, 1537, 1532, 3, 2,
	2, 2, 1537, 1536, 3, 2, 2, 2, 1538, 131, 3, 2, 2, 2, 1539, 1540, 7, 8,
	2, 2, 1540, 1541, 7, 249, 2, 2, 1541, 1542, 7, 267, 2, 2, 1542, 1543, 7,
	256, 2, 2, 1543, 1546, 5, 136, 69, 2, 1544, 1545, 7, 253, 2, 2, 1545, 1547,
	5, 134, 68, 2, 1546, 1544, 3, 2, 2, 2, 1546, 1547, 3, 2, 2, 2, 1547, 1548,
	3, 2, 2, 2, 1548, 1549, 7, 257, 2, 2, 1549, 1550, 7, 247, 2, 2, 1550, 1567,
	3, 2, 2, 2, 1551, 1552, 7, 8, 2, 2, 1552, 1553, 7, 249, 2, 2, 1553, 1554,
	5, 360, 181, 2, 1554, 1555, 7, 249, 2, 2, 1555, 1556, 5, 362, 182, 2, 1556,
	1557, 7, 267, 2, 2, 1557, 1558, 7, 256, 2, 2, 1558, 1561, 5, 136, 69, 2,
	1559, 1560, 7, 253, 2, 2, 1560, 1562, 5, 134, 68, 2, 1561, 1559, 3, 2,
	2, 2, 1561, 1562, 3, 2, 2, 2, 1562, 1563, 3, 2, 2, 2, 1563, 1564, 7, 257,
	2, 2, 1564, 1565, 7, 247, 2, 2, 1565, 1567, 3, 2, 2, 2, 1566, 1539, 3,
	2, 2, 2, 1566, 1551, 3, 2, 2, 2, 1567, 133, 3, 2, 2, 2, 1568, 1569, 5,
	138, 70, 2, 1569, 135, 3, 2, 2, 2, 1570, 1571, 5, 138, 70, 2, 1571, 137,
	3, 2, 2, 2, 1572, 1573, 5, 524, 263, 2, 1573, 139, 3, 2, 2, 2, 1574, 1575,
	7, 258, 2, 2, 1575, 1576, 5, 528, 265, 2, 1576, 1577, 7, 248, 2, 2, 1577,
	1578, 5, 528, 265, 2, 1578, 1579, 7, 259, 2, 2, 1579, 141, 3, 2, 2, 2,
	1580, 1581, 7, 258, 2, 2, 1581, 1582, 5, 544, 273, 2, 1582, 1583, 7, 248,
	2, 2, 1583, 1584, 5, 534, 268, 2, 1584, 1585, 7, 259, 2, 2, 1585, 143,
	3, 2, 2, 2, 1586, 1588, 7, 49, 2, 2, 1587, 1589, 7, 12, 2, 2, 1588, 1587,
	3, 2, 2, 2, 1588, 1589, 3, 2, 2, 2, 1589, 1591, 3, 2, 2, 2, 1590, 1592,
	7, 100, 2, 2, 1591, 1590, 3, 2, 2, 2, 1591, 1592, 3, 2, 2, 2, 1592, 1594,
	3, 2, 2, 2, 1593, 1595, 5, 152, 77, 2, 1594, 1593, 3, 2, 2, 2, 1594, 1595,
	3, 2, 2, 2, 1595, 1596, 3, 2, 2, 2, 1596, 1597, 5, 590, 296, 2, 1597, 1601,
	7, 247, 2, 2, 1598, 1600, 5, 146, 74, 2, 1599, 1598, 3, 2, 2, 2, 1600,
	1603, 3, 2, 2, 2, 1601, 1599, 3, 2, 2, 2, 1601, 1602, 3, 2, 2, 2, 1602,
	1605, 3, 2, 2, 2, 1603, 1601, 3, 2, 2, 2, 1604, 1606, 5, 296, 149, 2, 1605,
	1604, 3, 2, 2, 2, 1605, 1606, 3, 2, 2, 2, 1606, 1607, 3, 2, 2, 2, 1607,
	1608, 7, 36, 2, 2, 1608, 1636, 3, 2, 2, 2, 1609, 1611, 7, 49, 2, 2, 1610,
	1612, 7, 12, 2, 2, 1611, 1610, 3, 2, 2, 2, 1611, 1612, 3, 2, 2, 2, 1612,
	1614, 3, 2, 2, 2, 1613, 1615, 7, 100, 2, 2, 1614, 1613, 3, 2, 2, 2, 1614,
	1615, 3, 2, 2, 2, 1615, 1617, 3, 2, 2, 2, 1616, 1618, 5, 152, 77, 2, 1617,
	1616, 3, 2, 2, 2, 1617, 1618, 3, 2, 2, 2, 1618, 1619, 3, 2, 2, 2, 1619,
	1620, 5, 590, 296, 2, 1620, 1621, 7, 256, 2, 2, 1621, 1622, 5, 148, 75,
	2, 1622, 1623, 7, 257, 2, 2, 1623, 1627, 7, 247, 2, 2, 1624, 1626, 5, 168,
	85, 2, 1625, 1624, 3, 2, 2, 2, 1626, 1629, 3, 2, 2, 2, 1627, 1625, 3, 2,
	2, 2, 1627, 1628, 3, 2, 2, 2, 1628, 1631, 3, 2, 2, 2, 1629, 1627, 3, 2,
	2, 2, 1630, 1632, 5, 296, 149, 2, 1631, 1630, 3, 2, 2, 2, 1631, 1632, 3,
	2, 2, 2, 1632, 1633, 3, 2, 2, 2, 1633, 1634, 7, 36, 2, 2, 1634, 1636, 3,
	2, 2, 2, 1635, 1586, 3, 2, 2, 2, 1635, 1609, 3, 2, 2, 2, 1636, 145, 3,
	2, 2, 2, 1637, 1642, 5, 168, 85, 2, 1638, 1639, 5, 164, 83, 2, 1639, 1640,
	7, 247, 2, 2, 1640, 1642, 3, 2, 2, 2, 1641, 1637, 3, 2, 2, 2, 1641, 1638,
	3, 2, 2, 2, 1642, 147, 3, 2, 2, 2, 1643, 1648, 5, 150, 76, 2, 1644, 1645,
	7, 253, 2, 2, 1645, 1647, 5, 150, 76, 2, 1646, 1644, 3, 2, 2, 2, 1647,
	1650, 3, 2, 2, 2, 1648, 1646, 3, 2, 2, 2, 1648, 1649, 3, 2, 2, 2, 1649,
	149, 3, 2, 2, 2, 1650, 1648, 3, 2, 2, 2, 1651, 1653, 5, 570, 286, 2, 1652,
	1651, 3, 2, 2, 2, 1653, 1656, 3, 2, 2, 2, 1654, 1652, 3, 2, 2, 2, 1654,
	1655, 3, 2, 2, 2, 1655, 1657, 3, 2, 2, 2, 1656, 1654, 3, 2, 2, 2, 1657,
	1658, 5, 164, 83, 2, 1658, 151, 3, 2, 2, 2, 1659, 1665, 5, 142, 72, 2,
	1660, 1665, 7, 59, 2, 2, 1661, 1665, 7, 88, 2, 2, 1662, 1665, 7, 89, 2,
	2, 1663, 1665, 7, 110, 2, 2, 1664, 1659, 3, 2, 2, 2, 1664, 1660, 3, 2,
	2, 2, 1664, 1661, 3, 2, 2, 2, 1664, 1662, 3, 2, 2, 2, 1664, 1663, 3, 2,
	2, 2, 1665, 153, 3, 2, 2, 2, 1666, 1668, 7, 109, 2, 2, 1667, 1669, 7, 12,
	2, 2, 1668, 1667, 3, 2, 2, 2, 1668, 1669, 3, 2, 2, 2, 1669, 1670, 3, 2,
	2, 2, 1670, 1671, 5, 650, 326, 2, 1671, 1675, 7, 247, 2, 2, 1672, 1674,
	5, 156, 79, 2, 1673, 1672, 3, 2, 2, 2, 1674, 1677, 3, 2, 2, 2, 1675, 1673,
	3, 2, 2, 2, 1675, 1676, 3, 2, 2, 2, 1676, 1678, 3, 2, 2, 2, 1677, 1675,
	3, 2, 2, 2, 1678, 1679, 5, 292, 147, 2, 1679, 1680, 7, 41, 2, 2, 1680,
	1702, 3, 2, 2, 2, 1681, 1683, 7, 109, 2, 2, 1682, 1684, 7, 12, 2, 2, 1683,
	1682, 3, 2, 2, 2, 1683, 1684, 3, 2, 2, 2, 1684, 1685, 3, 2, 2, 2, 1685,
	1686, 5, 650, 326, 2, 1686, 1688, 7, 256, 2, 2, 1687, 1689, 5, 158, 80,
	2, 1688, 1687, 3, 2, 2, 2, 1688, 1689, 3, 2, 2, 2, 1689, 1690, 3, 2, 2,
	2, 1690, 1691, 7, 257, 2, 2, 1691, 1695, 7, 247, 2, 2, 1692, 1694, 5, 168,
	85, 2, 1693, 1692, 3, 2, 2, 2, 1694, 1697, 3, 2, 2, 2, 1695, 1693, 3, 2,
	2, 2, 1695, 1696, 3, 2, 2, 2, 1696, 1698, 3, 2, 2, 2, 1697, 1695, 3, 2,
	2, 2, 1698, 1699, 5, 292, 147, 2, 1699, 1700, 7, 41, 2, 2, 1700, 1702,
	3, 2, 2, 2, 1701, 1666, 3, 2, 2, 2, 1701, 1681, 3, 2, 2, 2, 1702, 155,
	3, 2, 2, 2, 1703, 1714, 5, 168, 85, 2, 1704, 1706, 5, 570, 286, 2, 1705,
	1704, 3, 2, 2, 2, 1706, 1709, 3, 2, 2, 2, 1707, 1705, 3, 2, 2, 2, 1707,
	1708, 3, 2, 2, 2, 1708, 1710, 3, 2, 2, 2, 1709, 1707, 3, 2, 2, 2, 1710,
	1711, 5, 164, 83, 2, 1711, 1712, 7, 247, 2, 2, 1712, 1714, 3, 2, 2, 2,
	1713, 1703, 3, 2, 2, 2, 1713, 1707, 3, 2, 2, 2, 1714, 157, 3, 2, 2, 2,
	1715, 1720, 5, 160, 81, 2, 1716, 1717, 7, 253, 2, 2, 1717, 1719, 5, 160,
	81, 2, 1718, 1716, 3, 2, 2, 2, 1719, 1722, 3, 2, 2, 2, 1720, 1718, 3, 2,
	2, 2, 1720, 1721, 3, 2, 2, 2, 1721, 159, 3, 2, 2, 2, 1722, 1720, 3, 2,
	2, 2, 1723, 1725, 5, 570, 286, 2, 1724, 1723, 3, 2, 2, 2, 1725, 1728, 3,
	2, 2, 2, 1726, 1724, 3, 2, 2, 2, 1726, 1727, 3, 2, 2, 2, 1727, 1729, 3,
	2, 2, 2, 1728, 1726, 3, 2, 2, 2, 1729, 1730, 5, 164, 83, 2, 1730, 161,
	3, 2, 2, 2, 1731, 1733, 9, 8, 2, 2, 1732, 1734, 5, 84, 43, 2, 1733, 1732,
	3, 2, 2, 2, 1733, 1734, 3, 2, 2, 2, 1734, 1736, 3, 2, 2, 2, 1735, 1737,
	7, 90, 2, 2, 1736, 1735, 3, 2, 2, 2, 1736, 1737, 3, 2, 2, 2, 1737, 1739,
	3, 2, 2, 2, 1738, 1740, 7, 100, 2, 2, 1739, 1738, 3, 2, 2, 2, 1739, 1740,
	3, 2, 2, 2, 1740, 1742, 3, 2, 2, 2, 1741, 1743, 5, 142, 72, 2, 1742, 1741,
	3, 2, 2, 2, 1742, 1743, 3, 2, 2, 2, 1743, 1752, 3, 2, 2, 2, 1744, 1746,
	9, 8, 2, 2, 1745, 1747, 5, 84, 43, 2, 1746, 1745, 3, 2, 2, 2, 1746, 1747,
	3, 2, 2, 2, 1747, 1749, 3, 2, 2, 2, 1748, 1750, 5, 166, 84, 2, 1749, 1748,
	3, 2, 2, 2, 1749, 1750, 3, 2, 2, 2, 1750, 1752, 3, 2, 2, 2, 1751, 1731,
	3, 2, 2, 2, 1751, 1744, 3, 2, 2, 2, 1752, 163, 3, 2, 2, 2, 1753, 1754,
	5, 162, 82, 2, 1754, 1755, 5, 112, 57, 2, 1755, 165, 3, 2, 2, 2, 1756,
	1757, 9, 9, 2, 2, 1757, 167, 3, 2, 2, 2, 1758, 1760, 5, 570, 286, 2, 1759,
	1758, 3, 2, 2, 2, 1760, 1763, 3, 2, 2, 2, 1761, 1759, 3, 2, 2, 2, 1761,
	1762, 3, 2, 2, 2, 1762, 1764, 3, 2, 2, 2, 1763, 1761, 3, 2, 2, 2, 1764,
	1815, 5, 170, 86, 2, 1765, 1767, 5, 570, 286, 2, 1766, 1765, 3, 2, 2, 2,
	1767, 1770, 3, 2, 2, 2, 1768, 1766, 3, 2, 2, 2, 1768, 1769, 3, 2, 2, 2,
	1769, 1771, 3, 2, 2, 2, 1770, 1768, 3, 2, 2, 2, 1771, 1815, 5, 68, 35,
	2, 1772, 1774, 5, 570, 286, 2, 1773, 1772, 3, 2, 2, 2, 1774, 1777, 3, 2,
	2, 2, 1775, 1773, 3, 2, 2, 2, 1775, 1776, 3, 2, 2, 2, 1776, 1778, 3, 2,
	2, 2, 1777, 1775, 3, 2, 2, 2, 1778, 1815, 5, 72, 37, 2, 1779, 1781, 5,
	570, 286, 2, 1780, 1779, 3, 2, 2, 2, 1781, 1784, 3, 2, 2, 2, 1782, 1780,
	3, 2, 2, 2, 1782, 1783, 3, 2, 2, 2, 1783, 1785, 3, 2, 2, 2, 1784, 1782,
	3, 2, 2, 2, 1785, 1815, 5, 54, 28, 2, 1786, 1788, 5, 570, 286, 2, 1787,
	1786, 3, 2, 2, 2, 1788, 1791, 3, 2, 2, 2, 1789, 1787, 3, 2, 2, 2, 1789,
	1790, 3, 2, 2, 2, 1790, 1792, 3, 2, 2, 2, 1791, 1789, 3, 2, 2, 2, 1792,
	1815, 5, 56, 29, 2, 1793, 1795, 5, 570, 286, 2, 1794, 1793, 3, 2, 2, 2,
	1795, 1798, 3, 2, 2, 2, 1796, 1794, 3, 2, 2, 2, 1796, 1797, 3, 2, 2, 2,
	1797, 1799, 3, 2, 2, 2, 1798, 1796, 3, 2, 2, 2, 1799, 1815, 5, 76, 39,
	2, 1800, 1802, 5, 570, 286, 2, 1801, 1800, 3, 2, 2, 2, 1802, 1805, 3, 2,
	2, 2, 1803, 1801, 3, 2, 2, 2, 1803, 1804, 3, 2, 2, 2, 1804, 1806, 3, 2,
	2, 2, 1805, 1803, 3, 2, 2, 2, 1806, 1815, 5, 78, 40, 2, 1807, 1809, 5,
	570, 286, 2, 1808, 1807, 3, 2, 2, 2, 1809, 1812, 3, 2, 2, 2, 1810, 1808,
	3, 2, 2, 2, 1810, 1811, 3, 2, 2, 2, 1811, 1813, 3, 2, 2, 2, 1812, 1810,
	3, 2, 2, 2, 1813, 1815, 5, 74, 38, 2, 1814, 1761, 3, 2, 2, 2, 1814, 1768,
	3, 2, 2, 2, 1814, 1775, 3, 2, 2, 2, 1814, 1782, 3, 2, 2, 2, 1814, 1789,
	3, 2, 2, 2, 1814, 1796, 3, 2, 2, 2, 1814, 1803, 3, 2, 2, 2, 1814, 1810,
	3, 2, 2, 2, 1815, 169, 3, 2, 2, 2, 1816, 1818, 7, 90, 2, 2, 1817, 1819,
	7, 100, 2, 2, 1818, 1817, 3, 2, 2, 2, 1818, 1819, 3, 2, 2, 2, 1819, 1821,
	3, 2, 2, 2, 1820, 1822, 5, 142, 72, 2, 1821, 1820, 3, 2, 2, 2, 1821, 1822,
	3, 2, 2, 2, 1822, 1823, 3, 2, 2, 2, 1823, 1824, 5, 172, 87, 2, 1824, 1825,
	7, 247, 2, 2, 1825, 171, 3, 2, 2, 2, 1826, 1831, 5, 174, 88, 2, 1827, 1828,
	7, 253, 2, 2, 1828, 1830, 5, 174, 88, 2, 1829, 1827, 3, 2, 2, 2, 1830,
	1833, 3, 2, 2, 2, 1831, 1829, 3, 2, 2, 2, 1831, 1832, 3, 2, 2, 2, 1832,
	173, 3, 2, 2, 2, 1833, 1831, 3, 2, 2, 2, 1834, 1844, 5, 662, 332, 2, 1835,
	1836, 5, 662, 332, 2, 1836, 1840, 5, 140, 71, 2, 1837, 1839, 5, 140, 71,
	2, 1838, 1837, 3, 2, 2, 2, 1839, 1842, 3, 2, 2, 2, 1840, 1838, 3, 2, 2,
	2, 1840, 1841, 3, 2, 2, 2, 1841, 1844, 3, 2, 2, 2, 1842, 1840, 3, 2, 2,
	2, 1843, 1834, 3, 2, 2, 2, 1843, 1835, 3, 2, 2, 2, 1844, 175, 3, 2, 2,
	2, 1845, 1847, 5, 212, 107, 2, 1846, 1848, 5, 100, 51, 2, 1847, 1846, 3,
	2, 2, 2, 1847, 1848, 3, 2, 2, 2, 1848, 1849, 3, 2, 2, 2, 1849, 1854, 5,
	178, 90, 2, 1850, 1851, 7, 253, 2, 2, 1851, 1853, 5, 178, 90, 2, 1852,
	1850, 3, 2, 2, 2, 1853, 1856, 3, 2, 2, 2, 1854, 1852, 3, 2, 2, 2, 1854,
	1855, 3, 2, 2, 2, 1855, 1857, 3, 2, 2, 2, 1856, 1854, 3, 2, 2, 2, 1857,
	1858, 7, 247, 2, 2, 1858, 1978, 3, 2, 2, 2, 1859, 1861, 5, 216, 109, 2,
	1860, 1862, 5, 100, 51, 2, 1861, 1860, 3, 2, 2, 2, 1861, 1862, 3, 2, 2,
	2, 1862, 1863, 3, 2, 2, 2, 1863, 1868, 5, 182, 92, 2, 1864, 1865, 7, 253,
	2, 2, 1865, 1867, 5, 182, 92, 2, 1866, 1864, 3, 2, 2, 2, 1867, 1870, 3,
	2, 2, 2, 1868, 1866, 3, 2, 2, 2, 1868, 1869, 3, 2, 2, 2, 1869, 1871, 3,
	2, 2, 2, 1870, 1868, 3, 2, 2, 2, 1871, 1872, 7, 247, 2, 2, 1872, 1978,
	3, 2, 2, 2, 1873, 1874, 5, 224, 113, 2, 1874, 1879, 5, 188, 95, 2, 1875,
	1876, 7, 253, 2, 2, 1876, 1878, 5, 188, 95, 2, 1877, 1875, 3, 2, 2, 2,
	1878, 1881, 3, 2, 2, 2, 1879, 1877, 3, 2, 2, 2, 1879, 1880, 3, 2, 2, 2,
	1880, 1882, 3, 2, 2, 2, 1881, 1879, 3, 2, 2, 2, 1882, 1883, 7, 247, 2,
	2, 1883, 1978, 3, 2, 2, 2, 1884, 1886, 7, 83, 2, 2, 1885, 1887, 5, 196,
	99, 2, 1886, 1885, 3, 2, 2, 2, 1886, 1887, 3, 2, 2, 2, 1887, 1888, 3, 2,
	2, 2, 1888, 1893, 5, 192, 97, 2, 1889, 1890, 7, 253, 2, 2, 1890, 1892,
	5, 192, 97, 2, 1891, 1889, 3, 2, 2, 2, 1892, 1895, 3, 2, 2, 2, 1893, 1891,
	3, 2, 2, 2, 1893, 1894, 3, 2, 2, 2, 1894, 1896, 3, 2, 2, 2, 1895, 1893,
	3, 2, 2, 2, 1896, 1897, 7, 247, 2, 2, 1897, 1978, 3, 2, 2, 2, 1898, 1900,
	7, 84, 2, 2, 1899, 1901, 5, 198, 100, 2, 1900, 1899, 3, 2, 2, 2, 1900,
	1901, 3, 2, 2, 2, 1901, 1902, 3, 2, 2, 2, 1902, 1907, 5, 192, 97, 2, 1903,
	1904, 7, 253, 2, 2, 1904, 1906, 5, 192, 97, 2, 1905, 1903, 3, 2, 2, 2,
	1906, 1909, 3, 2, 2, 2, 1907, 1905, 3, 2, 2, 2, 1907, 1908, 3, 2, 2, 2,
	1908, 1910, 3, 2, 2, 2, 1909, 1907, 3, 2, 2, 2, 1910, 1911, 7, 247, 2,
	2, 1911, 1978, 3, 2, 2, 2, 1912, 1914, 5, 214, 108, 2, 1913, 1915, 5, 92,
	47, 2, 1914, 1913, 3, 2, 2, 2, 1914, 1915, 3, 2, 2, 2, 1915, 1917, 3, 2,
	2, 2, 1916, 1918, 5, 100, 51, 2, 1917, 1916, 3, 2, 2, 2, 1917, 1918, 3,
	2, 2, 2, 1918, 1919, 3, 2, 2, 2, 1919, 1924, 5, 180, 91, 2, 1920, 1921,
	7, 253, 2, 2, 1921, 1923, 5, 180, 91, 2, 1922, 1920, 3, 2, 2, 2, 1923,
	1926, 3, 2, 2, 2, 1924, 1922, 3, 2, 2, 2, 1924, 1925, 3, 2, 2, 2, 1925,
	1927, 3, 2, 2, 2, 1926, 1924, 3, 2, 2, 2, 1927, 1928, 7, 247, 2, 2, 1928,
	1978, 3, 2, 2, 2, 1929, 1931, 5, 218, 110, 2, 1930, 1932, 5, 92, 47, 2,
	1931, 1930, 3, 2, 2, 2, 1931, 1932, 3, 2, 2, 2, 1932, 1934, 3, 2, 2, 2,
	1933, 1935, 5, 102, 52, 2, 1934, 1933, 3, 2, 2, 2, 1934, 1935, 3, 2, 2,
	2, 1935, 1936, 3, 2, 2, 2, 1936, 1941, 5, 184, 93, 2, 1937, 1938, 7, 253,
	2, 2, 1938, 1940, 5, 184, 93, 2, 1939, 1937, 3, 2, 2, 2, 1940, 1943, 3,
	2, 2, 2, 1941, 1939, 3, 2, 2, 2, 1941, 1942, 3, 2, 2, 2, 1942, 1944, 3,
	2, 2, 2, 1943, 1941, 3, 2, 2, 2, 1944, 1945, 7, 247, 2, 2, 1945, 1978,
	3, 2, 2, 2, 1946, 1948, 5, 220, 111, 2, 1947, 1949, 5, 92, 47, 2, 1948,
	1947, 3, 2, 2, 2, 1948, 1949, 3, 2, 2, 2, 1949, 1951, 3, 2, 2, 2, 1950,
	1952, 5, 102, 52, 2, 1951, 1950, 3, 2, 2, 2, 1951, 1952, 3, 2, 2, 2, 1952,
	1953, 3, 2, 2, 2, 1953, 1958, 5, 186, 94, 2, 1954, 1955, 7, 253, 2, 2,
	1955, 1957, 5, 186, 94, 2, 1956, 1954, 3, 2, 2, 2, 1957, 1960, 3, 2, 2,
	2, 1958, 1956, 3, 2, 2, 2, 1958, 1959, 3, 2, 2, 2, 1959, 1961, 3, 2, 2,
	2, 1960, 1958, 3, 2, 2, 2, 1961, 1962, 7, 247, 2, 2, 1962, 1978, 3, 2,
	2, 2, 1963, 1965, 5, 222, 112, 2, 1964, 1966, 5, 102, 52, 2, 1965, 1964,
	3, 2, 2, 2, 1965, 1966, 3, 2, 2, 2, 1966, 1967, 3, 2, 2, 2, 1967, 1972,
	5, 190, 96, 2, 1968, 1969, 7, 253, 2, 2, 1969, 1971, 5, 190, 96, 2, 1970,
	1968, 3, 2, 2, 2, 1971, 1974, 3, 2, 2, 2, 1972, 1970, 3, 2, 2, 2, 1972,
	1973, 3, 2, 2, 2, 1973, 1975, 3, 2, 2, 2, 1974, 1972, 3, 2, 2, 2, 1975,
	1976, 7, 247, 2, 2, 1976, 1978, 3, 2, 2, 2, 1977, 1845, 3, 2, 2, 2, 1977,
	1859, 3, 2, 2, 2, 1977, 1873, 3, 2, 2, 2, 1977, 1884, 3, 2, 2, 2, 1977,
	1898, 3, 2, 2, 2, 1977, 1912, 3, 2, 2, 2, 1977, 1929, 3, 2, 2, 2, 1977,
	1946, 3, 2, 2, 2, 1977, 1963, 3, 2, 2, 2, 1978, 177, 3, 2, 2, 2, 1979,
	1981, 5, 194, 98, 2, 1980, 1979, 3, 2, 2, 2, 1980, 1981, 3, 2, 2, 2, 1981,
	1982, 3, 2, 2, 2, 1982, 1983, 7, 256, 2, 2, 1983, 1984, 5, 210, 106, 2,
	1984, 1985, 7, 253, 2, 2, 1985, 1986, 5, 206, 104, 2, 1986, 1987, 7, 253,
	2, 2, 1987, 1988, 5, 202, 102, 2, 1988, 1989, 7, 253, 2, 2, 1989, 1990,
	5, 204, 103, 2, 1990, 1991, 7, 257, 2, 2, 1991, 179, 3, 2, 2, 2, 1992,
	1994, 5, 194, 98, 2, 1993, 1992, 3, 2, 2, 2, 1993, 1994, 3, 2, 2, 2, 1994,
	1995, 3, 2, 2, 2, 1995, 1996, 7, 256, 2, 2, 1996, 1997, 5, 210, 106, 2,
	1997, 1998, 7, 253, 2, 2, 1998, 1999, 5, 206, 104, 2, 1999, 2000, 7, 253,
	2, 2, 2000, 2001, 5, 200, 101, 2, 2001, 2002, 7, 257, 2, 2, 2002, 181,
	3, 2, 2, 2, 2003, 2005, 5, 194, 98, 2, 2004, 2003, 3, 2, 2, 2, 2004, 2005,
	3, 2, 2, 2, 2005, 2006, 3, 2, 2, 2, 2006, 2007, 7, 256, 2, 2, 2007, 2008,
	5, 210, 106, 2, 2008, 2009, 7, 253, 2, 2, 2009, 2010, 5, 206, 104, 2, 2010,
	2011, 7, 253, 2, 2, 2011, 2012, 5, 200, 101, 2, 2012, 2013, 7, 257, 2,
	2, 2013, 183, 3, 2, 2, 2, 2014, 2016, 5, 194, 98, 2, 2015, 2014, 3, 2,
	2, 2, 2015, 2016, 3, 2, 2, 2, 2016, 2017, 3, 2, 2, 2, 2017, 2018, 7, 256,
	2, 2, 2018, 2019, 5, 210, 106, 2, 2019, 2020, 7, 253, 2, 2, 2020, 2025,
	5, 206, 104, 2, 2021, 2022, 7, 253, 2, 2, 2022, 2024, 5, 206, 104, 2, 2023,
	2021, 3, 2, 2, 2, 2024, 2027, 3, 2, 2, 2, 2025, 2023, 3, 2, 2, 2, 2025,
	2026, 3, 2, 2, 2, 2026, 2028, 3, 2, 2, 2, 2027, 2025, 3, 2, 2, 2, 2028,
	2029, 7, 257, 2, 2, 2029, 185, 3, 2, 2, 2, 2030, 2032, 5, 194, 98, 2, 2031,
	2030, 3, 2, 2, 2, 2031, 2032, 3, 2, 2, 2, 2032, 2033, 3, 2, 2, 2, 2033,
	2034, 7, 256, 2, 2, 2034, 2039, 5, 210, 106, 2, 2035, 2036, 7, 253, 2,
	2, 2036, 2038, 5, 210, 106, 2, 2037, 2035, 3, 2, 2, 2, 2038, 2041, 3, 2,
	2, 2, 2039, 2037, 3, 2, 2, 2, 2039, 2040, 3, 2, 2, 2, 2040, 2042, 3, 2,
	2, 2, 2041, 2039, 3, 2, 2, 2, 2042, 2043, 7, 253, 2, 2, 2043, 2044, 5,
	206, 104, 2, 2044, 2045, 7, 257, 2, 2, 2045, 187, 3, 2, 2, 2, 2046, 2048,
	5, 194, 98, 2, 2047, 2046, 3, 2, 2, 2, 2047, 2048, 3, 2, 2, 2, 2048, 2049,
	3, 2, 2, 2, 2049, 2050, 7, 256, 2, 2, 2050, 2051, 5, 208, 105, 2, 2051,
	2052, 7, 253, 2, 2, 2052, 2053, 5, 208, 105, 2, 2053, 2054, 7, 257, 2,
	2, 2054, 189, 3, 2, 2, 2, 2055, 2057, 5, 194, 98, 2, 2056, 2055, 3, 2,
	2, 2, 2056, 2057, 3, 2, 2, 2, 2057, 2058, 3, 2, 2, 2, 2058, 2059, 7, 256,
	2, 2, 2059, 2060, 5, 208, 105, 2, 2060, 2061, 7, 253, 2, 2, 2061, 2062,
	5, 208, 105, 2, 2062, 2063, 7, 253, 2, 2, 2063, 2064, 5, 200, 101, 2, 2064,
	2065, 7, 257, 2, 2, 2065, 191, 3, 2, 2, 2, 2066, 2068, 5, 194, 98, 2, 2067,
	2066, 3, 2, 2, 2, 2067, 2068, 3, 2, 2, 2, 2068, 2069, 3, 2, 2, 2, 2069,
	2070, 7, 256, 2, 2, 2070, 2071, 5, 210, 106, 2, 2071, 2072, 7, 257, 2,
	2, 2072, 193, 3, 2, 2, 2, 2073, 2075, 5, 592, 297, 2, 2074, 2076, 5, 142,
	72, 2, 2075, 2074, 3, 2, 2, 2, 2075, 2076, 3, 2, 2, 2, 2076, 195, 3, 2,
	2, 2, 2077, 2078, 7, 256, 2, 2, 2078, 2079, 5, 94, 48, 2, 2079, 2080, 7,
	253, 2, 2, 2080, 2081, 5, 96, 49, 2, 2081, 2082, 7, 257, 2, 2, 2082, 2094,
	3, 2, 2, 2, 2083, 2084, 7, 256, 2, 2, 2084, 2085, 5, 96, 49, 2, 2085, 2086,
	7, 253, 2, 2, 2086, 2087, 5, 94, 48, 2, 2087, 2088, 7, 257, 2, 2, 2088,
	2094, 3, 2, 2, 2, 2089, 2090, 7, 256, 2, 2, 2090, 2091, 5, 94, 48, 2, 2091,
	2092, 7, 257, 2, 2, 2092, 2094, 3, 2, 2, 2, 2093, 2077, 3, 2, 2, 2, 2093,
	2083, 3, 2, 2, 2, 2093, 2089, 3, 2, 2, 2, 2094, 197, 3, 2, 2, 2, 2095,
	2096, 7, 256, 2, 2, 2096, 2097, 5, 94, 48, 2, 2097, 2098, 7, 253, 2, 2,
	2098, 2099, 5, 96, 49, 2, 2099, 2100, 7, 257, 2, 2, 2100, 2112, 3, 2, 2,
	2, 2101, 2102, 7, 256, 2, 2, 2102, 2103, 5, 96, 49, 2, 2103, 2104, 7, 253,
	2, 2, 2104, 2105, 5, 94, 48, 2, 2105, 2106, 7, 257, 2, 2, 2106, 2112, 3,
	2, 2, 2, 2107, 2108, 7, 256, 2, 2, 2108, 2109, 5, 96, 49, 2, 2109, 2110,
	7, 257, 2, 2, 2110, 2112, 3, 2, 2, 2, 2111, 2095, 3, 2, 2, 2, 2111, 2101,
	3, 2, 2, 2, 2111, 2107, 3, 2, 2, 2, 2112, 199, 3, 2, 2, 2, 2113, 2114,
	5, 530, 266, 2, 2114, 201, 3, 2, 2, 2, 2115, 2116, 5, 530, 266, 2, 2116,
	203, 3, 2, 2, 2, 2117, 2118, 5, 530, 266, 2, 2118, 205, 3, 2, 2, 2, 2119,
	2120, 5, 530, 266, 2, 2120, 207, 3, 2, 2, 2, 2121, 2122, 5, 556, 279, 2,
	2122, 209, 3, 2, 2, 2, 2123, 2124, 5, 556, 279, 2, 2124, 211, 3, 2, 2,
	2, 2125, 2126, 9, 10, 2, 2, 2126, 213, 3, 2, 2, 2, 2127, 2128, 9, 11, 2,
	2, 2128, 215, 3, 2, 2, 2, 2129, 2130, 9, 12, 2, 2, 2130, 217, 3, 2, 2,
	2, 2131, 2132, 9, 13, 2, 2, 2132, 219, 3, 2, 2, 2, 2133, 2134, 9, 14, 2,
	2, 2134, 221, 3, 2, 2, 2, 2135, 2136, 9, 15, 2, 2, 2136, 223, 3, 2, 2,
	2, 2137, 2138, 9, 16, 2, 2, 2138, 225, 3, 2, 2, 2, 2139, 2141, 5, 626,
	314, 2, 2140, 2142, 5, 228, 115, 2, 2141, 2140, 3, 2, 2, 2, 2141, 2142,
	3, 2, 2, 2, 2142, 2143, 3, 2, 2, 2, 2143, 2148, 5, 236, 119, 2, 2144, 2145,
	7, 253, 2, 2, 2145, 2147, 5, 236, 119, 2, 2146, 2144, 3, 2, 2, 2, 2147,
	2150, 3, 2, 2, 2, 2148, 2146, 3, 2, 2, 2, 2148, 2149, 3, 2, 2, 2, 2149,
	2151, 3, 2, 2, 2, 2150, 2148, 3, 2, 2, 2, 2151, 2152, 7, 247, 2, 2, 2152,
	227, 3, 2, 2, 2, 2153, 2154, 7, 264, 2, 2, 2154, 2155, 7, 256, 2, 2, 2155,
	2156, 5, 230, 116, 2, 2156, 2157, 7, 257, 2, 2, 2157, 229, 3, 2, 2, 2,
	2158, 2163, 5, 232, 117, 2, 2159, 2160, 7, 253, 2, 2, 2160, 2162, 5, 232,
	117, 2, 2161, 2159, 3, 2, 2, 2, 2162, 2165, 3, 2, 2, 2, 2163, 2161, 3,
	2, 2, 2, 2163, 2164, 3, 2, 2, 2, 2164, 2175, 3, 2, 2, 2, 2165, 2163, 3,
	2, 2, 2, 2166, 2171, 5, 234, 118, 2, 2167, 2168, 7, 253, 2, 2, 2168, 2170,
	5, 234, 118, 2, 2169, 2167, 3, 2, 2, 2, 2170, 2173, 3, 2, 2, 2, 2171, 2169,
	3, 2, 2, 2, 2171, 2172, 3, 2, 2, 2, 2172, 2175, 3, 2, 2, 2, 2173, 2171,
	3, 2, 2, 2, 2174, 2158, 3, 2, 2, 2, 2174, 2166, 3, 2, 2, 2, 2175, 231,
	3, 2, 2, 2, 2176, 2177, 5, 530, 266, 2, 2177, 233, 3, 2, 2, 2, 2178, 2179,
	7, 250, 2, 2, 2179, 2180, 5, 634, 318, 2, 2180, 2182, 7, 256, 2, 2, 2181,
	2183, 5, 530, 266, 2, 2182, 2181, 3, 2, 2, 2, 2182, 2183, 3, 2, 2, 2, 2183,
	2184, 3, 2, 2, 2, 2184, 2185, 7, 257, 2, 2, 2185, 235, 3, 2, 2, 2, 2186,
	2187, 5, 238, 120, 2, 2187, 2188, 7, 256, 2, 2, 2188, 2189, 5, 240, 121,
	2, 2189, 2190, 7, 257, 2, 2, 2190, 237, 3, 2, 2, 2, 2191, 2193, 5, 628,
	315, 2, 2192, 2194, 5, 142, 72, 2, 2193, 2192, 3, 2, 2, 2, 2193, 2194,
	3, 2, 2, 2, 2194, 239, 3, 2, 2, 2, 2195, 2200, 5, 242, 122, 2, 2196, 2197,
	7, 253, 2, 2, 2197, 2199, 5, 242, 122, 2, 2198, 2196, 3, 2, 2, 2, 2199,
	2202, 3, 2, 2, 2, 2200, 2198, 3, 2, 2, 2, 2200, 2201, 3, 2, 2, 2, 2201,
	2212, 3, 2, 2, 2, 2202, 2200, 3, 2, 2, 2, 2203, 2208, 5, 244, 123, 2, 2204,
	2205, 7, 253, 2, 2, 2205, 2207, 5, 244, 123, 2, 2206, 2204, 3, 2, 2, 2,
	2207, 2210, 3, 2, 2, 2, 2208, 2206, 3, 2, 2, 2, 2208, 2209, 3, 2, 2, 2,
	2209, 2212, 3, 2, 2, 2, 2210, 2208, 3, 2, 2, 2, 2211, 2195, 3, 2, 2, 2,
	2211, 2203, 3, 2, 2, 2, 2212, 241, 3, 2, 2, 2, 2213, 2215, 5, 570, 286,
	2, 2214, 2213, 3, 2, 2, 2, 2215, 2218, 3, 2, 2, 2, 2216, 2214, 3, 2, 2,
	2, 2216, 2217, 3, 2, 2, 2, 2217, 2220, 3, 2, 2, 2, 2218, 2216, 3, 2, 2,
	2, 2219, 2221, 5, 530, 266, 2, 2220, 2219, 3, 2, 2, 2, 2220, 2221, 3, 2,
	2, 2, 2221, 243, 3, 2, 2, 2, 2222, 2224, 5, 570, 286, 2, 2223, 2222, 3,
	2, 2, 2, 2224, 2227, 3, 2, 2, 2, 2225, 2223, 3, 2, 2, 2, 2225, 2226, 3,
	2, 2, 2, 2226, 2228, 3, 2, 2, 2, 2227, 2225, 3, 2, 2, 2, 2228, 2229, 7,
	250, 2, 2, 2229, 2230, 5, 636, 319, 2, 2230, 2232, 7, 256, 2, 2, 2231,
	2233, 5, 530, 266, 2, 2232, 2231, 3, 2, 2, 2, 2232, 2233, 3, 2, 2, 2, 2233,
	2234, 3, 2, 2, 2, 2234, 2235, 7, 257, 2, 2, 2235, 245, 3, 2, 2, 2, 2236,
	2240, 7, 50, 2, 2, 2237, 2239, 5, 250, 126, 2, 2238, 2237, 3, 2, 2, 2,
	2239, 2242, 3, 2, 2, 2, 2240, 2238, 3, 2, 2, 2, 2240, 2241, 3, 2, 2, 2,
	2241, 2243, 3, 2, 2, 2, 2242, 2240, 3, 2, 2, 2, 2243, 2244, 7, 37, 2, 2,
	2244, 247, 3, 2, 2, 2, 2245, 2248, 5, 250, 126, 2, 2246, 2248, 7, 247,
	2, 2, 2247, 2245, 3, 2, 2, 2, 2247, 2246, 3, 2, 2, 2, 2248, 249, 3, 2,
	2, 2, 2249, 2255, 5, 252, 127, 2, 2250, 2255, 5, 254, 128, 2, 2251, 2255,
	5, 258, 130, 2, 2252, 2255, 5, 262, 132, 2, 2253, 2255, 5, 48, 25, 2, 2254,
	2249, 3, 2, 2, 2, 2254, 2250, 3, 2, 2, 2, 2254, 2251, 3, 2, 2, 2, 2254,
	2252, 3, 2, 2, 2, 2254, 2253, 3, 2, 2, 2, 2255, 251, 3, 2, 2, 2, 2256,
	2257, 7, 52, 2, 2, 2257, 2258, 7, 256, 2, 2, 2258, 2259, 5, 522, 262, 2,
	2259, 2260, 7, 257, 2, 2, 2260, 2263, 5, 248, 125, 2, 2261, 2262, 7, 32,
	2, 2, 2262, 2264, 5, 248, 125, 2, 2263, 2261, 3, 2, 2, 2, 2263, 2264, 3,
	2, 2, 2, 2264, 253, 3, 2, 2, 2, 2265, 2266, 7, 19, 2, 2, 2266, 2267, 7,
	256, 2, 2, 2267, 2268, 5, 522, 262, 2, 2268, 2269, 7, 257, 2, 2, 2269,
	2273, 5, 256, 129, 2, 2270, 2272, 5, 256, 129, 2, 2271, 2270, 3, 2, 2,
	2, 2272, 2275, 3, 2, 2, 2, 2273, 2271, 3, 2, 2, 2, 2273, 2274, 3, 2, 2,
	2, 2274, 2276, 3, 2, 2, 2, 2275, 2273, 3, 2, 2, 2, 2276, 2277, 7, 34, 2,
	2, 2277, 255, 3, 2, 2, 2, 2278, 2283, 5, 522, 262, 2, 2279, 2280, 7, 253,
	2, 2, 2280, 2282, 5, 522, 262, 2, 2281, 2279, 3, 2, 2, 2, 2282, 2285, 3,
	2, 2, 2, 2283, 2281, 3, 2, 2, 2, 2283, 2284, 3, 2, 2, 2, 2284, 2286, 3,
	2, 2, 2, 2285, 2283, 3, 2, 2, 2, 2286, 2287, 7, 248, 2, 2, 2287, 2288,
	5, 248, 125, 2, 2288, 2295, 3, 2, 2, 2, 2289, 2291, 7, 26, 2, 2, 2290,
	2292, 7, 248, 2, 2, 2291, 2290, 3, 2, 2, 2, 2291, 2292, 3, 2, 2, 2, 2292,
	2293, 3, 2, 2, 2, 2293, 2295, 5, 248, 125, 2, 2294, 2278, 3, 2, 2, 2, 2294,
	2289, 3, 2, 2, 2, 2295, 257, 3, 2, 2, 2, 2296, 2297, 7, 43, 2, 2, 2297,
	2298, 7, 256, 2, 2, 2298, 2299, 5, 260, 131, 2, 2299, 2300, 7, 247, 2,
	2, 2300, 2301, 5, 522, 262, 2, 2301, 2302, 7, 247, 2, 2, 2302, 2303, 5,
	260, 131, 2, 2303, 2304, 7, 257, 2, 2, 2304, 2305, 5, 262, 132, 2, 2305,
	259, 3, 2, 2, 2, 2306, 2307, 5, 598, 300, 2, 2307, 2308, 7, 267, 2, 2,
	2308, 2309, 5, 522, 262, 2, 2309, 261, 3, 2, 2, 2, 2310, 2313, 7, 15, 2,
	2, 2311, 2312, 7, 248, 2, 2, 2312, 2314, 5, 594, 298, 2, 2313, 2311, 3,
	2, 2, 2, 2313, 2314, 3, 2, 2, 2, 2314, 2318, 3, 2, 2, 2, 2315, 2317, 5,
	250, 126, 2, 2316, 2315, 3, 2, 2, 2, 2317, 2320, 3, 2, 2, 2, 2318, 2316,
	3, 2, 2, 2, 2318, 2319, 3, 2, 2, 2, 2319, 2321, 3, 2, 2, 2, 2320, 2318,
	3, 2, 2, 2, 2321, 2322, 7, 33, 2, 2, 2322, 263, 3, 2, 2, 2, 2323, 2325,
	7, 11, 2, 2, 2324, 2326, 5, 92, 47, 2, 2325, 2324, 3, 2, 2, 2, 2325, 2326,
	3, 2, 2, 2, 2326, 2328, 3, 2, 2, 2, 2327, 2329, 5, 100, 51, 2, 2328, 2327,
	3, 2, 2, 2, 2328, 2329, 3, 2, 2, 2, 2329, 2330, 3, 2, 2, 2, 2330, 2331,
	5, 266, 134, 2, 2331, 2332, 7, 247, 2, 2, 2332, 265, 3, 2, 2, 2, 2333,
	2338, 5, 268, 135, 2, 2334, 2335, 7, 253, 2, 2, 2335, 2337, 5, 268, 135,
	2, 2336, 2334, 3, 2, 2, 2, 2337, 2340, 3, 2, 2, 2, 2338, 2336, 3, 2, 2,
	2, 2338, 2339, 3, 2, 2, 2, 2339, 267, 3, 2, 2, 2, 2340, 2338, 3, 2, 2,
	2, 2341, 2342, 5, 556, 279, 2, 2342, 2343, 7, 267, 2, 2, 2343, 2344, 5,
	530, 266, 2, 2344, 269, 3, 2, 2, 2, 2345, 2346, 7, 55, 2, 2, 2346, 2347,
	5, 292, 147, 2, 2347, 271, 3, 2, 2, 2, 2348, 2349, 7, 9, 2, 2, 2349, 2350,
	5, 292, 147, 2, 2350, 273, 3, 2, 2, 2, 2351, 2352, 5, 558, 280, 2, 2352,
	2354, 7, 267, 2, 2, 2353, 2355, 5, 298, 150, 2, 2354, 2353, 3, 2, 2, 2,
	2354, 2355, 3, 2, 2, 2, 2355, 2356, 3, 2, 2, 2, 2356, 2357, 5, 530, 266,
	2, 2357, 275, 3, 2, 2, 2, 2358, 2359, 5, 558, 280, 2, 2359, 2361, 7, 272,
	2, 2, 2360, 2362, 5, 298, 150, 2, 2361, 2360, 3, 2, 2, 2, 2361, 2362, 3,
	2, 2, 2, 2362, 2363, 3, 2, 2, 2, 2363, 2364, 5, 530, 266, 2, 2364, 277,
	3, 2, 2, 2, 2365, 2366, 7, 11, 2, 2, 2366, 2378, 5, 286, 144, 2, 2367,
	2368, 7, 25, 2, 2, 2368, 2378, 5, 558, 280, 2, 2369, 2370, 7, 44, 2, 2,
	2370, 2378, 5, 286, 144, 2, 2371, 2372, 7, 44, 2, 2, 2372, 2378, 5, 268,
	135, 2, 2373, 2374, 7, 91, 2, 2, 2374, 2378, 5, 558, 280, 2, 2375, 2376,
	7, 91, 2, 2, 2376, 2378, 5, 556, 279, 2, 2377, 2365, 3, 2, 2, 2, 2377,
	2367, 3, 2, 2, 2, 2377, 2369, 3, 2, 2, 2, 2377, 2371, 3, 2, 2, 2, 2377,
	2373, 3, 2, 2, 2, 2377, 2375, 3, 2, 2, 2, 2378, 279, 3, 2, 2, 2, 2379,
	2380, 5, 558, 280, 2, 2380, 2381, 7, 267, 2, 2, 2381, 2382, 5, 530, 266,
	2, 2382, 281, 3, 2, 2, 2, 2383, 2392, 5, 296, 149, 2, 2384, 2386, 5, 570,
	286, 2, 2385, 2384, 3, 2, 2, 2, 2386, 2389, 3, 2, 2, 2, 2387, 2385, 3,
	2, 2, 2, 2387, 2388, 3, 2, 2, 2, 2388, 2390, 3, 2, 2, 2, 2389, 2387, 3,
	2, 2, 2, 2390, 2392, 7, 247, 2, 2, 2391, 2383, 3, 2, 2, 2, 2391, 2387,
	3, 2, 2, 2, 2392, 283, 3, 2, 2, 2, 2393, 2402, 7, 15, 2, 2, 2394, 2395,
	7, 248, 2, 2, 2395, 2399, 5, 578, 290, 2, 2396, 2398, 5, 168, 85, 2, 2397,
	2396, 3, 2, 2, 2, 2398, 2401, 3, 2, 2, 2, 2399, 2397, 3, 2, 2, 2, 2399,
	2400, 3, 2, 2, 2, 2400, 2403, 3, 2, 2, 2, 2401, 2399, 3, 2, 2, 2, 2402,
	2394, 3, 2, 2, 2, 2402, 2403, 3, 2, 2, 2, 2403, 2407, 3, 2, 2, 2, 2404,
	2406, 5, 296, 149, 2, 2405, 2404, 3, 2, 2, 2, 2406, 2409, 3, 2, 2, 2, 2407,
	2405, 3, 2, 2, 2, 2407, 2408, 3, 2, 2, 2, 2408, 2410, 3, 2, 2, 2, 2409,
	2407, 3, 2, 2, 2, 2410, 2411, 7, 33, 2, 2, 2411, 285, 3, 2, 2, 2, 2412,
	2413, 5, 558, 280, 2, 2413, 2414, 7, 267, 2, 2, 2414, 2415, 5, 530, 266,
	2, 2415, 287, 3, 2, 2, 2, 2416, 2425, 7, 46, 2, 2, 2417, 2418, 7, 248,
	2, 2, 2418, 2422, 5, 578, 290, 2, 2419, 2421, 5, 168, 85, 2, 2420, 2419,
	3, 2, 2, 2, 2421, 2424, 3, 2, 2, 2, 2422, 2420, 3, 2, 2, 2, 2422, 2423,
	3, 2, 2, 2, 2423, 2426, 3, 2, 2, 2, 2424, 2422, 3, 2, 2, 2, 2425, 2417,
	3, 2, 2, 2, 2425, 2426, 3, 2, 2, 2, 2426, 2430, 3, 2, 2, 2, 2427, 2429,
	5, 292, 147, 2, 2428, 2427, 3, 2, 2, 2, 2429, 2432, 3, 2, 2, 2, 2430, 2428,
	3, 2, 2, 2, 2430, 2431, 3, 2, 2, 2, 2431, 2433, 3, 2, 2, 2, 2432, 2430,
	3, 2, 2, 2, 2433, 2434, 7, 60, 2, 2, 2434, 289, 3, 2, 2, 2, 2435, 2444,
	7, 15, 2, 2, 2436, 2437, 7, 248, 2, 2, 2437, 2441, 5, 578, 290, 2, 2438,
	2440, 5, 168, 85, 2, 2439, 2438, 3, 2, 2, 2, 2440, 2443, 3, 2, 2, 2, 2441,
	2439, 3, 2, 2, 2, 2441, 2442, 3, 2, 2, 2, 2442, 2445, 3, 2, 2, 2, 2443,
	2441, 3, 2, 2, 2, 2444, 2436, 3, 2, 2, 2, 2444, 2445, 3, 2, 2, 2, 2445,
	2449, 3, 2, 2, 2, 2446, 2448, 5, 292, 147, 2, 2447, 2446, 3, 2, 2, 2, 2448,
	2451, 3, 2, 2, 2, 2449, 2447, 3, 2, 2, 2, 2449, 2450, 3, 2, 2, 2, 2450,
	2452, 3, 2, 2, 2, 2451, 2449, 3, 2, 2, 2, 2452, 2453, 7, 33, 2, 2, 2453,
	291, 3, 2, 2, 2, 2454, 2456, 5, 570, 286, 2, 2455, 2454, 3, 2, 2, 2, 2456,
	2459, 3, 2, 2, 2, 2457, 2455, 3, 2, 2, 2, 2457, 2458, 3, 2, 2, 2, 2458,
	2460, 3, 2, 2, 2, 2459, 2457, 3, 2, 2, 2, 2460, 2461, 5, 274, 138, 2, 2461,
	2462, 7, 247, 2, 2, 2462, 2559, 3, 2, 2, 2, 2463, 2465, 5, 570, 286, 2,
	2464, 2463, 3, 2, 2, 2, 2465, 2468, 3, 2, 2, 2, 2466, 2464, 3, 2, 2, 2,
	2466, 2467, 3, 2, 2, 2, 2467, 2469, 3, 2, 2, 2, 2468, 2466, 3, 2, 2, 2,
	2469, 2559, 5, 324, 163, 2, 2470, 2472, 5, 570, 286, 2, 2471, 2470, 3,
	2, 2, 2, 2472, 2475, 3, 2, 2, 2, 2473, 2471, 3, 2, 2, 2, 2473, 2474, 3,
	2, 2, 2, 2474, 2476, 3, 2, 2, 2, 2475, 2473, 3, 2, 2, 2, 2476, 2559, 5,
	316, 159, 2, 2477, 2479, 5, 570, 286, 2, 2478, 2477, 3, 2, 2, 2, 2479,
	2482, 3, 2, 2, 2, 2480, 2478, 3, 2, 2, 2, 2480, 2481, 3, 2, 2, 2, 2481,
	2483, 3, 2, 2, 2, 2482, 2480, 3, 2, 2, 2, 2483, 2559, 5, 302, 152, 2, 2484,
	2486, 5, 570, 286, 2, 2485, 2484, 3, 2, 2, 2, 2486, 2489, 3, 2, 2, 2, 2487,
	2485, 3, 2, 2, 2, 2487, 2488, 3, 2, 2, 2, 2488, 2490, 3, 2, 2, 2, 2489,
	2487, 3, 2, 2, 2, 2490, 2559, 5, 306, 154, 2, 2491, 2493, 5, 570, 286,
	2, 2492, 2491, 3, 2, 2, 2, 2493, 2496, 3, 2, 2, 2, 2494, 2492, 3, 2, 2,
	2, 2494, 2495, 3, 2, 2, 2, 2495, 2497, 3, 2, 2, 2, 2496, 2494, 3, 2, 2,
	2, 2497, 2559, 5, 334, 168, 2, 2498, 2500, 5, 570, 286, 2, 2499, 2498,
	3, 2, 2, 2, 2500, 2503, 3, 2, 2, 2, 2501, 2499, 3, 2, 2, 2, 2501, 2502,
	3, 2, 2, 2, 2502, 2504, 3, 2, 2, 2, 2503, 2501, 3, 2, 2, 2, 2504, 2505,
	5, 276, 139, 2, 2505, 2506, 7, 247, 2, 2, 2506, 2559, 3, 2, 2, 2, 2507,
	2509, 5, 570, 286, 2, 2508, 2507, 3, 2, 2, 2, 2509, 2512, 3, 2, 2, 2, 2510,
	2508, 3, 2, 2, 2, 2510, 2511, 3, 2, 2, 2, 2511, 2513, 3, 2, 2, 2, 2512,
	2510, 3, 2, 2, 2, 2513, 2559, 5, 288, 145, 2, 2514, 2516, 5, 570, 286,
	2, 2515, 2514, 3, 2, 2, 2, 2516, 2519, 3, 2, 2, 2, 2517, 2515, 3, 2, 2,
	2, 2517, 2518, 3, 2, 2, 2, 2518, 2520, 3, 2, 2, 2, 2519, 2517, 3, 2, 2,
	2, 2520, 2521, 5, 278, 140, 2, 2521, 2522, 7, 247, 2, 2, 2522, 2559, 3,
	2, 2, 2, 2523, 2525, 5, 570, 286, 2, 2524, 2523, 3, 2, 2, 2, 2525, 2528,
	3, 2, 2, 2, 2526, 2524, 3, 2, 2, 2, 2526, 2527, 3, 2, 2, 2, 2527, 2529,
	3, 2, 2, 2, 2528, 2526, 3, 2, 2, 2, 2529, 2559, 5, 312, 157, 2, 2530, 2532,
	5, 570, 286, 2, 2531, 2530, 3, 2, 2, 2, 2532, 2535, 3, 2, 2, 2, 2533, 2531,
	3, 2, 2, 2, 2533, 2534, 3, 2, 2, 2, 2534, 2536, 3, 2, 2, 2, 2535, 2533,
	3, 2, 2, 2, 2536, 2559, 5, 290, 146, 2, 2537, 2539, 5, 570, 286, 2, 2538,
	2537, 3, 2, 2, 2, 2539, 2542, 3, 2, 2, 2, 2540, 2538, 3, 2, 2, 2, 2540,
	2541, 3, 2, 2, 2, 2541, 2543, 3, 2, 2, 2, 2542, 2540, 3, 2, 2, 2, 2543,
	2559, 5, 336, 169, 2, 2544, 2546, 5, 570, 286, 2, 2545, 2544, 3, 2, 2,
	2, 2546, 2549, 3, 2, 2, 2, 2547, 2545, 3, 2, 2, 2, 2547, 2548, 3, 2, 2,
	2, 2548, 2550, 3, 2, 2, 2, 2549, 2547, 3, 2, 2, 2, 2550, 2559, 5, 338,
	170, 2, 2551, 2553, 5, 570, 286, 2, 2552, 2551, 3, 2, 2, 2, 2553, 2556,
	3, 2, 2, 2, 2554, 2552, 3, 2, 2, 2, 2554, 2555, 3, 2, 2, 2, 2555, 2557,
	3, 2, 2, 2, 2556, 2554, 3, 2, 2, 2, 2557, 2559, 5, 314, 158, 2, 2558, 2457,
	3, 2, 2, 2, 2558, 2466, 3, 2, 2, 2, 2558, 2473, 3, 2, 2, 2, 2558, 2480,
	3, 2, 2, 2, 2558, 2487, 3, 2, 2, 2, 2558, 2494, 3, 2, 2, 2, 2558, 2501,
	3, 2, 2, 2, 2558, 2510, 3, 2, 2, 2, 2558, 2517, 3, 2, 2, 2, 2558, 2526,
	3, 2, 2, 2, 2558, 2533, 3, 2, 2, 2, 2558, 2540, 3, 2, 2, 2, 2558, 2547,
	3, 2, 2, 2, 2558, 2554, 3, 2, 2, 2, 2559, 293, 3, 2, 2, 2, 2560, 2569,
	5, 292, 147, 2, 2561, 2563, 5, 570, 286, 2, 2562, 2561, 3, 2, 2, 2, 2563,
	2566, 3, 2, 2, 2, 2564, 2562, 3, 2, 2, 2, 2564, 2565, 3, 2, 2, 2, 2565,
	2567, 3, 2, 2, 2, 2566, 2564, 3, 2, 2, 2, 2567, 2569, 7, 247, 2, 2, 2568,
	2560, 3, 2, 2, 2, 2568, 2564, 3, 2, 2, 2, 2569, 295, 3, 2, 2, 2, 2570,
	2572, 5, 570, 286, 2, 2571, 2570, 3, 2, 2, 2, 2572, 2575, 3, 2, 2, 2, 2573,
	2571, 3, 2, 2, 2, 2573, 2574, 3, 2, 2, 2, 2574, 2576, 3, 2, 2, 2, 2575,
	2573, 3, 2, 2, 2, 2576, 2577, 5, 280, 141, 2, 2577, 2578, 7, 247, 2, 2,
	2578, 2622, 3, 2, 2, 2, 2579, 2581, 5, 570, 286, 2, 2580, 2579, 3, 2, 2,
	2, 2581, 2584, 3, 2, 2, 2, 2582, 2580, 3, 2, 2, 2, 2582, 2583, 3, 2, 2,
	2, 2583, 2585, 3, 2, 2, 2, 2584, 2582, 3, 2, 2, 2, 2585, 2622, 5, 328,
	165, 2, 2586, 2588, 5, 570, 286, 2, 2587, 2586, 3, 2, 2, 2, 2588, 2591,
	3, 2, 2, 2, 2589, 2587, 3, 2, 2, 2, 2589, 2590, 3, 2, 2, 2, 2590, 2592,
	3, 2, 2, 2, 2591, 2589, 3, 2, 2, 2, 2592, 2622, 5, 320, 161, 2, 2593, 2595,
	5, 570, 286, 2, 2594, 2593, 3, 2, 2, 2, 2595, 2598, 3, 2, 2, 2, 2596, 2594,
	3, 2, 2, 2, 2596, 2597, 3, 2, 2, 2, 2597, 2599, 3, 2, 2, 2, 2598, 2596,
	3, 2, 2, 2, 2599, 2622, 5, 332, 167, 2, 2600, 2602, 5, 570, 286, 2, 2601,
	2600, 3, 2, 2, 2, 2602, 2605, 3, 2, 2, 2, 2603, 2601, 3, 2, 2, 2, 2603,
	2604, 3, 2, 2, 2, 2604, 2606, 3, 2, 2, 2, 2605, 2603, 3, 2, 2, 2, 2606,
	2622, 5, 284, 143, 2, 2607, 2609, 5, 570, 286, 2, 2608, 2607, 3, 2, 2,
	2, 2609, 2612, 3, 2, 2, 2, 2610, 2608, 3, 2, 2, 2, 2610, 2611, 3, 2, 2,
	2, 2611, 2613, 3, 2, 2, 2, 2612, 2610, 3, 2, 2, 2, 2613, 2622, 5, 302,
	152, 2, 2614, 2616, 5, 570, 286, 2, 2615, 2614, 3, 2, 2, 2, 2616, 2619,
	3, 2, 2, 2, 2617, 2615, 3, 2, 2, 2, 2617, 2618, 3, 2, 2, 2, 2618, 2620,
	3, 2, 2, 2, 2619, 2617, 3, 2, 2, 2, 2620, 2622, 5, 336, 169, 2, 2621, 2573,
	3, 2, 2, 2, 2621, 2582, 3, 2, 2, 2, 2621, 2589, 3, 2, 2, 2, 2621, 2596,
	3, 2, 2, 2, 2621, 2603, 3, 2, 2, 2, 2621, 2610, 3, 2, 2, 2, 2621, 2617,
	3, 2, 2, 2, 2622, 297, 3, 2, 2, 2, 2623, 2632, 5, 300, 151, 2, 2624, 2632,
	5, 304, 153, 2, 2625, 2626, 7, 92, 2, 2, 2626, 2627, 7, 256, 2, 2, 2627,
	2628, 5, 530, 266, 2, 2628, 2629, 7, 257, 2, 2, 2629, 2630, 5, 304, 153,
	2, 2630, 2632, 3, 2, 2, 2, 2631, 2623, 3, 2, 2, 2, 2631, 2624, 3, 2, 2,
	2, 2631, 2625, 3, 2, 2, 2, 2632, 299, 3, 2, 2, 2, 2633, 2634, 7, 264, 2,
	2, 2634, 2641, 5, 104, 53, 2, 2635, 2636, 7, 264, 2, 2, 2636, 2637, 7,
	256, 2, 2, 2637, 2638, 5, 536, 269, 2, 2638, 2639, 7, 257, 2, 2, 2639,
	2641, 3, 2, 2, 2, 2640, 2633, 3, 2, 2, 2, 2640, 2635, 3, 2, 2, 2, 2641,
	301, 3, 2, 2, 2, 2642, 2643, 7, 30, 2, 2, 2643, 2644, 5, 612, 307, 2, 2644,
	2645, 7, 247, 2, 2, 2645, 2651, 3, 2, 2, 2, 2646, 2647, 7, 30, 2, 2, 2647,
	2648, 5, 600, 301, 2, 2648, 2649, 7, 247, 2, 2, 2649, 2651, 3, 2, 2, 2,
	2650, 2642, 3, 2, 2, 2, 2650, 2646, 3, 2, 2, 2, 2651, 303, 3, 2, 2, 2,
	2652, 2653, 7, 274, 2, 2, 2653, 2666, 5, 588, 295, 2, 2654, 2655, 7, 274,
	2, 2, 2655, 2656, 7, 256, 2, 2, 2656, 2657, 5, 308, 155, 2, 2657, 2658,
	7, 257, 2, 2, 2658, 2666, 3, 2, 2, 2, 2659, 2660, 7, 274, 2, 2, 2660, 2666,
	7, 275, 2, 2, 2661, 2662, 7, 274, 2, 2, 2662, 2663, 7, 256, 2, 2, 2663,
	2664, 7, 275, 2, 2, 2664, 2666, 7, 257, 2, 2, 2665, 2652, 3, 2, 2, 2, 2665,
	2654, 3, 2, 2, 2, 2665, 2659, 3, 2, 2, 2, 2665, 2661, 3, 2, 2, 2, 2666,
	305, 3, 2, 2, 2, 2667, 2668, 7, 277, 2, 2, 2668, 2669, 5, 602, 302, 2,
	2669, 2670, 7, 247, 2, 2, 2670, 307, 3, 2, 2, 2, 2671, 2678, 5, 310, 156,
	2, 2672, 2673, 7, 75, 2, 2, 2673, 2677, 5, 310, 156, 2, 2674, 2675, 7,
	253, 2, 2, 2675, 2677, 5, 310, 156, 2, 2676, 2672, 3, 2, 2, 2, 2676, 2674,
	3, 2, 2, 2, 2677, 2680, 3, 2, 2, 2, 2678, 2676, 3, 2, 2, 2, 2678, 2679,
	3, 2, 2, 2, 2679, 309, 3, 2, 2, 2, 2680, 2678, 3, 2, 2, 2, 2681, 2687,
	5, 530, 266, 2, 2682, 2683, 7, 79, 2, 2, 2683, 2687, 5, 530, 266, 2, 2684,
	2685, 7, 68, 2, 2, 2685, 2687, 5, 530, 266, 2, 2686, 2681, 3, 2, 2, 2,
	2686, 2682, 3, 2, 2, 2, 2686, 2684, 3, 2, 2, 2, 2687, 311, 3, 2, 2, 2,
	2688, 2689, 5, 298, 150, 2, 2689, 2690, 5, 294, 148, 2, 2690, 313, 3, 2,
	2, 2, 2691, 2692, 7, 123, 2, 2, 2692, 2693, 7, 256, 2, 2, 2693, 2694, 5,
	530, 266, 2, 2694, 2695, 7, 257, 2, 2, 2695, 2696, 5, 294, 148, 2, 2696,
	315, 3, 2, 2, 2, 2697, 2698, 7, 52, 2, 2, 2698, 2699, 7, 256, 2, 2, 2699,
	2700, 5, 530, 266, 2, 2700, 2701, 7, 257, 2, 2, 2701, 2704, 5, 294, 148,
	2, 2702, 2703, 7, 32, 2, 2, 2703, 2705, 5, 294, 148, 2, 2704, 2702, 3,
	2, 2, 2, 2704, 2705, 3, 2, 2, 2, 2705, 2708, 3, 2, 2, 2, 2706, 2708, 5,
	318, 160, 2, 2707, 2697, 3, 2, 2, 2, 2707, 2706, 3, 2, 2, 2, 2708, 317,
	3, 2, 2, 2, 2709, 2710, 7, 52, 2, 2, 2710, 2711, 7, 256, 2, 2, 2711, 2712,
	5, 530, 266, 2, 2712, 2713, 7, 257, 2, 2, 2713, 2723, 5, 294, 148, 2, 2714,
	2715, 7, 32, 2, 2, 2715, 2716, 7, 52, 2, 2, 2716, 2717, 7, 256, 2, 2, 2717,
	2718, 5, 530, 266, 2, 2718, 2719, 7, 257, 2, 2, 2719, 2720, 5, 294, 148,
	2, 2720, 2722, 3, 2, 2, 2, 2721, 2714, 3, 2, 2, 2, 2722, 2725, 3, 2, 2,
	2, 2723, 2721, 3, 2, 2, 2, 2723, 2724, 3, 2, 2, 2, 2724, 2728, 3, 2, 2,
	2, 2725, 2723, 3, 2, 2, 2, 2726, 2727, 7, 32, 2, 2, 2727, 2729, 5, 294,
	148, 2, 2728, 2726, 3, 2, 2, 2, 2728, 2729, 3, 2, 2, 2, 2729, 319, 3, 2,
	2, 2, 2730, 2731, 7, 52, 2, 2, 2731, 2732, 7, 256, 2, 2, 2732, 2733, 5,
	530, 266, 2, 2733, 2734, 7, 257, 2, 2, 2734, 2737, 5, 282, 142, 2, 2735,
	2736, 7, 32, 2, 2, 2736, 2738, 5, 282, 142, 2, 2737, 2735, 3, 2, 2, 2,
	2737, 2738, 3, 2, 2, 2, 2738, 2741, 3, 2, 2, 2, 2739, 2741, 5, 322, 162,
	2, 2740, 2730, 3, 2, 2, 2, 2740, 2739, 3, 2, 2, 2, 2741, 321, 3, 2, 2,
	2, 2742, 2743, 7, 52, 2, 2, 2743, 2744, 7, 256, 2, 2, 2744, 2745, 5, 530,
	266, 2, 2745, 2746, 7, 257, 2, 2, 2746, 2756, 5, 282, 142, 2, 2747, 2748,
	7, 32, 2, 2, 2748, 2749, 7, 52, 2, 2, 2749, 2750, 7, 256, 2, 2, 2750, 2751,
	5, 530, 266, 2, 2751, 2752, 7, 257, 2, 2, 2752, 2753, 5, 282, 142, 2, 2753,
	2755, 3, 2, 2, 2, 2754, 2747, 3, 2, 2, 2, 2755, 2758, 3, 2, 2, 2, 2756,
	2754, 3, 2, 2, 2, 2756, 2757, 3, 2, 2, 2, 2757, 2761, 3, 2, 2, 2, 2758,
	2756, 3, 2, 2, 2, 2759, 2760, 7, 32, 2, 2, 2760, 2762, 5, 282, 142, 2,
	2761, 2759, 3, 2, 2, 2, 2761, 2762, 3, 2, 2, 2, 2762, 323, 3, 2, 2, 2,
	2763, 2764, 7, 19, 2, 2, 2764, 2765, 7, 256, 2, 2, 2765, 2766, 5, 530,
	266, 2, 2766, 2767, 7, 257, 2, 2, 2767, 2771, 5, 326, 164, 2, 2768, 2770,
	5, 326, 164, 2, 2769, 2768, 3, 2, 2, 2, 2770, 2773, 3, 2, 2, 2, 2771, 2769,
	3, 2, 2, 2, 2771, 2772, 3, 2, 2, 2, 2772, 2774, 3, 2, 2, 2, 2773, 2771,
	3, 2, 2, 2, 2774, 2775, 7, 34, 2, 2, 2775, 2803, 3, 2, 2, 2, 2776, 2777,
	7, 21, 2, 2, 2777, 2778, 7, 256, 2, 2, 2778, 2779, 5, 530, 266, 2, 2779,
	2780, 7, 257, 2, 2, 2780, 2784, 5, 326, 164, 2, 2781, 2783, 5, 326, 164,
	2, 2782, 2781, 3, 2, 2, 2, 2783, 2786, 3, 2, 2, 2, 2784, 2782, 3, 2, 2,
	2, 2784, 2785, 3, 2, 2, 2, 2785, 2787, 3, 2, 2, 2, 2786, 2784, 3, 2, 2,
	2, 2787, 2788, 7, 34, 2, 2, 2788, 2803, 3, 2, 2, 2, 2789, 2790, 7, 20,
	2, 2, 2790, 2791, 7, 256, 2, 2, 2791, 2792, 5, 530, 266, 2, 2792, 2793,
	7, 257, 2, 2, 2793, 2797, 5, 326, 164, 2, 2794, 2796, 5, 326, 164, 2, 2795,
	2794, 3, 2, 2, 2, 2796, 2799, 3, 2, 2, 2, 2797, 2795, 3, 2, 2, 2, 2797,
	2798, 3, 2, 2, 2, 2798, 2800, 3, 2, 2, 2, 2799, 2797, 3, 2, 2, 2, 2800,
	2801, 7, 34, 2, 2, 2801, 2803, 3, 2, 2, 2, 2802, 2763, 3, 2, 2, 2, 2802,
	2776, 3, 2, 2, 2, 2802, 2789, 3, 2, 2, 2, 2803, 325, 3, 2, 2, 2, 2804,
	2809, 5, 530, 266, 2, 2805, 2806, 7, 253, 2, 2, 2806, 2808, 5, 530, 266,
	2, 2807, 2805, 3, 2, 2, 2, 2808, 2811, 3, 2, 2, 2, 2809, 2807, 3, 2, 2,
	2, 2809, 2810, 3, 2, 2, 2, 2810, 2812, 3, 2, 2, 2, 2811, 2809, 3, 2, 2,
	2, 2812, 2813, 7, 248, 2, 2, 2813, 2814, 5, 294, 148, 2, 2814, 2821, 3,
	2, 2, 2, 2815, 2817, 7, 26, 2, 2, 2816, 2818, 7, 248, 2, 2, 2817, 2816,
	3, 2, 2, 2, 2817, 2818, 3, 2, 2, 2, 2818, 2819, 3, 2, 2, 2, 2819, 2821,
	5, 294, 148, 2, 2820, 2804, 3, 2, 2, 2, 2820, 2815, 3, 2, 2, 2, 2821, 327,
	3, 2, 2, 2, 2822, 2823, 7, 19, 2, 2, 2823, 2824, 7, 256, 2, 2, 2824, 2825,
	5, 530, 266, 2, 2825, 2826, 7, 257, 2, 2, 2826, 2830, 5, 330, 166, 2, 2827,
	2829, 5, 330, 166, 2, 2828, 2827, 3, 2, 2, 2, 2829, 2832, 3, 2, 2, 2, 2830,
	2828, 3, 2, 2, 2, 2830, 2831, 3, 2, 2, 2, 2831, 2833, 3, 2, 2, 2, 2832,
	2830, 3, 2, 2, 2, 2833, 2834, 7, 34, 2, 2, 2834, 2862, 3, 2, 2, 2, 2835,
	2836, 7, 21, 2, 2, 2836, 2837, 7, 256, 2, 2, 2837, 2838, 5, 530, 266, 2,
	2838, 2839, 7, 257, 2, 2, 2839, 2843, 5, 330, 166, 2, 2840, 2842, 5, 330,
	166, 2, 2841, 2840, 3, 2, 2, 2, 2842, 2845, 3, 2, 2, 2, 2843, 2841, 3,
	2, 2, 2, 2843, 2844, 3, 2, 2, 2, 2844, 2846, 3, 2, 2, 2, 2845, 2843, 3,
	2, 2, 2, 2846, 2847, 7, 34, 2, 2, 2847, 2862, 3, 2, 2, 2, 2848, 2849, 7,
	20, 2, 2, 2849, 2850, 7, 256, 2, 2, 2850, 2851, 5, 530, 266, 2, 2851, 2852,
	7, 257, 2, 2, 2852, 2856, 5, 330, 166, 2, 2853, 2855, 5, 330, 166, 2, 2854,
	2853, 3, 2, 2, 2, 2855, 2858, 3, 2, 2, 2, 2856, 2854, 3, 2, 2, 2, 2856,
	2857, 3, 2, 2, 2, 2857, 2859, 3, 2, 2, 2, 2858, 2856, 3, 2, 2, 2, 2859,
	2860, 7, 34, 2, 2, 2860, 2862, 3, 2, 2, 2, 2861, 2822, 3, 2, 2, 2, 2861,
	2835, 3, 2, 2, 2, 2861, 2848, 3, 2, 2, 2, 2862, 329, 3, 2, 2, 2, 2863,
	2868, 5, 530, 266, 2, 2864, 2865, 7, 253, 2, 2, 2865, 2867, 5, 530, 266,
	2, 2866, 2864, 3, 2, 2, 2, 2867, 2870, 3, 2, 2, 2, 2868, 2866, 3, 2, 2,
	2, 2868, 2869, 3, 2, 2, 2, 2869, 2871, 3, 2, 2, 2, 2870, 2868, 3, 2, 2,
	2, 2871, 2872, 7, 248, 2, 2, 2872, 2873, 5, 282, 142, 2, 2873, 2880, 3,
	2, 2, 2, 2874, 2876, 7, 26, 2, 2, 2875, 2877, 7, 248, 2, 2, 2876, 2875,
	3, 2, 2, 2, 2876, 2877, 3, 2, 2, 2, 2877, 2878, 3, 2, 2, 2, 2878, 2880,
	5, 282, 142, 2, 2879, 2863, 3, 2, 2, 2, 2879, 2874, 3, 2, 2, 2, 2880, 331,
	3, 2, 2, 2, 2881, 2882, 7, 45, 2, 2, 2882, 2906, 5, 296, 149, 2, 2883,
	2884, 7, 92, 2, 2, 2884, 2885, 7, 256, 2, 2, 2885, 2886, 5, 530, 266, 2,
	2886, 2887, 7, 257, 2, 2, 2887, 2888, 5, 296, 149, 2, 2888, 2906, 3, 2,
	2, 2, 2889, 2890, 7, 127, 2, 2, 2890, 2891, 7, 256, 2, 2, 2891, 2892, 5,
	530, 266, 2, 2892, 2893, 7, 257, 2, 2, 2893, 2894, 5, 296, 149, 2, 2894,
	2906, 3, 2, 2, 2, 2895, 2896, 7, 43, 2, 2, 2896, 2897, 7, 256, 2, 2, 2897,
	2898, 5, 286, 144, 2, 2898, 2899, 7, 247, 2, 2, 2899, 2900, 5, 530, 266,
	2, 2900, 2901, 7, 247, 2, 2, 2901, 2902, 5, 286, 144, 2, 2902, 2903, 7,
	257, 2, 2, 2903, 2904, 5, 296, 149, 2, 2904, 2906, 3, 2, 2, 2, 2905, 2881,
	3, 2, 2, 2, 2905, 2883, 3, 2, 2, 2, 2905, 2889, 3, 2, 2, 2, 2905, 2895,
	3, 2, 2, 2, 2906, 333, 3, 2, 2, 2, 2907, 2908, 7, 45, 2, 2, 2908, 2932,
	5, 292, 147, 2, 2909, 2910, 7, 92, 2, 2, 2910, 2911, 7, 256, 2, 2, 2911,
	2912, 5, 530, 266, 2, 2912, 2913, 7, 257, 2, 2, 2913, 2914, 5, 292, 147,
	2, 2914, 2932, 3, 2, 2, 2, 2915, 2916, 7, 127, 2, 2, 2916, 2917, 7, 256,
	2, 2, 2917, 2918, 5, 530, 266, 2, 2918, 2919, 7, 257, 2, 2, 2919, 2920,
	5, 292, 147, 2, 2920, 2932, 3, 2, 2, 2, 2921, 2922, 7, 43, 2, 2, 2922,
	2923, 7, 256, 2, 2, 2923, 2924, 5, 286, 144, 2, 2924, 2925, 7, 247, 2,
	2, 2925, 2926, 5, 530, 266, 2, 2926, 2927, 7, 247, 2, 2, 2927, 2928, 5,
	286, 144, 2, 2928, 2929, 7, 257, 2, 2, 2929, 2930, 5, 292, 147, 2, 2930,
	2932, 3, 2, 2, 2, 2931, 2907, 3, 2, 2, 2, 2931, 2909, 3, 2, 2, 2, 2931,
	2915, 3, 2, 2, 2, 2931, 2921, 3, 2, 2, 2, 2932, 335, 3, 2, 2, 2, 2933,
	2946, 5, 648, 325, 2, 2934, 2943, 7, 256, 2, 2, 2935, 2940, 5, 530, 266,
	2, 2936, 2937, 7, 253, 2, 2, 2937, 2939, 5, 530, 266, 2, 2938, 2936, 3,
	2, 2, 2, 2939, 2942, 3, 2, 2, 2, 2940, 2938, 3, 2, 2, 2, 2940, 2941, 3,
	2, 2, 2, 2941, 2944, 3, 2, 2, 2, 2942, 2940, 3, 2, 2, 2, 2943, 2935, 3,
	2, 2, 2, 2943, 2944, 3, 2, 2, 2, 2944, 2945, 3, 2, 2, 2, 2945, 2947, 7,
	257, 2, 2, 2946, 2934, 3, 2, 2, 2, 2946, 2947, 3, 2, 2, 2, 2947, 2948,
	3, 2, 2, 2, 2948, 2949, 7, 247, 2, 2, 2949, 337, 3, 2, 2, 2, 2950, 2963,
	5, 612, 307, 2, 2951, 2960, 7, 256, 2, 2, 2952, 2957, 5, 530, 266, 2, 2953,
	2954, 7, 253, 2, 2, 2954, 2956, 5, 530, 266, 2, 2955, 2953, 3, 2, 2, 2,
	2956, 2959, 3, 2, 2, 2, 2957, 2955, 3, 2, 2, 2, 2957, 2958, 3, 2, 2, 2,
	2958, 2961, 3, 2, 2, 2, 2959, 2957, 3, 2, 2, 2, 2960, 2952, 3, 2, 2, 2,
	2960, 2961, 3, 2, 2, 2, 2961, 2962, 3, 2, 2, 2, 2962, 2964, 7, 257, 2,
	2, 2963, 2951, 3, 2, 2, 2, 2963, 2964, 3, 2, 2, 2, 2964, 2965, 3, 2, 2,
	2, 2965, 2966, 7, 247, 2, 2, 2966, 339, 3, 2, 2, 2, 2967, 2971, 7, 102,
	2, 2, 2968, 2970, 5, 342, 172, 2, 2969, 2968, 3, 2, 2, 2, 2970, 2973, 3,
	2, 2, 2, 2971, 2969, 3, 2, 2, 2, 2971, 2972, 3, 2, 2, 2, 2972, 2974, 3,
	2, 2, 2, 2973, 2971, 3, 2, 2, 2, 2974, 2975, 7, 39, 2, 2, 2975, 341, 3,
	2, 2, 2, 2976, 2982, 5, 60, 31, 2, 2977, 2982, 5, 344, 173, 2, 2978, 2982,
	5, 346, 174, 2, 2979, 2982, 5, 348, 175, 2, 2980, 2982, 5, 420, 211, 2,
	2981, 2976, 3, 2, 2, 2, 2981, 2977, 3, 2, 2, 2, 2981, 2978, 3, 2, 2, 2,
	2981, 2979, 3, 2, 2, 2, 2981, 2980, 3, 2, 2, 2, 2982, 343, 3, 2, 2, 2,
	2983, 2984, 7, 86, 2, 2, 2984, 2985, 5, 358, 180, 2, 2985, 2986, 7, 247,
	2, 2, 2986, 2992, 3, 2, 2, 2, 2987, 2988, 7, 85, 2, 2, 2988, 2989, 5, 358,
	180, 2, 2989, 2990, 7, 247, 2, 2, 2990, 2992, 3, 2, 2, 2, 2991, 2983, 3,
	2, 2, 2, 2991, 2987, 3, 2, 2, 2, 2992, 345, 3, 2, 2, 2, 2993, 2994, 7,
	99, 2, 2, 2994, 2995, 5, 358, 180, 2, 2995, 2996, 7, 247, 2, 2, 2996, 3002,
	3, 2, 2, 2, 2997, 2998, 7, 71, 2, 2, 2998, 2999, 5, 358, 180, 2, 2999,
	3000, 7, 247, 2, 2, 3000, 3002, 3, 2, 2, 2, 3001, 2993, 3, 2, 2, 2, 3001,
	2997, 3, 2, 2, 2, 3002, 347, 3, 2, 2, 2, 3003, 3004, 5, 350, 176, 2, 3004,
	3005, 7, 247, 2, 2, 3005, 3013, 3, 2, 2, 2, 3006, 3007, 5, 406, 204, 2,
	3007, 3008, 7, 247, 2, 2, 3008, 3013, 3, 2, 2, 2, 3009, 3010, 5, 416, 209,
	2, 3010, 3011, 7, 247, 2, 2, 3011, 3013, 3, 2, 2, 2, 3012, 3003, 3, 2,
	2, 2, 3012, 3006, 3, 2, 2, 2, 3012, 3009, 3, 2, 2, 2, 3013, 349, 3, 2,
	2, 2, 3014, 3015, 5, 352, 177, 2, 3015, 3016, 7, 267, 2, 2, 3016, 3017,
	5, 368, 185, 2, 3017, 3023, 3, 2, 2, 2, 3018, 3019, 5, 354, 178, 2, 3019,
	3020, 7, 267, 2, 2, 3020, 3021, 5, 368, 185, 2, 3021, 3023, 3, 2, 2, 2,
	3022, 3014, 3, 2, 2, 2, 3022, 3018, 3, 2, 2, 2, 3023, 351, 3, 2, 2, 2,
	3024, 3026, 5, 360, 181, 2, 3025, 3027, 5, 418, 210, 2, 3026, 3025, 3,
	2, 2, 2, 3026, 3027, 3, 2, 2, 2, 3027, 3028, 3, 2, 2, 2, 3028, 3029, 7,
	273, 2, 2, 3029, 3030, 5, 362, 182, 2, 3030, 353, 3, 2, 2, 2, 3031, 3032,
	7, 256, 2, 2, 3032, 3034, 5, 356, 179, 2, 3033, 3035, 5, 418, 210, 2, 3034,
	3033, 3, 2, 2, 2, 3034, 3035, 3, 2, 2, 2, 3035, 3036, 3, 2, 2, 2, 3036,
	3037, 7, 275, 2, 2, 3037, 3038, 7, 263, 2, 2, 3038, 3039, 5, 358, 180,
	2, 3039, 3040, 7, 257, 2, 2, 3040, 355, 3, 2, 2, 2, 3041, 3046, 5, 360,
	181, 2, 3042, 3043, 7, 253, 2, 2, 3043, 3045, 5, 360, 181, 2, 3044, 3042,
	3, 2, 2, 2, 3045, 3048, 3, 2, 2, 2, 3046, 3044, 3, 2, 2, 2, 3046, 3047,
	3, 2, 2, 2, 3047, 357, 3, 2, 2, 2, 3048, 3046, 3, 2, 2, 2, 3049, 3054,
	5, 362, 182, 2, 3050, 3051, 7, 253, 2, 2, 3051, 3053, 5, 362, 182, 2, 3052,
	3050, 3, 2, 2, 2, 3053, 3056, 3, 2, 2, 2, 3054, 3052, 3, 2, 2, 2, 3054,
	3055, 3, 2, 2, 2, 3055, 359, 3, 2, 2, 2, 3056, 3054, 3, 2, 2, 2, 3057,
	3069, 5, 364, 183, 2, 3058, 3059, 5, 364, 183, 2, 3059, 3060, 7, 258, 2,
	2, 3060, 3061, 5, 522, 262, 2, 3061, 3062, 7, 259, 2, 2, 3062, 3069, 3,
	2, 2, 2, 3063, 3064, 5, 364, 183, 2, 3064, 3065, 7, 258, 2, 2, 3065, 3066,
	5, 546, 274, 2, 3066, 3067, 7, 259, 2, 2, 3067, 3069, 3, 2, 2, 2, 3068,
	3057, 3, 2, 2, 2, 3068, 3058, 3, 2, 2, 2, 3068, 3063, 3, 2, 2, 2, 3069,
	361, 3, 2, 2, 2, 3070, 3082, 5, 366, 184, 2, 3071, 3072, 5, 366, 184, 2,
	3072, 3073, 7, 258, 2, 2, 3073, 3074, 5, 522, 262, 2, 3074, 3075, 7, 259,
	2, 2, 3075, 3082, 3, 2, 2, 2, 3076, 3077, 5, 366, 184, 2, 3077, 3078, 7,
	258, 2, 2, 3078, 3079, 5, 546, 274, 2, 3079, 3080, 7, 259, 2, 2, 3080,
	3082, 3, 2, 2, 2, 3081, 3070, 3, 2, 2, 2, 3081, 3071, 3, 2, 2, 2, 3081,
	3076, 3, 2, 2, 2, 3082, 363, 3, 2, 2, 2, 3083, 3086, 5, 618, 310, 2, 3084,
	3086, 5, 616, 309, 2, 3085, 3083, 3, 2, 2, 2, 3085, 3084, 3, 2, 2, 2, 3086,
	365, 3, 2, 2, 2, 3087, 3090, 5, 632, 317, 2, 3088, 3090, 5, 616, 309, 2,
	3089, 3087, 3, 2, 2, 2, 3089, 3088, 3, 2, 2, 2, 3090, 367, 3, 2, 2, 2,
	3091, 3097, 5, 370, 186, 2, 3092, 3093, 7, 256, 2, 2, 3093, 3094, 5, 370,
	186, 2, 3094, 3095, 7, 257, 2, 2, 3095, 3097, 3, 2, 2, 2, 3096, 3091, 3,
	2, 2, 2, 3096, 3092, 3, 2, 2, 2, 3097, 369, 3, 2, 2, 2, 3098, 3146, 5,
	372, 187, 2, 3099, 3100, 5, 374, 188, 2, 3100, 3101, 7, 253, 2, 2, 3101,
	3102, 5, 376, 189, 2, 3102, 3146, 3, 2, 2, 2, 3103, 3104, 5, 374, 188,
	2, 3104, 3105, 7, 253, 2, 2, 3105, 3106, 5, 376, 189, 2, 3106, 3107, 7,
	253, 2, 2, 3107, 3108, 5, 378, 190, 2, 3108, 3146, 3, 2, 2, 2, 3109, 3110,
	5, 380, 191, 2, 3110, 3111, 7, 253, 2, 2, 3111, 3112, 5, 382, 192, 2, 3112,
	3113, 7, 253, 2, 2, 3113, 3114, 5, 384, 193, 2, 3114, 3115, 7, 253, 2,
	2, 3115, 3116, 5, 386, 194, 2, 3116, 3117, 7, 253, 2, 2, 3117, 3118, 5,
	388, 195, 2, 3118, 3119, 7, 253, 2, 2, 3119, 3120, 5, 390, 196, 2, 3120,
	3146, 3, 2, 2, 2, 3121, 3122, 5, 380, 191, 2, 3122, 3123, 7, 253, 2, 2,
	3123, 3124, 5, 382, 192, 2, 3124, 3125, 7, 253, 2, 2, 3125, 3126, 5, 384,
	193, 2, 3126, 3127, 7, 253, 2, 2, 3127, 3128, 5, 386, 194, 2, 3128, 3129,
	7, 253, 2, 2, 3129, 3130, 5, 388, 195, 2, 3130, 3131, 7, 253, 2, 2, 3131,
	3132, 5, 390, 196, 2, 3132, 3133, 7, 253, 2, 2, 3133, 3134, 5, 392, 197,
	2, 3134, 3135, 7, 253, 2, 2, 3135, 3136, 5, 394, 198, 2, 3136, 3137, 7,
	253, 2, 2, 3137, 3138, 5, 396, 199, 2, 3138, 3139, 7, 253, 2, 2, 3139,
	3140, 5, 398, 200, 2, 3140, 3141, 7, 253, 2, 2, 3141, 3142, 5, 400, 201,
	2, 3142, 3143, 7, 253, 2, 2, 3143, 3144, 5, 402, 202, 2, 3144, 3146, 3,
	2, 2, 2, 3145, 3098, 3, 2, 2, 2, 3145, 3099, 3, 2, 2, 2, 3145, 3103, 3,
	2, 2, 2, 3145, 3109, 3, 2, 2, 2, 3145, 3121, 3, 2, 2, 2, 3146, 371, 3,
	2, 2, 2, 3147, 3148, 5, 404, 203, 2, 3148, 373, 3, 2, 2, 2, 3149, 3150,
	5, 404, 203, 2, 3150, 375, 3, 2, 2, 2, 3151, 3152, 5, 404, 203, 2, 3152,
	377, 3, 2, 2, 2, 3153, 3154, 5, 404, 203, 2, 3154, 379, 3, 2, 2, 2, 3155,
	3156, 5, 404, 203, 2, 3156, 381, 3, 2, 2, 2, 3157, 3158, 5, 404, 203, 2,
	3158, 383, 3, 2, 2, 2, 3159, 3160, 5, 404, 203, 2, 3160, 385, 3, 2, 2,
	2, 3161, 3162, 5, 404, 203, 2, 3162, 387, 3, 2, 2, 2, 3163, 3164, 5, 404,
	203, 2, 3164, 389, 3, 2, 2, 2, 3165, 3166, 5, 404, 203, 2, 3166, 391, 3,
	2, 2, 2, 3167, 3168, 5, 404, 203, 2, 3168, 393, 3, 2, 2, 2, 3169, 3170,
	5, 404, 203, 2, 3170, 395, 3, 2, 2, 2, 3171, 3172, 5, 404, 203, 2, 3172,
	397, 3, 2, 2, 2, 3173, 3174, 5, 404, 203, 2, 3174, 399, 3, 2, 2, 2, 3175,
	3176, 5, 404, 203, 2, 3176, 401, 3, 2, 2, 2, 3177, 3178, 5, 404, 203, 2,
	3178, 403, 3, 2, 2, 2, 3179, 3180, 5, 524, 263, 2, 3180, 405, 3, 2, 2,
	2, 3181, 3182, 5, 408, 205, 2, 3182, 3183, 7, 267, 2, 2, 3183, 3184, 5,
	368, 185, 2, 3184, 3190, 3, 2, 2, 2, 3185, 3186, 5, 410, 206, 2, 3186,
	3187, 7, 267, 2, 2, 3187, 3188, 5, 368, 185, 2, 3188, 3190, 3, 2, 2, 2,
	3189, 3181, 3, 2, 2, 2, 3189, 3185, 3, 2, 2, 2, 3190, 407, 3, 2, 2, 2,
	3191, 3193, 7, 256, 2, 2, 3192, 3194, 5, 414, 208, 2, 3193, 3192, 3, 2,
	2, 2, 3193, 3194, 3, 2, 2, 2, 3194, 3195, 3, 2, 2, 2, 3195, 3196, 5, 360,
	181, 2, 3196, 3197, 7, 273, 2, 2, 3197, 3199, 5, 362, 182, 2, 3198, 3200,
	5, 418, 210, 2, 3199, 3198, 3, 2, 2, 2, 3199, 3200, 3, 2, 2, 2, 3200, 3201,
	3, 2, 2, 2, 3201, 3202, 7, 248, 2, 2, 3202, 3203, 5, 412, 207, 2, 3203,
	3204, 7, 257, 2, 2, 3204, 409, 3, 2, 2, 2, 3205, 3207, 7, 256, 2, 2, 3206,
	3208, 5, 414, 208, 2, 3207, 3206, 3, 2, 2, 2, 3207, 3208, 3, 2, 2, 2, 3208,
	3209, 3, 2, 2, 2, 3209, 3210, 5, 356, 179, 2, 3210, 3211, 7, 279, 2, 2,
	3211, 3213, 5, 358, 180, 2, 3212, 3214, 5, 418, 210, 2, 3213, 3212, 3,
	2, 2, 2, 3213, 3214, 3, 2, 2, 2, 3214, 3215, 3, 2, 2, 2, 3215, 3216, 7,
	248, 2, 2, 3216, 3217, 5, 412, 207, 2, 3217, 3218, 7, 257, 2, 2, 3218,
	411, 3, 2, 2, 2, 3219, 3220, 5, 530, 266, 2, 3220, 413, 3, 2, 2, 2, 3221,
	3222, 9, 17, 2, 2, 3222, 415, 3, 2, 2, 2, 3223, 3224, 7, 52, 2, 2, 3224,
	3225, 7, 256, 2, 2, 3225, 3226, 5, 540, 271, 2, 3226, 3227, 7, 257, 2,
	2, 3227, 3228, 5, 350, 176, 2, 3228, 3238, 3, 2, 2, 2, 3229, 3230, 7, 52,
	2, 2, 3230, 3231, 7, 256, 2, 2, 3231, 3232, 5, 540, 271, 2, 3232, 3233,
	7, 257, 2, 2, 3233, 3234, 5, 406, 204, 2, 3234, 3238, 3, 2, 2, 2, 3235,
	3236, 7, 53, 2, 2, 3236, 3238, 5, 350, 176, 2, 3237, 3223, 3, 2, 2, 2,
	3237, 3229, 3, 2, 2, 2, 3237, 3235, 3, 2, 2, 2, 3238, 417, 3, 2, 2, 2,
	3239, 3240, 9, 18, 2, 2, 3240, 419, 3, 2, 2, 2, 3241, 3254, 5, 422, 212,
	2, 3242, 3254, 5, 424, 213, 2, 3243, 3254, 5, 426, 214, 2, 3244, 3254,
	5, 428, 215, 2, 3245, 3254, 5, 430, 216, 2, 3246, 3254, 5, 432, 217, 2,
	3247, 3254, 5, 434, 218, 2, 3248, 3254, 5, 436, 219, 2, 3249, 3254, 5,
	438, 220, 2, 3250, 3254, 5, 440, 221, 2, 3251, 3254, 5, 442, 222, 2, 3252,
	3254, 5, 444, 223, 2, 3253, 3241, 3, 2, 2, 2, 3253, 3242, 3, 2, 2, 2, 3253,
	3243, 3, 2, 2, 2, 3253, 3244, 3, 2, 2, 2, 3253, 3245, 3, 2, 2, 2, 3253,
	3246, 3, 2, 2, 2, 3253, 3247, 3, 2, 2, 2, 3253, 3248, 3, 2, 2, 2, 3253,
	3249, 3, 2, 2, 2, 3253, 3250, 3, 2, 2, 2, 3253, 3251, 3, 2, 2, 2, 3253,
	3252, 3, 2, 2, 2, 3254, 421, 3, 2, 2, 2, 3255, 3256, 7, 141, 2, 2, 3256,
	3257, 7, 256, 2, 2, 3257, 3258, 5, 450, 226, 2, 3258, 3259, 7, 253, 2,
	2, 3259, 3260, 5, 462, 232, 2, 3260, 3261, 7, 253, 2, 2, 3261, 3266, 5,
	472, 237, 2, 3262, 3264, 7, 253, 2, 2, 3263, 3265, 5, 460, 231, 2, 3264,
	3263, 3, 2, 2, 2, 3264, 3265, 3, 2, 2, 2, 3265, 3267, 3, 2, 2, 2, 3266,
	3262, 3, 2, 2, 2, 3266, 3267, 3, 2, 2, 2, 3267, 3268, 3, 2, 2, 2, 3268,
	3269, 7, 257, 2, 2, 3269, 3270, 7, 247, 2, 2, 3270, 423, 3, 2, 2, 2, 3271,
	3272, 7, 133, 2, 2, 3272, 3273, 7, 256, 2, 2, 3273, 3274, 5, 462, 232,
	2, 3274, 3275, 7, 253, 2, 2, 3275, 3276, 5, 450, 226, 2, 3276, 3277, 7,
	253, 2, 2, 3277, 3282, 5, 472, 237, 2, 3278, 3280, 7, 253, 2, 2, 3279,
	3281, 5, 460, 231, 2, 3280, 3279, 3, 2, 2, 2, 3280, 3281, 3, 2, 2, 2, 3281,
	3283, 3, 2, 2, 2, 3282, 3278, 3, 2, 2, 2, 3282, 3283, 3, 2, 2, 2, 3283,
	3284, 3, 2, 2, 2, 3284, 3285, 7, 257, 2, 2, 3285, 3286, 7, 247, 2, 2, 3286,
	425, 3, 2, 2, 2, 3287, 3288, 7, 140, 2, 2, 3288, 3289, 7, 256, 2, 2, 3289,
	3290, 5, 462, 232, 2, 3290, 3291, 7, 253, 2, 2, 3291, 3292, 5, 450, 226,
	2, 3292, 3293, 7, 253, 2, 2, 3293, 3294, 5, 472, 237, 2, 3294, 3295, 7,
	253, 2, 2, 3295, 3324, 5, 472, 237, 2, 3296, 3298, 7, 253, 2, 2, 3297,
	3299, 5, 460, 231, 2, 3298, 3297, 3, 2, 2, 2, 3298, 3299, 3, 2, 2, 2, 3299,
	3322, 3, 2, 2, 2, 3300, 3302, 7, 253, 2, 2, 3301, 3303, 5, 466, 234, 2,
	3302, 3301, 3, 2, 2, 2, 3302, 3303, 3, 2, 2, 2, 3303, 3320, 3, 2, 2, 2,
	3304, 3306, 7, 253, 2, 2, 3305, 3307, 5, 446, 224, 2, 3306, 3305, 3, 2,
	2, 2, 3306, 3307, 3, 2, 2, 2, 3307, 3318, 3, 2, 2, 2, 3308, 3310, 7, 253,
	2, 2, 3309, 3311, 5, 454, 228, 2, 3310, 3309, 3, 2, 2, 2, 3310, 3311, 3,
	2, 2, 2, 3311, 3316, 3, 2, 2, 2, 3312, 3314, 7, 253, 2, 2, 3313, 3315,
	5, 452, 227, 2, 3314, 3313, 3, 2, 2, 2, 3314, 3315, 3, 2, 2, 2, 3315, 3317,
	3, 2, 2, 2, 3316, 3312, 3, 2, 2, 2, 3316, 3317, 3, 2, 2, 2, 3317, 3319,
	3, 2, 2, 2, 3318, 3308, 3, 2, 2, 2, 3318, 3319, 3, 2, 2, 2, 3319, 3321,
	3, 2, 2, 2, 3320, 3304, 3, 2, 2, 2, 3320, 3321, 3, 2, 2, 2, 3321, 3323,
	3, 2, 2, 2, 3322, 3300, 3, 2, 2, 2, 3322, 3323, 3, 2, 2, 2, 3323, 3325,
	3, 2, 2, 2, 3324, 3296, 3, 2, 2, 2, 3324, 3325, 3, 2, 2, 2, 3325, 3326,
	3, 2, 2, 2, 3326, 3327, 7, 257, 2, 2, 3327, 3328, 7, 247, 2, 2, 3328, 427,
	3, 2, 2, 2, 3329, 3330, 7, 136, 2, 2, 3330, 3331, 7, 256, 2, 2, 3331, 3332,
	5, 462, 232, 2, 3332, 3333, 7, 253, 2, 2, 3333, 3334, 5, 450, 226, 2, 3334,
	3335, 7, 253, 2, 2, 3335, 3340, 5, 472, 237, 2, 3336, 3338, 7, 253, 2,
	2, 3337, 3339, 5, 460, 231, 2, 3338, 3337, 3, 2, 2, 2, 3338, 3339, 3, 2,
	2, 2, 3339, 3341, 3, 2, 2, 2, 3340, 3336, 3, 2, 2, 2, 3340, 3341, 3, 2,
	2, 2, 3341, 3342, 3, 2, 2, 2, 3342, 3343, 7, 257, 2, 2, 3343, 3344, 7,
	247, 2, 2, 3344, 429, 3, 2, 2, 2, 3345, 3346, 7, 138, 2, 2, 3346, 3347,
	7, 256, 2, 2, 3347, 3348, 5, 462, 232, 2, 3348, 3349, 7, 253, 2, 2, 3349,
	3350, 5, 450, 226, 2, 3350, 3351, 7, 253, 2, 2, 3351, 3356, 5, 472, 237,
	2, 3352, 3354, 7, 253, 2, 2, 3353, 3355, 5, 460, 231, 2, 3354, 3353, 3,
	2, 2, 2, 3354, 3355, 3, 2, 2, 2, 3355, 3357, 3, 2, 2, 2, 3356, 3352, 3,
	2, 2, 2, 3356, 3357, 3, 2, 2, 2, 3357, 3358, 3, 2, 2, 2, 3358, 3359, 7,
	257, 2, 2, 3359, 3360, 7, 247, 2, 2, 3360, 431, 3, 2, 2, 2, 3361, 3362,
	7, 137, 2, 2, 3362, 3363, 7, 256, 2, 2, 3363, 3364, 5, 462, 232, 2, 3364,
	3365, 7, 253, 2, 2, 3365, 3366, 5, 450, 226, 2, 3366, 3367, 7, 253, 2,
	2, 3367, 3368, 5, 472, 237, 2, 3368, 3369, 7, 253, 2, 2, 3369, 3398, 5,
	472, 237, 2, 3370, 3372, 7, 253, 2, 2, 3371, 3373, 5, 460, 231, 2, 3372,
	3371, 3, 2, 2, 2, 3372, 3373, 3, 2, 2, 2, 3373, 3396, 3, 2, 2, 2, 3374,
	3376, 7, 253, 2, 2, 3375, 3377, 5, 466, 234, 2, 3376, 3375, 3, 2, 2, 2,
	3376, 3377, 3, 2, 2, 2, 3377, 3394, 3, 2, 2, 2, 3378, 3380, 7, 253, 2,
	2, 3379, 3381, 5, 446, 224, 2, 3380, 3379, 3, 2, 2, 2, 3380, 3381, 3, 2,
	2, 2, 3381, 3392, 3, 2, 2, 2, 3382, 3384, 7, 253, 2, 2, 3383, 3385, 5,
	454, 228, 2, 3384, 3383, 3, 2, 2, 2, 3384, 3385, 3, 2, 2, 2, 3385, 3390,
	3, 2, 2, 2, 3386, 3388, 7, 253, 2, 2, 3387, 3389, 5, 452, 227, 2, 3388,
	3387, 3, 2, 2, 2, 3388, 3389, 3, 2, 2, 2, 3389, 3391, 3, 2, 2, 2, 3390,
	3386, 3, 2, 2, 2, 3390, 3391, 3, 2, 2, 2, 3391, 3393, 3, 2, 2, 2, 3392,
	3382, 3, 2, 2, 2, 3392, 3393, 3, 2, 2, 2, 3393, 3395, 3, 2, 2, 2, 3394,
	3378, 3, 2, 2, 2, 3394, 3395, 3, 2, 2, 2, 3395, 3397, 3, 2, 2, 2, 3396,
	3374, 3, 2, 2, 2, 3396, 3397, 3, 2, 2, 2, 3397, 3399, 3, 2, 2, 2, 3398,
	3370, 3, 2, 2, 2, 3398, 3399, 3, 2, 2, 2, 3399, 3400, 3, 2, 2, 2, 3400,
	3401, 7, 257, 2, 2, 3401, 3402, 7, 247, 2, 2, 3402, 433, 3, 2, 2, 2, 3403,
	3404, 7, 142, 2, 2, 3404, 3405, 7, 256, 2, 2, 3405, 3406, 5, 462, 232,
	2, 3406, 3407, 7, 253, 2, 2, 3407, 3408, 5, 450, 226, 2, 3408, 3409, 7,
	253, 2, 2, 3409, 3414, 5, 472, 237, 2, 3410, 3412, 7, 253, 2, 2, 3411,
	3413, 5, 460, 231, 2, 3412, 3411, 3, 2, 2, 2, 3412, 3413, 3, 2, 2, 2, 3413,
	3415, 3, 2, 2, 2, 3414, 3410, 3, 2, 2, 2, 3414, 3415, 3, 2, 2, 2, 3415,
	3416, 3, 2, 2, 2, 3416, 3417, 7, 257, 2, 2, 3417, 3418, 7, 247, 2, 2, 3418,
	435, 3, 2, 2, 2, 3419, 3420, 7, 143, 2, 2, 3420, 3421, 7, 256, 2, 2, 3421,
	3422, 5, 462, 232, 2, 3422, 3423, 7, 253, 2, 2, 3423, 3424, 5, 450, 226,
	2, 3424, 3425, 7, 253, 2, 2, 3425, 3442, 5, 472, 237, 2, 3426, 3428, 7,
	253, 2, 2, 3427, 3429, 5, 460, 231, 2, 3428, 3427, 3, 2, 2, 2, 3428, 3429,
	3, 2, 2, 2, 3429, 3440, 3, 2, 2, 2, 3430, 3432, 7, 253, 2, 2, 3431, 3433,
	5, 458, 230, 2, 3432, 3431, 3, 2, 2, 2, 3432, 3433, 3, 2, 2, 2, 3433, 3438,
	3, 2, 2, 2, 3434, 3436, 7, 253, 2, 2, 3435, 3437, 5, 464, 233, 2, 3436,
	3435, 3, 2, 2, 2, 3436, 3437, 3, 2, 2, 2, 3437, 3439, 3, 2, 2, 2, 3438,
	3434, 3, 2, 2, 2, 3438, 3439, 3, 2, 2, 2, 3439, 3441, 3, 2, 2, 2, 3440,
	3430, 3, 2, 2, 2, 3440, 3441, 3, 2, 2, 2, 3441, 3443, 3, 2, 2, 2, 3442,
	3426, 3, 2, 2, 2, 3442, 3443, 3, 2, 2, 2, 3443, 3444, 3, 2, 2, 2, 3444,
	3445, 7, 257, 2, 2, 3445, 3446, 7, 247, 2, 2, 3446, 437, 3, 2, 2, 2, 3447,
	3448, 7, 132, 2, 2, 3448, 3449, 7, 256, 2, 2, 3449, 3450, 5, 462, 232,
	2, 3450, 3451, 7, 253, 2, 2, 3451, 3452, 5, 450, 226, 2, 3452, 3453, 7,
	253, 2, 2, 3453, 3454, 5, 472, 237, 2, 3454, 3455, 7, 253, 2, 2, 3455,
	3472, 5, 472, 237, 2, 3456, 3458, 7, 253, 2, 2, 3457, 3459, 5, 460, 231,
	2, 3458, 3457, 3, 2, 2, 2, 3458, 3459, 3, 2, 2, 2, 3459, 3470, 3, 2, 2,
	2, 3460, 3462, 7, 253, 2, 2, 3461, 3463, 5, 458, 230, 2, 3462, 3461, 3,
	2, 2, 2, 3462, 3463, 3, 2, 2, 2, 3463, 3468, 3, 2, 2, 2, 3464, 3466, 7,
	253, 2, 2, 3465, 3467, 5, 464, 233, 2, 3466, 3465, 3, 2, 2, 2, 3466, 3467,
	3, 2, 2, 2, 3467, 3469, 3, 2, 2, 2, 3468, 3464, 3, 2, 2, 2, 3468, 3469,
	3, 2, 2, 2, 3469, 3471, 3, 2, 2, 2, 3470, 3460, 3, 2, 2, 2, 3470, 3471,
	3, 2, 2, 2, 3471, 3473, 3, 2, 2, 2, 3472, 3456, 3, 2, 2, 2, 3472, 3473,
	3, 2, 2, 2, 3473, 3474, 3, 2, 2, 2, 3474, 3475, 7, 257, 2, 2, 3475, 3476,
	7, 247, 2, 2, 3476, 439, 3, 2, 2, 2, 3477, 3478, 7, 135, 2, 2, 3478, 3479,
	7, 256, 2, 2, 3479, 3480, 5, 448, 225, 2, 3480, 3481, 7, 253, 2, 2, 3481,
	3486, 5, 472, 237, 2, 3482, 3484, 7, 253, 2, 2, 3483, 3485, 5, 460, 231,
	2, 3484, 3483, 3, 2, 2, 2, 3484, 3485, 3, 2, 2, 2, 3485, 3487, 3, 2, 2,
	2, 3486, 3482, 3, 2, 2, 2, 3486, 3487, 3, 2, 2, 2, 3487, 3488, 3, 2, 2,
	2, 3488, 3489, 7, 257, 2, 2, 3489, 3490, 7, 247, 2, 2, 3490, 441, 3, 2,
	2, 2, 3491, 3492, 7, 145, 2, 2, 3492, 3493, 7, 256, 2, 2, 3493, 3494, 5,
	448, 225, 2, 3494, 3495, 7, 253, 2, 2, 3495, 3496, 5, 472, 237, 2, 3496,
	3497, 7, 253, 2, 2, 3497, 3502, 5, 470, 236, 2, 3498, 3500, 7, 253, 2,
	2, 3499, 3501, 5, 460, 231, 2, 3500, 3499, 3, 2, 2, 2, 3500, 3501, 3, 2,
	2, 2, 3501, 3503, 3, 2, 2, 2, 3502, 3498, 3, 2, 2, 2, 3502, 3503, 3, 2,
	2, 2, 3503, 3504, 3, 2, 2, 2, 3504, 3505, 7, 257, 2, 2, 3505, 3506, 7,
	247, 2, 2, 3506, 443, 3, 2, 2, 2, 3507, 3508, 7, 134, 2, 2, 3508, 3509,
	7, 256, 2, 2, 3509, 3510, 5, 462, 232, 2, 3510, 3511, 7, 253, 2, 2, 3511,
	3512, 5, 450, 226, 2, 3512, 3513, 7, 253, 2, 2, 3513, 3514, 5, 468, 235,
	2, 3514, 3515, 7, 253, 2, 2, 3515, 3520, 5, 456, 229, 2, 3516, 3518, 7,
	253, 2, 2, 3517, 3519, 5, 460, 231, 2, 3518, 3517, 3, 2, 2, 2, 3518, 3519,
	3, 2, 2, 2, 3519, 3521, 3, 2, 2, 2, 3520, 3516, 3, 2, 2, 2, 3520, 3521,
	3, 2, 2, 2, 3521, 3522, 3, 2, 2, 2, 3522, 3523, 7, 257, 2, 2, 3523, 3524,
	7, 247, 2, 2, 3524, 445, 3, 2, 2, 2, 3525, 3526, 5, 536, 269, 2, 3526,
	447, 3, 2, 2, 2, 3527, 3528, 5, 476, 239, 2, 3528, 449, 3, 2, 2, 2, 3529,
	3530, 5, 474, 238, 2, 3530, 451, 3, 2, 2, 2, 3531, 3538, 5, 652, 327, 2,
	3532, 3533, 5, 652, 327, 2, 3533, 3534, 7, 258, 2, 2, 3534, 3535, 5, 524,
	263, 2, 3535, 3536, 7, 259, 2, 2, 3536, 3538, 3, 2, 2, 2, 3537, 3531, 3,
	2, 2, 2, 3537, 3532, 3, 2, 2, 2, 3538, 453, 3, 2, 2, 2, 3539, 3546, 5,
	652, 327, 2, 3540, 3541, 5, 652, 327, 2, 3541, 3542, 7, 258, 2, 2, 3542,
	3543, 5, 524, 263, 2, 3543, 3544, 7, 259, 2, 2, 3544, 3546, 3, 2, 2, 2,
	3545, 3539, 3, 2, 2, 2, 3545, 3540, 3, 2, 2, 2, 3546, 455, 3, 2, 2, 2,
	3547, 3548, 5, 536, 269, 2, 3548, 457, 3, 2, 2, 2, 3549, 3550, 5, 522,
	262, 2, 3550, 459, 3, 2, 2, 2, 3551, 3552, 5, 662, 332, 2, 3552, 461, 3,
	2, 2, 2, 3553, 3554, 5, 474, 238, 2, 3554, 463, 3, 2, 2, 2, 3555, 3556,
	5, 524, 263, 2, 3556, 465, 3, 2, 2, 2, 3557, 3558, 5, 536, 269, 2, 3558,
	467, 3, 2, 2, 2, 3559, 3560, 5, 536, 269, 2, 3560, 469, 3, 2, 2, 2, 3561,
	3562, 5, 522, 262, 2, 3562, 471, 3, 2, 2, 2, 3563, 3564, 5, 530, 266, 2,
	3564, 473, 3, 2, 2, 2, 3565, 3567, 5, 478, 240, 2, 3566, 3565, 3, 2, 2,
	2, 3566, 3567, 3, 2, 2, 2, 3567, 3568, 3, 2, 2, 2, 3568, 3571, 5, 480,
	241, 2, 3569, 3570, 7, 281, 2, 2, 3570, 3572, 5, 484, 243, 2, 3571, 3569,
	3, 2, 2, 2, 3571, 3572, 3, 2, 2, 2, 3572, 475, 3, 2, 2, 2, 3573, 3574,
	5, 478, 240, 2, 3574, 3577, 5, 480, 241, 2, 3575, 3576, 7, 281, 2, 2, 3576,
	3578, 5, 484, 243, 2, 3577, 3575, 3, 2, 2, 2, 3577, 3578, 3, 2, 2, 2, 3578,
	477, 3, 2, 2, 2, 3579, 3580, 9, 17, 2, 2, 3580, 479, 3, 2, 2, 2, 3581,
	3584, 5, 360, 181, 2, 3582, 3584, 5, 362, 182, 2, 3583, 3581, 3, 2, 2,
	2, 3583, 3582, 3, 2, 2, 2, 3584, 481, 3, 2, 2, 2, 3585, 3586, 7, 31, 2,
	2, 3586, 3587, 7, 258, 2, 2, 3587, 3590, 7, 309, 2, 2, 3588, 3589, 7, 253,
	2, 2, 3589, 3591, 7, 309, 2, 2, 3590, 3588, 3, 2, 2, 2, 3590, 3591, 3,
	2, 2, 2, 3591, 3592, 3, 2, 2, 2, 3592, 3593, 7, 259, 2, 2, 3593, 483, 3,
	2, 2, 2, 3594, 3600, 5, 486, 244, 2, 3595, 3596, 7, 256, 2, 2, 3596, 3597,
	5, 486, 244, 2, 3597, 3598, 7, 257, 2, 2, 3598, 3600, 3, 2, 2, 2, 3599,
	3594, 3, 2, 2, 2, 3599, 3595, 3, 2, 2, 2, 3600, 485, 3, 2, 2, 2, 3601,
	3621, 5, 530, 266, 2, 3602, 3603, 7, 285, 2, 2, 3603, 3621, 5, 530, 266,
	2, 3604, 3605, 5, 530, 266, 2, 3605, 3606, 7, 268, 2, 2, 3606, 3607, 5,
	488, 245, 2, 3607, 3621, 3, 2, 2, 2, 3608, 3609, 5, 530, 266, 2, 3609,
	3610, 7, 269, 2, 2, 3610, 3611, 5, 488, 245, 2, 3611, 3621, 3, 2, 2, 2,
	3612, 3613, 5, 530, 266, 2, 3613, 3614, 7, 270, 2, 2, 3614, 3615, 5, 488,
	245, 2, 3615, 3621, 3, 2, 2, 2, 3616, 3617, 5, 530, 266, 2, 3617, 3618,
	7, 271, 2, 2, 3618, 3619, 5, 488, 245, 2, 3619, 3621, 3, 2, 2, 2, 3620,
	3601, 3, 2, 2, 2, 3620, 3602, 3, 2, 2, 2, 3620, 3604, 3, 2, 2, 2, 3620,
	3608, 3, 2, 2, 2, 3620, 3612, 3, 2, 2, 2, 3620, 3616, 3, 2, 2, 2, 3621,
	487, 3, 2, 2, 2, 3622, 3623, 9, 19, 2, 2, 3623, 489, 3, 2, 2, 2, 3624,
	3625, 7, 260, 2, 2, 3625, 3630, 5, 530, 266, 2, 3626, 3627, 7, 253, 2,
	2, 3627, 3629, 5, 530, 266, 2, 3628, 3626, 3, 2, 2, 2, 3629, 3632, 3, 2,
	2, 2, 3630, 3628, 3, 2, 2, 2, 3630, 3631, 3, 2, 2, 2, 3631, 3633, 3, 2,
	2, 2, 3632, 3630, 3, 2, 2, 2, 3633, 3634, 7, 261, 2, 2, 3634, 491, 3, 2,
	2, 2, 3635, 3636, 7, 260, 2, 2, 3636, 3641, 5, 522, 262, 2, 3637, 3638,
	7, 253, 2, 2, 3638, 3640, 5, 522, 262, 2, 3639, 3637, 3, 2, 2, 2, 3640,
	3643, 3, 2, 2, 2, 3641, 3639, 3, 2, 2, 2, 3641, 3642, 3, 2, 2, 2, 3642,
	3644, 3, 2, 2, 2, 3643, 3641, 3, 2, 2, 2, 3644, 3645, 7, 261, 2, 2, 3645,
	493, 3, 2, 2, 2, 3646, 3647, 7, 260, 2, 2, 3647, 3648, 5, 522, 262, 2,
	3648, 3649, 5, 492, 247, 2, 3649, 3650, 7, 261, 2, 2, 3650, 495, 3, 2,
	2, 2, 3651, 3652, 7, 260, 2, 2, 3652, 3657, 5, 540, 271, 2, 3653, 3654,
	7, 253, 2, 2, 3654, 3656, 5, 540, 271, 2, 3655, 3653, 3, 2, 2, 2, 3656,
	3659, 3, 2, 2, 2, 3657, 3655, 3, 2, 2, 2, 3657, 3658, 3, 2, 2, 2, 3658,
	3660, 3, 2, 2, 2, 3659, 3657, 3, 2, 2, 2, 3660, 3661, 7, 261, 2, 2, 3661,
	497, 3, 2, 2, 2, 3662, 3663, 7, 260, 2, 2, 3663, 3664, 5, 522, 262, 2,
	3664, 3665, 5, 496, 249, 2, 3665, 3666, 7, 261, 2, 2, 3666, 499, 3, 2,
	2, 2, 3667, 3668, 7, 260, 2, 2, 3668, 3669, 5, 522, 262, 2, 3669, 3670,
	5, 490, 246, 2, 3670, 3671, 7, 261, 2, 2, 3671, 501, 3, 2, 2, 2, 3672,
	3673, 7, 260, 2, 2, 3673, 3678, 5, 504, 253, 2, 3674, 3675, 7, 253, 2,
	2, 3675, 3677, 5, 504, 253, 2, 3676, 3674, 3, 2, 2, 2, 3677, 3680, 3, 2,
	2, 2, 3678, 3676, 3, 2, 2, 2, 3678, 3679, 3, 2, 2, 2, 3679, 3681, 3, 2,
	2, 2, 3680, 3678, 3, 2, 2, 2, 3681, 3682, 7, 261, 2, 2, 3682, 503, 3, 2,
	2, 2, 3683, 3721, 5, 608, 305, 2, 3684, 3685, 5, 608, 305, 2, 3685, 3686,
	7, 258, 2, 2, 3686, 3687, 5, 530, 266, 2, 3687, 3694, 7, 259, 2, 2, 3688,
	3689, 7, 258, 2, 2, 3689, 3690, 5, 530, 266, 2, 3690, 3691, 7, 259, 2,
	2, 3691, 3693, 3, 2, 2, 2, 3692, 3688, 3, 2, 2, 2, 3693, 3696, 3, 2, 2,
	2, 3694, 3692, 3, 2, 2, 2, 3694, 3695, 3, 2, 2, 2, 3695, 3721, 3, 2, 2,
	2, 3696, 3694, 3, 2, 2, 2, 3697, 3698, 5, 608, 305, 2, 3698, 3699, 7, 258,
	2, 2, 3699, 3700, 5, 530, 266, 2, 3700, 3707, 7, 259, 2, 2, 3701, 3702,
	7, 258, 2, 2, 3702, 3703, 5, 530, 266, 2, 3703, 3704, 7, 259, 2, 2, 3704,
	3706, 3, 2, 2, 2, 3705, 3701, 3, 2, 2, 2, 3706, 3709, 3, 2, 2, 2, 3707,
	3705, 3, 2, 2, 2, 3707, 3708, 3, 2, 2, 2, 3708, 3710, 3, 2, 2, 2, 3709,
	3707, 3, 2, 2, 2, 3710, 3711, 7, 258, 2, 2, 3711, 3712, 5, 546, 274, 2,
	3712, 3713, 7, 259, 2, 2, 3713, 3721, 3, 2, 2, 2, 3714, 3715, 5, 608, 305,
	2, 3715, 3716, 7, 258, 2, 2, 3716, 3717, 5, 546, 274, 2, 3717, 3718, 7,
	259, 2, 2, 3718, 3721, 3, 2, 2, 2, 3719, 3721, 5, 502, 252, 2, 3720, 3683,
	3, 2, 2, 2, 3720, 3684, 3, 2, 2, 2, 3720, 3697, 3, 2, 2, 2, 3720, 3714,
	3, 2, 2, 2, 3720, 3719, 3, 2, 2, 2, 3721, 505, 3, 2, 2, 2, 3722, 3723,
	7, 260, 2, 2, 3723, 3728, 5, 508, 255, 2, 3724, 3725, 7, 253, 2, 2, 3725,
	3727, 5, 508, 255, 2, 3726, 3724, 3, 2, 2, 2, 3727, 3730, 3, 2, 2, 2, 3728,
	3726, 3, 2, 2, 2, 3728, 3729, 3, 2, 2, 2, 3729, 3731, 3, 2, 2, 2, 3730,
	3728, 3, 2, 2, 2, 3731, 3732, 7, 261, 2, 2, 3732, 507, 3, 2, 2, 2, 3733,
	3771, 5, 610, 306, 2, 3734, 3735, 5, 610, 306, 2, 3735, 3736, 7, 258, 2,
	2, 3736, 3737, 5, 530, 266, 2, 3737, 3744, 7, 259, 2, 2, 3738, 3739, 7,
	258, 2, 2, 3739, 3740, 5, 530, 266, 2, 3740, 3741, 7, 259, 2, 2, 3741,
	3743, 3, 2, 2, 2, 3742, 3738, 3, 2, 2, 2, 3743, 3746, 3, 2, 2, 2, 3744,
	3742, 3, 2, 2, 2, 3744, 3745, 3, 2, 2, 2, 3745, 3771, 3, 2, 2, 2, 3746,
	3744, 3, 2, 2, 2, 3747, 3748, 5, 610, 306, 2, 3748, 3749, 7, 258, 2, 2,
	3749, 3750, 5, 530, 266, 2, 3750, 3757, 7, 259, 2, 2, 3751, 3752, 7, 258,
	2, 2, 3752, 3753, 5, 530, 266, 2, 3753, 3754, 7, 259, 2, 2, 3754, 3756,
	3, 2, 2, 2, 3755, 3751, 3, 2, 2, 2, 3756, 3759, 3, 2, 2, 2, 3757, 3755,
	3, 2, 2, 2, 3757, 3758, 3, 2, 2, 2, 3758, 3760, 3, 2, 2, 2, 3759, 3757,
	3, 2, 2, 2, 3760, 3761, 7, 258, 2, 2, 3761, 3762, 5, 546, 274, 2, 3762,
	3763, 7, 259, 2, 2, 3763, 3771, 3, 2, 2, 2, 3764, 3765, 5, 610, 306, 2,
	3765, 3766, 7, 258, 2, 2, 3766, 3767, 5, 546, 274, 2, 3767, 3768, 7, 259,
	2, 2, 3768, 3771, 3, 2, 2, 2, 3769, 3771, 5, 506, 254, 2, 3770, 3733, 3,
	2, 2, 2, 3770, 3734, 3, 2, 2, 2, 3770, 3747, 3, 2, 2, 2, 3770, 3764, 3,
	2, 2, 2, 3770, 3769, 3, 2, 2, 2, 3771, 509, 3, 2, 2, 2, 3772, 3776, 5,
	590, 296, 2, 3773, 3775, 5, 570, 286, 2, 3774, 3773, 3, 2, 2, 2, 3775,
	3778, 3, 2, 2, 2, 3776, 3774, 3, 2, 2, 2, 3776, 3777, 3, 2, 2, 2, 3777,
	3779, 3, 2, 2, 2, 3778, 3776, 3, 2, 2, 2, 3779, 3788, 7, 256, 2, 2, 3780,
	3785, 5, 522, 262, 2, 3781, 3782, 7, 253, 2, 2, 3782, 3784, 5, 522, 262,
	2, 3783, 3781, 3, 2, 2, 2, 3784, 3787, 3, 2, 2, 2, 3785, 3783, 3, 2, 2,
	2, 3785, 3786, 3, 2, 2, 2, 3786, 3789, 3, 2, 2, 2, 3787, 3785, 3, 2, 2,
	2, 3788, 3780, 3, 2, 2, 2, 3788, 3789, 3, 2, 2, 2, 3789, 3790, 3, 2, 2,
	2, 3790, 3791, 7, 257, 2, 2, 3791, 511, 3, 2, 2, 2, 3792, 3796, 5, 604,
	303, 2, 3793, 3795, 5, 570, 286, 2, 3794, 3793, 3, 2, 2, 2, 3795, 3798,
	3, 2, 2, 2, 3796, 3794, 3, 2, 2, 2, 3796, 3797, 3, 2, 2, 2, 3797, 3799,
	3, 2, 2, 2, 3798, 3796, 3, 2, 2, 2, 3799, 3808, 7, 256, 2, 2, 3800, 3805,
	5, 530, 266, 2, 3801, 3802, 7, 253, 2, 2, 3802, 3804, 5, 530, 266, 2, 3803,
	3801, 3, 2, 2, 2, 3804, 3807, 3, 2, 2, 2, 3805, 3803, 3, 2, 2, 2, 3805,
	3806, 3, 2, 2, 2, 3806, 3809, 3, 2, 2, 2, 3807, 3805, 3, 2, 2, 2, 3808,
	3800, 3, 2, 2, 2, 3808, 3809, 3, 2, 2, 2, 3809, 3810, 3, 2, 2, 2, 3810,
	3811, 7, 257, 2, 2, 3811, 513, 3, 2, 2, 2, 3812, 3825, 5, 646, 324, 2,
	3813, 3822, 7, 256, 2, 2, 3814, 3819, 5, 530, 266, 2, 3815, 3816, 7, 253,
	2, 2, 3816, 3818, 5, 530, 266, 2, 3817, 3815, 3, 2, 2, 2, 3818, 3821, 3,
	2, 2, 2, 3819, 3817, 3, 2, 2, 2, 3819, 3820, 3, 2, 2, 2, 3820, 3823, 3,
	2, 2, 2, 3821, 3819, 3, 2, 2, 2, 3822, 3814, 3, 2, 2, 2, 3822, 3823, 3,
	2, 2, 2, 3823, 3824, 3, 2, 2, 2, 3824, 3826, 7, 257, 2, 2, 3825, 3813,
	3, 2, 2, 2, 3825, 3826, 3, 2, 2, 2, 3826, 515, 3, 2, 2, 2, 3827, 3831,
	5, 596, 299, 2, 3828, 3830, 5, 570, 286, 2, 3829, 3828, 3, 2, 2, 2, 3830,
	3833, 3, 2, 2, 2, 3831, 3829, 3, 2, 2, 2, 3831, 3832, 3, 2, 2, 2, 3832,
	3834, 3, 2, 2, 2, 3833, 3831, 3, 2, 2, 2, 3834, 3843, 7, 256, 2, 2, 3835,
	3840, 5, 522, 262, 2, 3836, 3837, 7, 253, 2, 2, 3837, 3839, 5, 522, 262,
	2, 3838, 3836, 3, 2, 2, 2, 3839, 3842, 3, 2, 2, 2, 3840, 3838, 3, 2, 2,
	2, 3840, 3841, 3, 2, 2, 2, 3841, 3844, 3, 2, 2, 2, 3842, 3840, 3, 2, 2,
	2, 3843, 3835, 3, 2, 2, 2, 3843, 3844, 3, 2, 2, 2, 3844, 3845, 3, 2, 2,
	2, 3845, 3846, 7, 257, 2, 2, 3846, 517, 3, 2, 2, 2, 3847, 3848, 5, 530,
	266, 2, 3848, 519, 3, 2, 2, 2, 3849, 3850, 5, 522, 262, 2, 3850, 521, 3,
	2, 2, 2, 3851, 3852, 5, 530, 266, 2, 3852, 523, 3, 2, 2, 2, 3853, 3861,
	5, 522, 262, 2, 3854, 3855, 5, 522, 262, 2, 3855, 3856, 7, 248, 2, 2, 3856,
	3857, 5, 522, 262, 2, 3857, 3858, 7, 248, 2, 2, 3858, 3859, 5, 522, 262,
	2, 3859, 3861, 3, 2, 2, 2, 3860, 3853, 3, 2, 2, 2, 3860, 3854, 3, 2, 2,
	2, 3861, 525, 3, 2, 2, 2, 3862, 3878, 5, 522, 262, 2, 3863, 3864, 5, 544,
	273, 2, 3864, 3865, 7, 248, 2, 2, 3865, 3866, 5, 534, 268, 2, 3866, 3878,
	3, 2, 2, 2, 3867, 3868, 5, 520, 261, 2, 3868, 3869, 7, 251, 2, 2, 3869,
	3870, 7, 248, 2, 2, 3870, 3871, 5, 548, 275, 2, 3871, 3878, 3, 2, 2, 2,
	3872, 3873, 5, 520, 261, 2, 3873, 3874, 7, 252, 2, 2, 3874, 3875, 7, 248,
	2, 2, 3875, 3876, 5, 548, 275, 2, 3876, 3878, 3, 2, 2, 2, 3877, 3862, 3,
	2, 2, 2, 3877, 3863, 3, 2, 2, 2, 3877, 3867, 3, 2, 2, 2, 3877, 3872, 3,
	2, 2, 2, 3878, 527, 3, 2, 2, 2, 3879, 3880, 5, 522, 262, 2, 3880, 529,
	3, 2, 2, 2, 3881, 3904, 5, 532, 267, 2, 3882, 3886, 5, 562, 282, 2, 3883,
	3885, 5, 570, 286, 2, 3884, 3883, 3, 2, 2, 2, 3885, 3888, 3, 2, 2, 2, 3886,
	3884, 3, 2, 2, 2, 3886, 3887, 3, 2, 2, 2, 3887, 3889, 3, 2, 2, 2, 3888,
	3886, 3, 2, 2, 2, 3889, 3890, 5, 532, 267, 2, 3890, 3903, 3, 2, 2, 2, 3891,
	3895, 7, 254, 2, 2, 3892, 3894, 5, 570, 286, 2, 3893, 3892, 3, 2, 2, 2,
	3894, 3897, 3, 2, 2, 2, 3895, 3893, 3, 2, 2, 2, 3895, 3896, 3, 2, 2, 2,
	3896, 3898, 3, 2, 2, 2, 3897, 3895, 3, 2, 2, 2, 3898, 3899, 5, 530, 266,
	2, 3899, 3900, 7, 248, 2, 2, 3900, 3901, 5, 532, 267, 2, 3901, 3903, 3,
	2, 2, 2, 3902, 3882, 3, 2, 2, 2, 3902, 3891, 3, 2, 2, 2, 3903, 3906, 3,
	2, 2, 2, 3904, 3902, 3, 2, 2, 2, 3904, 3905, 3, 2, 2, 2, 3905, 531, 3,
	2, 2, 2, 3906, 3904, 3, 2, 2, 2, 3907, 3911, 5, 560, 281, 2, 3908, 3910,
	5, 570, 286, 2, 3909, 3908, 3, 2, 2, 2, 3910, 3913, 3, 2, 2, 2, 3911, 3909,
	3, 2, 2, 2, 3911, 3912, 3, 2, 2, 2, 3912, 3914, 3, 2, 2, 2, 3913, 3911,
	3, 2, 2, 2, 3914, 3915, 5, 554, 278, 2, 3915, 3919, 3, 2, 2, 2, 3916, 3919,
	5, 554, 278, 2, 3917, 3919, 7, 304, 2, 2, 3918, 3907, 3, 2, 2, 2, 3918,
	3916, 3, 2, 2, 2, 3918, 3917, 3, 2, 2, 2, 3919, 533, 3, 2, 2, 2, 3920,
	3921, 5, 522, 262, 2, 3921, 535, 3, 2, 2, 2, 3922, 3928, 5, 530, 266, 2,
	3923, 3924, 7, 248, 2, 2, 3924, 3925, 5, 530, 266, 2, 3925, 3926, 7, 248,
	2, 2, 3926, 3927, 5, 530, 266, 2, 3927, 3929, 3, 2, 2, 2, 3928, 3923, 3,
	2, 2, 2, 3928, 3929, 3, 2, 2, 2, 3929, 537, 3, 2, 2, 2, 3930, 3931, 5,
	540, 271, 2, 3931, 3935, 7, 254, 2, 2, 3932, 3934, 5, 570, 286, 2, 3933,
	3932, 3, 2, 2, 2, 3934, 3937, 3, 2, 2, 2, 3935, 3933, 3, 2, 2, 2, 3935,
	3936, 3, 2, 2, 2, 3936, 3938, 3, 2, 2, 2, 3937, 3935, 3, 2, 2, 2, 3938,
	3939, 5, 540, 271, 2, 3939, 3940, 7, 248, 2, 2, 3940, 3941, 5, 540, 271,
	2, 3941, 539, 3, 2, 2, 2, 3942, 3953, 5, 552, 277, 2, 3943, 3947, 5, 564,
	283, 2, 3944, 3946, 5, 570, 286, 2, 3945, 3944, 3, 2, 2, 2, 3946, 3949,
	3, 2, 2, 2, 3947, 3945, 3, 2, 2, 2, 3947, 3948, 3, 2, 2, 2, 3948, 3950,
	3, 2, 2, 2, 3949, 3947, 3, 2, 2, 2, 3950, 3951, 5, 552, 277, 2, 3951, 3953,
	3, 2, 2, 2, 3952, 3942, 3, 2, 2, 2, 3952, 3943, 3, 2, 2, 2, 3953, 3976,
	3, 2, 2, 2, 3954, 3958, 5, 566, 284, 2, 3955, 3957, 5, 570, 286, 2, 3956,
	3955, 3, 2, 2, 2, 3957, 3960, 3, 2, 2, 2, 3958, 3956, 3, 2, 2, 2, 3958,
	3959, 3, 2, 2, 2, 3959, 3961, 3, 2, 2, 2, 3960, 3958, 3, 2, 2, 2, 3961,
	3962, 5, 540, 271, 2, 3962, 3975, 3, 2, 2, 2, 3963, 3967, 7, 254, 2, 2,
	3964, 3966, 5, 570, 286, 2, 3965, 3964, 3, 2, 2, 2, 3966, 3969, 3, 2, 2,
	2, 3967, 3965, 3, 2, 2, 2, 3967, 3968, 3, 2, 2, 2, 3968, 3970, 3, 2, 2,
	2, 3969, 3967, 3, 2, 2, 2, 3970, 3971, 5, 540, 271, 2, 3971, 3972, 7, 248,
	2, 2, 3972, 3973, 5, 540, 271, 2, 3973, 3975, 3, 2, 2, 2, 3974, 3954, 3,
	2, 2, 2, 3974, 3963, 3, 2, 2, 2, 3975, 3978, 3, 2, 2, 2, 3976, 3974, 3,
	2, 2, 2, 3976, 3977, 3, 2, 2, 2, 3977, 541, 3, 2, 2, 2, 3978, 3976, 3,
	2, 2, 2, 3979, 3985, 5, 540, 271, 2, 3980, 3981, 7, 248, 2, 2, 3981, 3982,
	5, 540, 271, 2, 3982, 3983, 7, 248, 2, 2, 3983, 3984, 5, 540, 271, 2, 3984,
	3986, 3, 2, 2, 2, 3985, 3980, 3, 2, 2, 2, 3985, 3986, 3, 2, 2, 2, 3986,
	543, 3, 2, 2, 2, 3987, 3988, 5, 522, 262, 2, 3988, 545, 3, 2, 2, 2, 3989,
	4005, 5, 530, 266, 2, 3990, 3991, 5, 544, 273, 2, 3991, 3992, 7, 248, 2,
	2, 3992, 3993, 5, 534, 268, 2, 3993, 4005, 3, 2, 2, 2, 3994, 3995, 5, 518,
	260, 2, 3995, 3996, 7, 251, 2, 2, 3996, 3997, 7, 248, 2, 2, 3997, 3998,
	5, 548, 275, 2, 3998, 4005, 3, 2, 2, 2, 3999, 4000, 5, 518, 260, 2, 4000,
	4001, 7, 252, 2, 2, 4001, 4002, 7, 248, 2, 2, 4002, 4003, 5, 548, 275,
	2, 4003, 4005, 3, 2, 2, 2, 4004, 3989, 3, 2, 2, 2, 4004, 3990, 3, 2, 2,
	2, 4004, 3994, 3, 2, 2, 2, 4004, 3999, 3, 2, 2, 2, 4005, 547, 3, 2, 2,
	2, 4006, 4007, 5, 522, 262, 2, 4007, 549, 3, 2, 2, 2, 4008, 4020, 5, 492,
	247, 2, 4009, 4020, 5, 510, 256, 2, 4010, 4011, 7, 256, 2, 2, 4011, 4012,
	5, 524, 263, 2, 4012, 4013, 7, 257, 2, 2, 4013, 4020, 3, 2, 2, 2, 4014,
	4020, 5, 494, 248, 2, 4015, 4020, 5, 598, 300, 2, 4016, 4020, 5, 568, 285,
	2, 4017, 4020, 5, 634, 318, 2, 4018, 4020, 5, 644, 323, 2, 4019, 4008,
	3, 2, 2, 2, 4019, 4009, 3, 2, 2, 2, 4019, 4010, 3, 2, 2, 2, 4019, 4014,
	3, 2, 2, 2, 4019, 4015, 3, 2, 2, 2, 4019, 4016, 3, 2, 2, 2, 4019, 4017,
	3, 2, 2, 2, 4019, 4018, 3, 2, 2, 2, 4020, 551, 3, 2, 2, 2, 4021, 4033,
	5, 568, 285, 2, 4022, 4033, 5, 614, 308, 2, 4023, 4033, 5, 496, 249, 2,
	4024, 4033, 5, 498, 250, 2, 4025, 4033, 5, 512, 257, 2, 4026, 4033, 5,
	514, 258, 2, 4027, 4033, 5, 510, 256, 2, 4028, 4029, 7, 256, 2, 2, 4029,
	4030, 5, 542, 272, 2, 4030, 4031, 7, 257, 2, 2, 4031, 4033, 3, 2, 2, 2,
	4032, 4021, 3, 2, 2, 2, 4032, 4022, 3, 2, 2, 2, 4032, 4023, 3, 2, 2, 2,
	4032, 4024, 3, 2, 2, 2, 4032, 4025, 3, 2, 2, 2, 4032, 4026, 3, 2, 2, 2,
	4032, 4027, 3, 2, 2, 2, 4032, 4028, 3, 2, 2, 2, 4033, 553, 3, 2, 2, 2,
	4034, 4073, 5, 568, 285, 2, 4035, 4073, 5, 606, 304, 2, 4036, 4041, 5,
	606, 304, 2, 4037, 4038, 7, 258, 2, 2, 4038, 4039, 5, 530, 266, 2, 4039,
	4040, 7, 259, 2, 2, 4040, 4042, 3, 2, 2, 2, 4041, 4037, 3, 2, 2, 2, 4042,
	4043, 3, 2, 2, 2, 4043, 4041, 3, 2, 2, 2, 4043, 4044, 3, 2, 2, 2, 4044,
	4073, 3, 2, 2, 2, 4045, 4050, 5, 606, 304, 2, 4046, 4047, 7, 258, 2, 2,
	4047, 4048, 5, 530, 266, 2, 4048, 4049, 7, 259, 2, 2, 4049, 4051, 3, 2,
	2, 2, 4050, 4046, 3, 2, 2, 2, 4051, 4052, 3, 2, 2, 2, 4052, 4050, 3, 2,
	2, 2, 4052, 4053, 3, 2, 2, 2, 4053, 4054, 3, 2, 2, 2, 4054, 4055, 7, 258,
	2, 2, 4055, 4056, 5, 546, 274, 2, 4056, 4057, 7, 259, 2, 2, 4057, 4073,
	3, 2, 2, 2, 4058, 4059, 5, 606, 304, 2, 4059, 4060, 7, 258, 2, 2, 4060,
	4061, 5, 546, 274, 2, 4061, 4062, 7, 259, 2, 2, 4062, 4073, 3, 2, 2, 2,
	4063, 4073, 5, 490, 246, 2, 4064, 4073, 5, 500, 251, 2, 4065, 4073, 5,
	512, 257, 2, 4066, 4073, 5, 514, 258, 2, 4067, 4073, 5, 510, 256, 2, 4068,
	4069, 7, 256, 2, 2, 4069, 4070, 5, 536, 269, 2, 4070, 4071, 7, 257, 2,
	2, 4071, 4073, 3, 2, 2, 2, 4072, 4034, 3, 2, 2, 2, 4072, 4035, 3, 2, 2,
	2, 4072, 4036, 3, 2, 2, 2, 4072, 4045, 3, 2, 2, 2, 4072, 4058, 3, 2, 2,
	2, 4072, 4063, 3, 2, 2, 2, 4072, 4064, 3, 2, 2, 2, 4072, 4065, 3, 2, 2,
	2, 4072, 4066, 3, 2, 2, 2, 4072, 4067, 3, 2, 2, 2, 4072, 4068, 3, 2, 2,
	2, 4073, 555, 3, 2, 2, 2, 4074, 4112, 5, 608, 305, 2, 4075, 4076, 5, 608,
	305, 2, 4076, 4077, 7, 258, 2, 2, 4077, 4078, 5, 522, 262, 2, 4078, 4085,
	7, 259, 2, 2, 4079, 4080, 7, 258, 2, 2, 4080, 4081, 5, 522, 262, 2, 4081,
	4082, 7, 259, 2, 2, 4082, 4084, 3, 2, 2, 2, 4083, 4079, 3, 2, 2, 2, 4084,
	4087, 3, 2, 2, 2, 4085, 4083, 3, 2, 2, 2, 4085, 4086, 3, 2, 2, 2, 4086,
	4112, 3, 2, 2, 2, 4087, 4085, 3, 2, 2, 2, 4088, 4089, 5, 608, 305, 2, 4089,
	4090, 7, 258, 2, 2, 4090, 4091, 5, 522, 262, 2, 4091, 4098, 7, 259, 2,
	2, 4092, 4093, 7, 258, 2, 2, 4093, 4094, 5, 522, 262, 2, 4094, 4095, 7,
	259, 2, 2, 4095, 4097, 3, 2, 2, 2, 4096, 4092, 3, 2, 2, 2, 4097, 4100,
	3, 2, 2, 2, 4098, 4096, 3, 2, 2, 2, 4098, 4099, 3, 2, 2, 2, 4099, 4101,
	3, 2, 2, 2, 4100, 4098, 3, 2, 2, 2, 4101, 4102, 7, 258, 2, 2, 4102, 4103,
	5, 526, 264, 2, 4103, 4104, 7, 259, 2, 2, 4104, 4112, 3, 2, 2, 2, 4105,
	4106, 5, 608, 305, 2, 4106, 4107, 7, 258, 2, 2, 4107, 4108, 5, 526, 264,
	2, 4108, 4109, 7, 259, 2, 2, 4109, 4112, 3, 2, 2, 2, 4110, 4112, 5, 502,
	252, 2, 4111, 4074, 3, 2, 2, 2, 4111, 4075, 3, 2, 2, 2, 4111, 4088, 3,
	2, 2, 2, 4111, 4105, 3, 2, 2, 2, 4111, 4110, 3, 2, 2, 2, 4112, 557, 3,
	2, 2, 2, 4113, 4151, 5, 610, 306, 2, 4114, 4115, 5, 610, 306, 2, 4115,
	4116, 7, 258, 2, 2, 4116, 4117, 5, 530, 266, 2, 4117, 4124, 7, 259, 2,
	2, 4118, 4119, 7, 258, 2, 2, 4119, 4120, 5, 530, 266, 2, 4120, 4121, 7,
	259, 2, 2, 4121, 4123, 3, 2, 2, 2, 4122, 4118, 3, 2, 2, 2, 4123, 4126,
	3, 2, 2, 2, 4124, 4122, 3, 2, 2, 2, 4124, 4125, 3, 2, 2, 2, 4125, 4151,
	3, 2, 2, 2, 4126, 4124, 3, 2, 2, 2, 4127, 4128, 5, 610, 306, 2, 4128, 4129,
	7, 258, 2, 2, 4129, 4130, 5, 530, 266, 2, 4130, 4137, 7, 259, 2, 2, 4131,
	4132, 7, 258, 2, 2, 4132, 4133, 5, 530, 266, 2, 4133, 4134, 7, 259, 2,
	2, 4134, 4136, 3, 2, 2, 2, 4135, 4131, 3, 2, 2, 2, 4136, 4139, 3, 2, 2,
	2, 4137, 4135, 3, 2, 2, 2, 4137, 4138, 3, 2, 2, 2, 4138, 4140, 3, 2, 2,
	2, 4139, 4137, 3, 2, 2, 2, 4140, 4141, 7, 258, 2, 2, 4141, 4142, 5, 546,
	274, 2, 4142, 4143, 7, 259, 2, 2, 4143, 4151, 3, 2, 2, 2, 4144, 4145, 5,
	610, 306, 2, 4145, 4146, 7, 258, 2, 2, 4146, 4147, 5, 546, 274, 2, 4147,
	4148, 7, 259, 2, 2, 4148, 4151, 3, 2, 2, 2, 4149, 4151, 5, 506, 254, 2,
	4150, 4113, 3, 2, 2, 2, 4150, 4114, 3, 2, 2, 2, 4150, 4127, 3, 2, 2, 2,
	4150, 4144, 3, 2, 2, 2, 4150, 4149, 3, 2, 2, 2, 4151, 559, 3, 2, 2, 2,
	4152, 4168, 7, 251, 2, 2, 4153, 4168, 7, 252, 2, 2, 4154, 4168, 7, 255,
	2, 2, 4155, 4168, 7, 285, 2, 2, 4156, 4168, 7, 282, 2, 2, 4157, 4158, 7,
	285, 2, 2, 4158, 4168, 7, 282, 2, 2, 4159, 4168, 7, 283, 2, 2, 4160, 4161,
	7, 285, 2, 2, 4161, 4168, 7, 283, 2, 2, 4162, 4168, 7, 286, 2, 2, 4163,
	4164, 7, 285, 2, 2, 4164, 4168, 7, 286, 2, 2, 4165, 4166, 7, 286, 2, 2,
	4166, 4168, 7, 285, 2, 2, 4167, 4152, 3, 2, 2, 2, 4167, 4153, 3, 2, 2,
	2, 4167, 4154, 3, 2, 2, 2, 4167, 4155, 3, 2, 2, 2, 4167, 4156, 3, 2, 2,
	2, 4167, 4157, 3, 2, 2, 2, 4167, 4159, 3, 2, 2, 2, 4167, 4160, 3, 2, 2,
	2, 4167, 4162, 3, 2, 2, 2, 4167, 4163, 3, 2, 2, 2, 4167, 4165, 3, 2, 2,
	2, 4168, 561, 3, 2, 2, 2, 4169, 4207, 7, 251, 2, 2, 4170, 4207, 7, 252,
	2, 2, 4171, 4207, 7, 275, 2, 2, 4172, 4207, 7, 266, 2, 2, 4173, 4207, 7,
	280, 2, 2, 4174, 4207, 7, 268, 2, 2, 4175, 4207, 7, 270, 2, 2, 4176, 4207,
	7, 269, 2, 2, 4177, 4207, 7, 271, 2, 2, 4178, 4179, 7, 282, 2, 2, 4179,
	4207, 7, 282, 2, 2, 4180, 4181, 7, 283, 2, 2, 4181, 4207, 7, 283, 2, 2,
	4182, 4183, 7, 275, 2, 2, 4183, 4207, 7, 275, 2, 2, 4184, 4207, 7, 262,
	2, 2, 4185, 4207, 7, 272, 2, 2, 4186, 4207, 7, 263, 2, 2, 4187, 4188, 7,
	263, 2, 2, 4188, 4207, 7, 267, 2, 2, 4189, 4207, 7, 282, 2, 2, 4190, 4207,
	7, 283, 2, 2, 4191, 4207, 7, 286, 2, 2, 4192, 4193, 7, 286, 2, 2, 4193,
	4207, 7, 285, 2, 2, 4194, 4195, 7, 285, 2, 2, 4195, 4207, 7, 286, 2, 2,
	4196, 4197, 7, 263, 2, 2, 4197, 4207, 7, 263, 2, 2, 4198, 4199, 7, 262,
	2, 2, 4199, 4207, 7, 262, 2, 2, 4200, 4201, 7, 263, 2, 2, 4201, 4202, 7,
	263, 2, 2, 4202, 4207, 7, 263, 2, 2, 4203, 4204, 7, 262, 2, 2, 4204, 4205,
	7, 262, 2, 2, 4205, 4207, 7, 262, 2, 2, 4206, 4169, 3, 2, 2, 2, 4206, 4170,
	3, 2, 2, 2, 4206, 4171, 3, 2, 2, 2, 4206, 4172, 3, 2, 2, 2, 4206, 4173,
	3, 2, 2, 2, 4206, 4174, 3, 2, 2, 2, 4206, 4175, 3, 2, 2, 2, 4206, 4176,
	3, 2, 2, 2, 4206, 4177, 3, 2, 2, 2, 4206, 4178, 3, 2, 2, 2, 4206, 4180,
	3, 2, 2, 2, 4206, 4182, 3, 2, 2, 2, 4206, 4184, 3, 2, 2, 2, 4206, 4185,
	3, 2, 2, 2, 4206, 4186, 3, 2, 2, 2, 4206, 4187, 3, 2, 2, 2, 4206, 4189,
	3, 2, 2, 2, 4206, 4190, 3, 2, 2, 2, 4206, 4191, 3, 2, 2, 2, 4206, 4192,
	3, 2, 2, 2, 4206, 4194, 3, 2, 2, 2, 4206, 4196, 3, 2, 2, 2, 4206, 4198,
	3, 2, 2, 2, 4206, 4200, 3, 2, 2, 2, 4206, 4203, 3, 2, 2, 2, 4207, 563,
	3, 2, 2, 2, 4208, 4222, 7, 255, 2, 2, 4209, 4222, 7, 285, 2, 2, 4210, 4222,
	7, 282, 2, 2, 4211, 4212, 7, 285, 2, 2, 4212, 4222, 7, 282, 2, 2, 4213,
	4222, 7, 283, 2, 2, 4214, 4215, 7, 285, 2, 2, 4215, 4222, 7, 283, 2, 2,
	4216, 4222, 7, 286, 2, 2, 4217, 4218, 7, 285, 2, 2, 4218, 4222, 7, 286,
	2, 2, 4219, 4220, 7, 286, 2, 2, 4220, 4222, 7, 285, 2, 2, 4221, 4208, 3,
	2, 2, 2, 4221, 4209, 3, 2, 2, 2, 4221, 4210, 3, 2, 2, 2, 4221, 4211, 3,
	2, 2, 2, 4221, 4213, 3, 2, 2, 2, 4221, 4214, 3, 2, 2, 2, 4221, 4216, 3,
	2, 2, 2, 4221, 4217, 3, 2, 2, 2, 4221, 4219, 3, 2, 2, 2, 4222, 565, 3,
	2, 2, 2, 4223, 4237, 7, 268, 2, 2, 4224, 4237, 7, 270, 2, 2, 4225, 4226,
	7, 282, 2, 2, 4226, 4237, 7, 282, 2, 2, 4227, 4228, 7, 283, 2, 2, 4228,
	4237, 7, 283, 2, 2, 4229, 4237, 7, 282, 2, 2, 4230, 4237, 7, 283, 2, 2,
	4231, 4237, 7, 286, 2, 2, 4232, 4233, 7, 286, 2, 2, 4233, 4237, 7, 285,
	2, 2, 4234, 4235, 7, 285, 2, 2, 4235, 4237, 7, 286, 2, 2, 4236, 4223, 3,
	2, 2, 2, 4236, 4224, 3, 2, 2, 2, 4236, 4225, 3, 2, 2, 2, 4236, 4227, 3,
	2, 2, 2, 4236, 4229, 3, 2, 2, 2, 4236, 4230, 3, 2, 2, 2, 4236, 4231, 3,
	2, 2, 2, 4236, 4232, 3, 2, 2, 2, 4236, 4234, 3, 2, 2, 2, 4237, 567, 3,
	2, 2, 2, 4238, 4239, 9, 20, 2, 2, 4239, 569, 3, 2, 2, 2, 4240, 4241, 7,
	256, 2, 2, 4241, 4242, 7, 275, 2, 2, 4242, 4247, 5, 572, 287, 2, 4243,
	4244, 7, 253, 2, 2, 4244, 4246, 5, 572, 287, 2, 4245, 4243, 3, 2, 2, 2,
	4246, 4249, 3, 2, 2, 2, 4247, 4245, 3, 2, 2, 2, 4247, 4248, 3, 2, 2, 2,
	4248, 4250, 3, 2, 2, 2, 4249, 4247, 3, 2, 2, 2, 4250, 4251, 7, 275, 2,
	2, 4251, 4252, 7, 257, 2, 2, 4252, 571, 3, 2, 2, 2, 4253, 4254, 5, 574,
	288, 2, 4254, 4255, 7, 267, 2, 2, 4255, 4256, 5, 522, 262, 2, 4256, 4259,
	3, 2, 2, 2, 4257, 4259, 5, 574, 288, 2, 4258, 4253, 3, 2, 2, 2, 4258, 4257,
	3, 2, 2, 2, 4259, 573, 3, 2, 2, 2, 4260, 4261, 5, 614, 308, 2, 4261, 575,
	3, 2, 2, 2, 4262, 4265, 5, 640, 321, 2, 4263, 4265, 5, 584, 293, 2, 4264,
	4262, 3, 2, 2, 2, 4264, 4263, 3, 2, 2, 2, 4265, 577, 3, 2, 2, 2, 4266,
	4267, 5, 614, 308, 2, 4267, 579, 3, 2, 2, 2, 4268, 4269, 5, 614, 308, 2,
	4269, 581, 3, 2, 2, 2, 4270, 4271, 5, 614, 308, 2, 4271, 583, 3, 2, 2,
	2, 4272, 4274, 7, 300, 2, 2, 4273, 4275, 5, 142, 72, 2, 4274, 4273, 3,
	2, 2, 2, 4274, 4275, 3, 2, 2, 2, 4275, 585, 3, 2, 2, 2, 4276, 4283, 5,
	666, 334, 2, 4277, 4278, 7, 250, 2, 2, 4278, 4282, 5, 664, 333, 2, 4279,
	4280, 7, 250, 2, 2, 4280, 4282, 5, 666, 334, 2, 4281, 4277, 3, 2, 2, 2,
	4281, 4279, 3, 2, 2, 2, 4282, 4285, 3, 2, 2, 2, 4283, 4281, 3, 2, 2, 2,
	4283, 4284, 3, 2, 2, 2, 4284, 587, 3, 2, 2, 2, 4285, 4283, 3, 2, 2, 2,
	4286, 4287, 5, 614, 308, 2, 4287, 589, 3, 2, 2, 2, 4288, 4289, 5, 614,
	308, 2, 4289, 591, 3, 2, 2, 2, 4290, 4291, 5, 576, 289, 2, 4291, 593, 3,
	2, 2, 2, 4292, 4293, 5, 614, 308, 2, 4293, 595, 3, 2, 2, 2, 4294, 4295,
	5, 614, 308, 2, 4295, 597, 3, 2, 2, 2, 4296, 4297, 5, 614, 308, 2, 4297,
	599, 3, 2, 2, 2, 4298, 4299, 5, 606, 304, 2, 4299, 601, 3, 2, 2, 2, 4300,
	4301, 5, 606, 304, 2, 4301, 603, 3, 2, 2, 2, 4302, 4303, 5, 606, 304, 2,
	4303, 605, 3, 2, 2, 2, 4304, 4307, 5, 642, 322, 2, 4305, 4307, 5, 586,
	294, 2, 4306, 4304, 3, 2, 2, 2, 4306, 4305, 3, 2, 2, 2, 4307, 607, 3, 2,
	2, 2, 4308, 4309, 5, 606, 304, 2, 4309, 609, 3, 2, 2, 2, 4310, 4311, 5,
	606, 304, 2, 4311, 611, 3, 2, 2, 2, 4312, 4313, 5, 606, 304, 2, 4313, 613,
	3, 2, 2, 2, 4314, 4315, 9, 21, 2, 2, 4315, 615, 3, 2, 2, 2, 4316, 4317,
	5, 614, 308, 2, 4317, 617, 3, 2, 2, 2, 4318, 4319, 5, 614, 308, 2, 4319,
	619, 3, 2, 2, 2, 4320, 4321, 5, 614, 308, 2, 4321, 621, 3, 2, 2, 2, 4322,
	4323, 5, 614, 308, 2, 4323, 623, 3, 2, 2, 2, 4324, 4325, 5, 614, 308, 2,
	4325, 625, 3, 2, 2, 2, 4326, 4327, 5, 614, 308, 2, 4327, 627, 3, 2, 2,
	2, 4328, 4329, 5, 576, 289, 2, 4329, 629, 3, 2, 2, 2, 4330, 4331, 5, 614,
	308, 2, 4331, 631, 3, 2, 2, 2, 4332, 4333, 5, 614, 308, 2, 4333, 633, 3,
	2, 2, 2, 4334, 4335, 5, 614, 308, 2, 4335, 635, 3, 2, 2, 2, 4336, 4337,
	5, 614, 308, 2, 4337, 637, 3, 2, 2, 2, 4338, 4339, 5, 614, 308, 2, 4339,
	639, 3, 2, 2, 2, 4340, 4342, 7, 301, 2, 2, 4341, 4343, 5, 142, 72, 2, 4342,
	4341, 3, 2, 2, 2, 4342, 4343, 3, 2, 2, 2, 4343, 641, 3, 2, 2, 2, 4344,
	4347, 5, 664, 333, 2, 4345, 4346, 7, 250, 2, 2, 4346, 4348, 7, 300, 2,
	2, 4347, 4345, 3, 2, 2, 2, 4347, 4348, 3, 2, 2, 2, 4348, 643, 3, 2, 2,
	2, 4349, 4350, 5, 614, 308, 2, 4350, 645, 3, 2, 2, 2, 4351, 4352, 9, 22,
	2, 2, 4352, 647, 3, 2, 2, 2, 4353, 4354, 9, 23, 2, 2, 4354, 649, 3, 2,
	2, 2, 4355, 4356, 5, 614, 308, 2, 4356, 651, 3, 2, 2, 2, 4357, 4358, 5,
	614, 308, 2, 4358, 653, 3, 2, 2, 2, 4359, 4360, 7, 301, 2, 2, 4360, 655,
	3, 2, 2, 2, 4361, 4362, 5, 614, 308, 2, 4362, 657, 3, 2, 2, 2, 4363, 4364,
	5, 614, 308, 2, 4364, 659, 3, 2, 2, 2, 4365, 4366, 5, 576, 289, 2, 4366,
	661, 3, 2, 2, 2, 4367, 4368, 5, 614, 308, 2, 4368, 663, 3, 2, 2, 2, 4369,
	4373, 7, 301, 2, 2, 4370, 4371, 7, 258, 2, 2, 4371, 4372, 7, 291, 2, 2,
	4372, 4374, 7, 259, 2, 2, 4373, 4370, 3, 2, 2, 2, 4373, 4374, 3, 2, 2,
	2, 4374, 4384, 3, 2, 2, 2, 4375, 4376, 7, 250, 2, 2, 4376, 4380, 7, 301,
	2, 2, 4377, 4378, 7, 258, 2, 2, 4378, 4379, 7, 291, 2, 2, 4379, 4381, 7,
	259, 2, 2, 4380, 4377, 3, 2, 2, 2, 4380, 4381, 3, 2, 2, 2, 4381, 4383,
	3, 2, 2, 2, 4382, 4375, 3, 2, 2, 2, 4383, 4386, 3, 2, 2, 2, 4384, 4382,
	3, 2, 2, 2, 4384, 4385, 3, 2, 2, 2, 4385, 665, 3, 2, 2, 2, 4386, 4384,
	3, 2, 2, 2, 4387, 4391, 7, 300, 2, 2, 4388, 4389, 7, 258, 2, 2, 4389, 4390,
	7, 291, 2, 2, 4390, 4392, 7, 259, 2, 2, 4391, 4388, 3, 2, 2, 2, 4391, 4392,
	3, 2, 2, 2, 4392, 4402, 3, 2, 2, 2, 4393, 4394, 7, 250, 2, 2, 4394, 4398,
	7, 300, 2, 2, 4395, 4396, 7, 258, 2, 2, 4396, 4397, 7, 291, 2, 2, 4397,
	4399, 7, 259, 2, 2, 4398, 4395, 3, 2, 2, 2, 4398, 4399, 3, 2, 2, 2, 4399,
	4401, 3, 2, 2, 2, 4400, 4393, 3, 2, 2, 2, 4401, 4404, 3, 2, 2, 2, 4402,
	4400, 3, 2, 2, 2, 4402, 4403, 3, 2, 2, 2, 4403, 667, 3, 2, 2, 2, 4404,
	4402, 3, 2, 2, 2, 471, 683, 692, 697, 717, 729, 736, 743, 751, 756, 760,
	762, 772, 778, 782, 788, 802, 813, 824, 831, 834, 840, 844, 853, 858, 871,
	876, 883, 890, 894, 903, 910, 917, 924, 931, 935, 940, 947, 954, 961, 968,
	975, 982, 989, 993, 1005, 1013, 1016, 1041, 1048, 1051, 1066, 1070, 1077,
	1080, 1083, 1089, 1092, 1095, 1101, 1104, 1107, 1112, 1115, 1118, 1124,
	1127, 1132, 1139, 1167, 1170, 1177, 1180, 1187, 1190, 1193, 1200, 1203,
	1206, 1213, 1216, 1219, 1226, 1229, 1232, 1236, 1243, 1246, 1249, 1253,
	1260, 1263, 1266, 1270, 1277, 1280, 1284, 1289, 1298, 1305, 1308, 1313,
	1320, 1323, 1347, 1362, 1373, 1375, 1379, 1388, 1392, 1398, 1405, 1408,
	1416, 1419, 1423, 1431, 1434, 1442, 1445, 1449, 1457, 1465, 1473, 1481,
	1489, 1497, 1505, 1511, 1517, 1521, 1537, 1546, 1561, 1566, 1588, 1591,
	1594, 1601, 1605, 1611, 1614, 1617, 1627, 1631, 1635, 1641, 1648, 1654,
	1664, 1668, 1675, 1683, 1688, 1695, 1701, 1707, 1713, 1720, 1726, 1733,
	1736, 1739, 1742, 1746, 1749, 1751, 1761, 1768, 1775, 1782, 1789, 1796,
	1803, 1810, 1814, 1818, 1821, 1831, 1840, 1843, 1847, 1854, 1861, 1868,
	1879, 1886, 1893, 1900, 1907, 1914, 1917, 1924, 1931, 1934, 1941, 1948,
	1951, 1958, 1965, 1972, 1977, 1980, 1993, 2004, 2015, 2025, 2031, 2039,
	2047, 2056, 2067, 2075, 2093, 2111, 2141, 2148, 2163, 2171, 2174, 2182,
	2193, 2200, 2208, 2211, 2216, 2220, 2225, 2232, 2240, 2247, 2254, 2263,
	2273, 2283, 2291, 2294, 2313, 2318, 2325, 2328, 2338, 2354, 2361, 2377,
	2387, 2391, 2399, 2402, 2407, 2422, 2425, 2430, 2441, 2444, 2449, 2457,
	2466, 2473, 2480, 2487, 2494, 2501, 2510, 2517, 2526, 2533, 2540, 2547,
	2554, 2558, 2564, 2568, 2573, 2582, 2589, 2596, 2603, 2610, 2617, 2621,
	2631, 2640, 2650, 2665, 2676, 2678, 2686, 2704, 2707, 2723, 2728, 2737,
	2740, 2756, 2761, 2771, 2784, 2797, 2802, 2809, 2817, 2820, 2830, 2843,
	2856, 2861, 2868, 2876, 2879, 2905, 2931, 2940, 2943, 2946, 2957, 2960,
	2963, 2971, 2981, 2991, 3001, 3012, 3022, 3026, 3034, 3046, 3054, 3068,
	3081, 3085, 3089, 3096, 3145, 3189, 3193, 3199, 3207, 3213, 3237, 3253,
	3264, 3266, 3280, 3282, 3298, 3302, 3306, 3310, 3314, 3316, 3318, 3320,
	3322, 3324, 3338, 3340, 3354, 3356, 3372, 3376, 3380, 3384, 3388, 3390,
	3392, 3394, 3396, 3398, 3412, 3414, 3428, 3432, 3436, 3438, 3440, 3442,
	3458, 3462, 3466, 3468, 3470, 3472, 3484, 3486, 3500, 3502, 3518, 3520,
	3537, 3545, 3566, 3571, 3577, 3583, 3590, 3599, 3620, 3630, 3641, 3657,
	3678, 3694, 3707, 3720, 3728, 3744, 3757, 3770, 3776, 3785, 3788, 3796,
	3805, 3808, 3819, 3822, 3825, 3831, 3840, 3843, 3860, 3877, 3886, 3895,
	3902, 3904, 3911, 3918, 3928, 3935, 3947, 3952, 3958, 3967, 3974, 3976,
	3985, 4004, 4019, 4032, 4043, 4052, 4072, 4085, 4098, 4111, 4124, 4137,
	4150, 4167, 4206, 4221, 4236, 4247, 4258, 4264, 4274, 4281, 4283, 4306,
	4342, 4347, 4373, 4380, 4384, 4391, 4398, 4402,
}
var literalNames = []string{
	"", "'module'", "'macromodule'", "'endmodule'", "'B0'", "'B1'", "'PATHPULSE'",
	"'always'", "'and'", "'assign'", "'automatic'", "'b0'", "'b1'", "'begin'",
	"'buf'", "'bufif0'", "'bufif1'", "'case'", "'casex'", "'casez'", "'config'",
	"'cell'", "'cmos'", "'deassign'", "'default'", "'default_nettype'", "'defparam'",
	"'design'", "'disable'", "'edge'", "'else'", "'end'", "'endcase'", "'endconfig'",
	"'endfunction'", "'endgenerate'", "'endprimitive'", "'endspecify'", "'endtable'",
	"'endtask'", "'event'", "'for'", "'force'", "'forever'", "'fork'", "'highz0'",
	"'highz1'", "'function'", "'generate'", "'genvar'", "'if'", "'ifnone'",
	"'include'", "'initial'", "'inout'", "'input'", "'instance'", "'integer'",
	"'join'", "'large'", "'liblist'", "'library'", "'line'", "'localparam'",
	"'medium'", "'nand'", "'negedge'", "'nmos'", "'nor'", "'noshowcancelled'",
	"'not'", "'notif0'", "'notif1'", "'or'", "'output'", "'parameter'", "'pmos'",
	"'posedge'", "'primitive'", "'pull0'", "'pull1'", "'pulldown'", "'pullup'",
	"'pulsestyle_ondetect'", "'pulsestyle_onevent'", "'rcmos'", "'real'", "'realtime'",
	"'reg'", "'release'", "'repeat'", "'rnmos'", "'rpmos'", "'rtran'", "'rtranif0'",
	"'rtranif1'", "'scalared'", "'showcancelled'", "'signed'", "'small'", "'specify'",
	"'specparam'", "'strong0'", "'strong1'", "'supply0'", "'supply1'", "'table'",
	"'task'", "'time'", "'timescale'", "'tran'", "'tranif0'", "'tranif1'",
	"'tri'", "'tri0'", "'tri1'", "'triand'", "'trior'", "'trireg'", "'use'",
	"'vectored'", "'wait'", "'wand'", "'weak0'", "'weak1'", "'while'", "'wire'",
	"'wor'", "'xnor'", "'xor'", "'$fullskew'", "'$hold'", "'$nochange'", "'$period'",
	"'$recovery'", "'$recrem'", "'$removal'", "'$root'", "'$setuphold'", "'$setup'",
	"'$skew'", "'$timeskew'", "'$unit'", "'$width'", "'$monitoroff'", "'$monitoron'",
	"'$monitoro'", "'$monitorh'", "'$monitorb'", "'$displayo'", "'$displayh'",
	"'$displayb'", "'$strobeo'", "'$strobeh'", "'$strobeb'", "'$monitor'",
	"'$display'", "'$writeo'", "'$writeh'", "'$writeb'", "'$strobe'", "'$write'",
	"'$fmonitoro'", "'$fmonitorh'", "'$fmonitorb'", "'$fdisplayo'", "'$fdisplayh'",
	"'$fdisplayb'", "'$fmonitor'", "'$fdisplay'", "'$fstrobeo'", "'$fstrobeh'",
	"'$fstrobeb'", "'$sformatf'", "'$swriteo'", "'$swriteh'", "'$swriteb'",
	"'$sformat'", "'$fwriteo'", "'$fwriteh'", "'$fwriteb'", "'$fstrobe'", "'$ungetc'",
	"'$swrite'", "'$sscanf'", "'$rewind'", "'$fwrite'", "'$fscanf'", "'$fflush'",
	"'$ferror'", "'$fclose'", "'$ftell'", "'$fseek'", "'$fopen'", "'$fread'",
	"'$fgets'", "'$fgetc'", "'$feof'", "'$printtimescale'", "'$timeformat'",
	"'$finish'", "'$stop'", "'$async$nand$plane'", "'$async$nand$array'", "'$async$nor$plane'",
	"'$async$nor$array'", "'$async$and$plane'", "'$async$and$array'", "'$sync$nand$plane'",
	"'$sync$nand$array'", "'$sync$nor$plane'", "'$sync$nor$array'", "'$sync$and$plane'",
	"'$sync$and$array'", "'$async$or$plane'", "'$async$or$array'", "'$sync$or$plane'",
	"'$sync$or$array'", "'$q_initialize'", "'$q_remove'", "'$q_full'", "'$q_exam'",
	"'$q_add'", "'$realtime'", "'$stime'", "'$time'", "'$shortrealtobits'",
	"'$bitstoshortreal'", "'$realtobits'", "'$bitstoreal'", "'$unsigned'",
	"'$signed'", "'$rtoi'", "'$itor'", "'$cast'", "'$random'", "'$dist_exponential'",
	"'$dist_chi_square'", "'$dist_uniform'", "'$dist_poisson'", "'$dist_normal'",
	"'$dist_erlang'", "'$dist_t'", "'$test$plusargs'", "'$value$plusargs'",
	"';'", "':'", "'$'", "'.'", "'+'", "'-'", "','", "'?'", "'!'", "'('", "')'",
	"'['", "']'", "'{'", "'}'", "'<'", "'>'", "'#'", "'_'", "'/'", "'='", "'=='",
	"'==='", "'!='", "'!=='", "'<='", "'=>'", "'@'", "'*'", "'<-'", "'->'",
	"'<*'", "'*>'", "'%'", "'&&&'", "'&'", "'|'", "'`'", "'~'", "'^'", "'\"'",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "'0'", "'1'", "", "'01'", "'10'",
}
var symbolicNames = []string{
	"", "K_module", "K_macromodule", "K_endmodule", "K_B0", "K_B1", "K_PATHPULSE",
	"K_always", "K_and", "K_assign", "K_automatic", "K_b0", "K_b1", "K_begin",
	"K_buf", "K_bufif0", "K_bufif1", "K_case", "K_casex", "K_casez", "K_config",
	"K_cell", "K_cmos", "K_deassign", "K_default", "K_default_nettype", "K_defparam",
	"K_design", "K_disable", "K_edge", "K_else", "K_end", "K_endcase", "K_endconfig",
	"K_endfunction", "K_endgenerate", "K_endprimitive", "K_endspecify", "K_endtable",
	"K_endtask", "K_event", "K_for", "K_force", "K_forever", "K_fork", "K_highz0",
	"K_highz1", "K_function", "K_generate", "K_genvar", "K_if", "K_ifnone",
	"K_include", "K_initial", "K_inout", "K_input", "K_instance", "K_integer",
	"K_join", "K_large", "K_liblist", "K_library", "K_line", "K_localparam",
	"K_medium", "K_nand", "K_negedge", "K_nmos", "K_nor", "K_noshowcancelled",
	"K_not", "K_notif0", "K_notif1", "K_or", "K_output", "K_parameter", "K_pmos",
	"K_posedge", "K_primitive", "K_pull0", "K_pull1", "K_pulldown", "K_pullup",
	"K_pulsestyle_ondetect", "K_pulsestyle_onevent", "K_rcmos", "K_real", "K_realtime",
	"K_reg", "K_release", "K_repeat", "K_rnmos", "K_rpmos", "K_rtran", "K_rtranif0",
	"K_rtranif1", "K_scalared", "K_showcancelled", "K_signed", "K_small", "K_specify",
	"K_specparam", "K_strong0", "K_strong1", "K_supply0", "K_supply1", "K_table",
	"K_task", "K_time", "K_timescale", "K_tran", "K_tranif0", "K_tranif1",
	"K_tri", "K_tri0", "K_tri1", "K_triand", "K_trior", "K_trireg", "K_use",
	"K_vectored", "K_wait", "K_wand", "K_weak0", "K_weak1", "K_while", "K_wire",
	"K_wor", "K_xnor", "K_xor", "K_fullskew", "K_hold", "K_nochange", "K_period",
	"K_recovery", "K_recrem", "K_removal", "K_root", "K_setuphold", "K_setup",
	"K_skew", "K_timeskew", "K_unit", "K_width", "K_TASK_monitoroff", "K_TASK_monitoron",
	"K_TASK_monitoro", "K_TASK_monitorh", "K_TASK_monitorb", "K_TASK_displayo",
	"K_TASK_displayh", "K_TASK_displayb", "K_TASK_strobeo", "K_TASK_strobeh",
	"K_TASK_strobeb", "K_TASK_monitor", "K_TASK_display", "K_TASK_writeo",
	"K_TASK_writeh", "K_TASK_writeb", "K_TASK_strobe", "K_TASK_write", "K_TASK_fmonitoro",
	"K_TASK_fmonitorh", "K_TASK_fmonitorb", "K_TASK_fdisplayo", "K_TASK_fdisplayh",
	"K_TASK_fdisplayb", "K_TASK_fmonitor", "K_TASK_fdisplay", "K_TASK_fstrobeo",
	"K_TASK_fstrobeh", "K_TASK_fstrobeb", "K_TASK_sformatf", "K_TASK_swriteo",
	"K_TASK_swriteh", "K_TASK_swriteb", "K_TASK_sformat", "K_TASK_fwriteo",
	"K_TASK_fwriteh", "K_TASK_fwriteb", "K_TASK_fstrobe", "K_TASK_ungetc",
	"K_TASK_swrite", "K_TASK_sscanf", "K_TASK_rewind", "K_TASK_fwrite", "K_TASK_fscanf",
	"K_TASK_fflush", "K_TASK_ferror", "K_TASK_fclose", "K_TASK_ftell", "K_TASK_fseek",
	"K_TASK_fopen", "K_TASK_fread", "K_TASK_fgets", "K_TASK_fgetc", "K_TASK_feof",
	"K_TASK_printtimescale", "K_TASK_timeformat", "K_TASK_finish", "K_TASK_stop",
	"K_TASK_async_nand_plane", "K_TASK_async_nand_array", "K_TASK_async_nor_plane",
	"K_TASK_async_nor_array", "K_TASK_async_and_plane", "K_TASK_async_and_array",
	"K_TASK_sync_nand_plane", "K_TASK_sync_nand_array", "K_TASK_sync_nor_plane",
	"K_TASK_sync_nor_array", "K_TASK_sync_and_plane", "K_TASK_sync_and_array",
	"K_TASK_async_or_plane", "K_TASK_async_or_array", "K_TASK_sync_or_plane",
	"K_TASK_sync_or_array", "K_FUNC_q_initialize", "K_FUNC_q_remove", "K_FUNC_q_full",
	"K_FUNC_q_exam", "K_FUNC_q_add", "K_FUNC_realtime", "K_FUNC_stime", "K_FUNC_time",
	"K_FUNC_shortrealtobits", "K_FUNC_bitstoshortreal", "K_FUNC_realtobits",
	"K_FUNC_bitstoreal", "K_FUNC_unsigned", "K_FUNC_signed", "K_FUNC_rtoi",
	"K_FUNC_itor", "K_FUNC_cast", "K_FUNC_random", "K_FUNC_dist_exponential",
	"K_FUNC_dist_chi_square", "K_FUNC_dist_uniform", "K_FUNC_dist_poisson",
	"K_FUNC_dist_normal", "K_FUNC_dist_erlang", "K_FUNC_dist_t", "K_FUNC_test_plusargs",
	"K_FUNC_value_plusargs", "Semicolon", "Colon", "Dollar", "Dot", "Plus",
	"Minus", "Comma", "Question_mark", "Exclamation_mark", "Left_parenthes",
	"Right_parenthes", "Left_bracket", "Right_bracket", "Left_brace", "Right_brace",
	"Left_angle_bracket", "Right_angle_bracket", "Sharp", "Underscore", "Slash",
	"Eq", "Eq_eq", "Eq_eq_eq", "Not_eq", "Not_eq_eq", "Left_angle_eq", "Right_angle_eq",
	"At", "Asterisk", "Left_arrow", "Right_arrow", "Left_asterisk_arrow", "Right_asterisk_arrow",
	"Percent", "AND3", "AND", "Vertical_line", "Apostrophe", "Tilda", "Hat",
	"Quotation_mark", "Ignored", "LINE", "Real_number", "Decimal_number", "Binary_number",
	"Octal_number", "Hex_number", "Single_Bit_Zero", "Single_Bit_One", "Single_Bit_X",
	"All_Binary_Zero", "All_Binary_One", "Escaped_identifier", "Simple_identifier",
	"Dollar_identifier", "Time_identifier", "String_const", "One_line_comment",
	"Block_comment", "Zero", "One", "Edge_descriptor", "Rising_Edge", "Falling_Edge",
	"X_Rising_Edge", "X_Falling_Edge", "White_space", "Bad_character", "LINE_MODE_NUMBER",
	"LINE_MODE_STRING", "LINE_MODE_NEW_LINE", "LINE_MODE_WHITE_SPACE", "LINE_MODE",
}

var ruleNames = []string{
	"directive", "timescale_directive", "config_declaration", "design_statement",
	"config_rule_statement", "default_clause", "inst_clause", "inst_name",
	"liblist_clause", "cell_clause", "use_clause", "source_text", "description",
	"module_declaration", "module_keyword", "module_parameter_port_list", "list_of_ports",
	"list_of_port_declarations", "port", "port_expression", "port_reference",
	"port_declaration", "module_item", "module_or_generate_item", "module_or_generate_item_declaration",
	"parameter_override", "local_parameter_declaration", "parameter_declaration",
	"parameter_declaration_", "specparam_declaration", "inout_declaration",
	"input_declaration", "output_declaration", "event_declaration", "genvar_declaration",
	"integer_declaration", "time_declaration", "real_declaration", "realtime_declaration",
	"reg_declaration", "net_declaration", "net_type", "output_variable_type",
	"real_type", "variable_type", "drive_strength", "strength0", "strength1",
	"charge_strength", "delay3", "delay2", "delay_value", "list_of_event_identifiers",
	"list_of_net_identifiers", "list_of_genvar_identifiers", "list_of_port_identifiers",
	"list_of_net_decl_assignments", "list_of_param_assignments", "list_of_specparam_assignments",
	"list_of_real_identifiers", "list_of_variable_identifiers", "list_of_variable_port_identifiers",
	"net_decl_assignment", "param_assignment", "specparam_assignment", "pulse_control_specparam",
	"error_limit_value", "reject_limit_value", "limit_value", "dimension",
	"range_", "function_declaration", "function_item_declaration", "function_port_list",
	"function_port", "range_or_type", "task_declaration", "task_item_declaration",
	"task_port_list", "task_port_item", "tf_decl_header", "tf_declaration",
	"task_port_type", "block_item_declaration", "block_reg_declaration", "list_of_block_variable_identifiers",
	"block_variable_type", "gate_instantiation", "cmos_switch_instance", "enable_gate_instance",
	"mos_switch_instance", "n_input_gate_instance", "n_output_gate_instance",
	"pass_switch_instance", "pass_enable_switch_instance", "pull_gate_instance",
	"name_of_gate_instance", "pulldown_strength", "pullup_strength", "enable_terminal",
	"ncontrol_terminal", "pcontrol_terminal", "input_terminal", "inout_terminal",
	"output_terminal", "cmos_switchtype", "enable_gatetype", "mos_switchtype",
	"n_input_gatetype", "n_output_gatetype", "pass_en_switchtype", "pass_switchtype",
	"module_instantiation", "parameter_value_assignment", "list_of_parameter_assignments",
	"ordered_parameter_assignment", "named_parameter_assignment", "module_instance",
	"name_of_instance", "list_of_port_connections", "ordered_port_connection",
	"named_port_connection", "generated_instantiation", "generate_item_or_null",
	"generate_item", "generate_conditional_statement", "generate_case_statement",
	"genvar_case_item", "generate_loop_statement", "genvar_assignment", "generate_block",
	"continuous_assign", "list_of_net_assignments", "net_assignment", "initial_construct",
	"always_construct", "blocking_assignment", "nonblocking_assignment", "procedural_continuous_assignments",
	"function_blocking_assignment", "function_statement_or_null", "function_seq_block",
	"variable_assignment", "par_block", "seq_block", "statement", "statement_or_null",
	"function_statement", "delay_or_event_control", "delay_control", "disable_statement",
	"event_control", "event_trigger", "event_expression", "event_primary",
	"procedural_timing_control_statement", "wait_statement", "conditional_statement",
	"if_else_if_statement", "function_conditional_statement", "function_if_else_if_statement",
	"case_statement", "case_item", "function_case_statement", "function_case_item",
	"function_loop_statement", "loop_statement", "system_task_enable", "task_enable",
	"specify_block", "specify_item", "pulsestyle_declaration", "showcancelled_declaration",
	"path_declaration", "simple_path_declaration", "parallel_path_description",
	"full_path_description", "list_of_path_inputs", "list_of_path_outputs",
	"specify_input_terminal_descriptor", "specify_output_terminal_descriptor",
	"input_identifier", "output_identifier", "path_delay_value", "list_of_path_delay_expressions",
	"t_path_delay_expression", "trise_path_delay_expression", "tfall_path_delay_expression",
	"tz_path_delay_expression", "t01_path_delay_expression", "t10_path_delay_expression",
	"t0z_path_delay_expression", "tz1_path_delay_expression", "t1z_path_delay_expression",
	"tz0_path_delay_expression", "t0x_path_delay_expression", "tx1_path_delay_expression",
	"t1x_path_delay_expression", "tx0_path_delay_expression", "txz_path_delay_expression",
	"tzx_path_delay_expression", "path_delay_expression", "edge_sensitive_path_declaration",
	"parallel_edge_sensitive_path_description", "full_edge_sensitive_path_description",
	"data_source_expression", "edge_identifier", "state_dependent_path_declaration",
	"polarity_operator", "system_timing_check", "setup_timing_check", "hold_timing_check",
	"setuphold_timing_check", "recovery_timing_check", "removal_timing_check",
	"recrem_timing_check", "skew_timing_check", "timeskew_timing_check", "fullskew_timing_check",
	"period_timing_check", "width_timing_check", "nochange_timing_check", "checktime_condition",
	"controlled_reference_event", "data_event", "delayed_data", "delayed_reference",
	"end_edge_offset", "event_based_flag", "notify_reg", "reference_event",
	"remain_active_flag", "stamptime_condition", "start_edge_offset", "threshold",
	"timing_check_limit", "timing_check_event", "controlled_timing_check_event",
	"timing_check_event_control", "specify_terminal_descriptor", "edge_control_specifier",
	"timing_check_condition", "scalar_timing_check_condition", "scalar_constant",
	"concatenation", "constant_concatenation", "constant_multiple_concatenation",
	"module_path_concatenation", "module_path_multiple_concatenation", "multiple_concatenation",
	"net_concatenation", "net_concatenation_value", "variable_concatenation",
	"variable_concatenation_value", "constant_function_call", "function_call",
	"system_function_call", "genvar_function_call", "base_expression", "constant_base_expression",
	"constant_expression", "constant_mintypmax_expression", "constant_range_expression",
	"dimension_constant_expression", "expression", "term", "lsb_constant_expression",
	"mintypmax_expression", "module_path_conditional_expression", "module_path_expression",
	"module_path_mintypmax_expression", "msb_constant_expression", "range_expression",
	"width_constant_expression", "constant_primary", "module_path_primary",
	"primary", "net_lvalue", "variable_lvalue", "unary_operator", "binary_operator",
	"unary_module_path_operator", "binary_module_path_operator", "number",
	"attribute_instance", "attr_spec", "attr_name", "arrayed_identifier", "block_identifier",
	"cell_identifier", "config_identifier", "escaped_arrayed_identifier", "escaped_hierarchical_identifier",
	"event_identifier", "function_identifier", "gate_instance_identifier",
	"generate_block_identifier", "genvar_function_identifier", "genvar_identifier",
	"hierarchical_block_identifier", "hierarchical_event_identifier", "hierarchical_function_identifier",
	"hierarchical_identifier", "hierarchical_net_identifier", "hierarchical_variable_identifier",
	"hierarchical_task_identifier", "identifier", "inout_port_identifier",
	"input_port_identifier", "instance_identifier", "library_identifier", "memory_identifier",
	"module_identifier", "module_instance_identifier", "net_identifier", "output_port_identifier",
	"parameter_identifier", "port_identifier", "real_identifier", "simple_arrayed_identifier",
	"simple_hierarchical_identifier", "specparam_identifier", "system_function_identifier",
	"system_task_identifier", "task_identifier", "terminal_identifier", "text_macro_identifier",
	"topmodule_identifier", "udp_identifier", "udp_instance_identifier", "variable_identifier",
	"simple_hierarchical_branch", "escaped_hierarchical_branch",
}

type VerilogParser struct {
	*antlr.BaseParser
}

// NewVerilogParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *VerilogParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewVerilogParser(input antlr.TokenStream) *VerilogParser {
	this := new(VerilogParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "VerilogParser.g4"

	return this
}

// VerilogParser tokens.
const (
	VerilogParserEOF                     = antlr.TokenEOF
	VerilogParserK_module                = 1
	VerilogParserK_macromodule           = 2
	VerilogParserK_endmodule             = 3
	VerilogParserK_B0                    = 4
	VerilogParserK_B1                    = 5
	VerilogParserK_PATHPULSE             = 6
	VerilogParserK_always                = 7
	VerilogParserK_and                   = 8
	VerilogParserK_assign                = 9
	VerilogParserK_automatic             = 10
	VerilogParserK_b0                    = 11
	VerilogParserK_b1                    = 12
	VerilogParserK_begin                 = 13
	VerilogParserK_buf                   = 14
	VerilogParserK_bufif0                = 15
	VerilogParserK_bufif1                = 16
	VerilogParserK_case                  = 17
	VerilogParserK_casex                 = 18
	VerilogParserK_casez                 = 19
	VerilogParserK_config                = 20
	VerilogParserK_cell                  = 21
	VerilogParserK_cmos                  = 22
	VerilogParserK_deassign              = 23
	VerilogParserK_default               = 24
	VerilogParserK_default_nettype       = 25
	VerilogParserK_defparam              = 26
	VerilogParserK_design                = 27
	VerilogParserK_disable               = 28
	VerilogParserK_edge                  = 29
	VerilogParserK_else                  = 30
	VerilogParserK_end                   = 31
	VerilogParserK_endcase               = 32
	VerilogParserK_endconfig             = 33
	VerilogParserK_endfunction           = 34
	VerilogParserK_endgenerate           = 35
	VerilogParserK_endprimitive          = 36
	VerilogParserK_endspecify            = 37
	VerilogParserK_endtable              = 38
	VerilogParserK_endtask               = 39
	VerilogParserK_event                 = 40
	VerilogParserK_for                   = 41
	VerilogParserK_force                 = 42
	VerilogParserK_forever               = 43
	VerilogParserK_fork                  = 44
	VerilogParserK_highz0                = 45
	VerilogParserK_highz1                = 46
	VerilogParserK_function              = 47
	VerilogParserK_generate              = 48
	VerilogParserK_genvar                = 49
	VerilogParserK_if                    = 50
	VerilogParserK_ifnone                = 51
	VerilogParserK_include               = 52
	VerilogParserK_initial               = 53
	VerilogParserK_inout                 = 54
	VerilogParserK_input                 = 55
	VerilogParserK_instance              = 56
	VerilogParserK_integer               = 57
	VerilogParserK_join                  = 58
	VerilogParserK_large                 = 59
	VerilogParserK_liblist               = 60
	VerilogParserK_library               = 61
	VerilogParserK_line                  = 62
	VerilogParserK_localparam            = 63
	VerilogParserK_medium                = 64
	VerilogParserK_nand                  = 65
	VerilogParserK_negedge               = 66
	VerilogParserK_nmos                  = 67
	VerilogParserK_nor                   = 68
	VerilogParserK_noshowcancelled       = 69
	VerilogParserK_not                   = 70
	VerilogParserK_notif0                = 71
	VerilogParserK_notif1                = 72
	VerilogParserK_or                    = 73
	VerilogParserK_output                = 74
	VerilogParserK_parameter             = 75
	VerilogParserK_pmos                  = 76
	VerilogParserK_posedge               = 77
	VerilogParserK_primitive             = 78
	VerilogParserK_pull0                 = 79
	VerilogParserK_pull1                 = 80
	VerilogParserK_pulldown              = 81
	VerilogParserK_pullup                = 82
	VerilogParserK_pulsestyle_ondetect   = 83
	VerilogParserK_pulsestyle_onevent    = 84
	VerilogParserK_rcmos                 = 85
	VerilogParserK_real                  = 86
	VerilogParserK_realtime              = 87
	VerilogParserK_reg                   = 88
	VerilogParserK_release               = 89
	VerilogParserK_repeat                = 90
	VerilogParserK_rnmos                 = 91
	VerilogParserK_rpmos                 = 92
	VerilogParserK_rtran                 = 93
	VerilogParserK_rtranif0              = 94
	VerilogParserK_rtranif1              = 95
	VerilogParserK_scalared              = 96
	VerilogParserK_showcancelled         = 97
	VerilogParserK_signed                = 98
	VerilogParserK_small                 = 99
	VerilogParserK_specify               = 100
	VerilogParserK_specparam             = 101
	VerilogParserK_strong0               = 102
	VerilogParserK_strong1               = 103
	VerilogParserK_supply0               = 104
	VerilogParserK_supply1               = 105
	VerilogParserK_table                 = 106
	VerilogParserK_task                  = 107
	VerilogParserK_time                  = 108
	VerilogParserK_timescale             = 109
	VerilogParserK_tran                  = 110
	VerilogParserK_tranif0               = 111
	VerilogParserK_tranif1               = 112
	VerilogParserK_tri                   = 113
	VerilogParserK_tri0                  = 114
	VerilogParserK_tri1                  = 115
	VerilogParserK_triand                = 116
	VerilogParserK_trior                 = 117
	VerilogParserK_trireg                = 118
	VerilogParserK_use                   = 119
	VerilogParserK_vectored              = 120
	VerilogParserK_wait                  = 121
	VerilogParserK_wand                  = 122
	VerilogParserK_weak0                 = 123
	VerilogParserK_weak1                 = 124
	VerilogParserK_while                 = 125
	VerilogParserK_wire                  = 126
	VerilogParserK_wor                   = 127
	VerilogParserK_xnor                  = 128
	VerilogParserK_xor                   = 129
	VerilogParserK_fullskew              = 130
	VerilogParserK_hold                  = 131
	VerilogParserK_nochange              = 132
	VerilogParserK_period                = 133
	VerilogParserK_recovery              = 134
	VerilogParserK_recrem                = 135
	VerilogParserK_removal               = 136
	VerilogParserK_root                  = 137
	VerilogParserK_setuphold             = 138
	VerilogParserK_setup                 = 139
	VerilogParserK_skew                  = 140
	VerilogParserK_timeskew              = 141
	VerilogParserK_unit                  = 142
	VerilogParserK_width                 = 143
	VerilogParserK_TASK_monitoroff       = 144
	VerilogParserK_TASK_monitoron        = 145
	VerilogParserK_TASK_monitoro         = 146
	VerilogParserK_TASK_monitorh         = 147
	VerilogParserK_TASK_monitorb         = 148
	VerilogParserK_TASK_displayo         = 149
	VerilogParserK_TASK_displayh         = 150
	VerilogParserK_TASK_displayb         = 151
	VerilogParserK_TASK_strobeo          = 152
	VerilogParserK_TASK_strobeh          = 153
	VerilogParserK_TASK_strobeb          = 154
	VerilogParserK_TASK_monitor          = 155
	VerilogParserK_TASK_display          = 156
	VerilogParserK_TASK_writeo           = 157
	VerilogParserK_TASK_writeh           = 158
	VerilogParserK_TASK_writeb           = 159
	VerilogParserK_TASK_strobe           = 160
	VerilogParserK_TASK_write            = 161
	VerilogParserK_TASK_fmonitoro        = 162
	VerilogParserK_TASK_fmonitorh        = 163
	VerilogParserK_TASK_fmonitorb        = 164
	VerilogParserK_TASK_fdisplayo        = 165
	VerilogParserK_TASK_fdisplayh        = 166
	VerilogParserK_TASK_fdisplayb        = 167
	VerilogParserK_TASK_fmonitor         = 168
	VerilogParserK_TASK_fdisplay         = 169
	VerilogParserK_TASK_fstrobeo         = 170
	VerilogParserK_TASK_fstrobeh         = 171
	VerilogParserK_TASK_fstrobeb         = 172
	VerilogParserK_TASK_sformatf         = 173
	VerilogParserK_TASK_swriteo          = 174
	VerilogParserK_TASK_swriteh          = 175
	VerilogParserK_TASK_swriteb          = 176
	VerilogParserK_TASK_sformat          = 177
	VerilogParserK_TASK_fwriteo          = 178
	VerilogParserK_TASK_fwriteh          = 179
	VerilogParserK_TASK_fwriteb          = 180
	VerilogParserK_TASK_fstrobe          = 181
	VerilogParserK_TASK_ungetc           = 182
	VerilogParserK_TASK_swrite           = 183
	VerilogParserK_TASK_sscanf           = 184
	VerilogParserK_TASK_rewind           = 185
	VerilogParserK_TASK_fwrite           = 186
	VerilogParserK_TASK_fscanf           = 187
	VerilogParserK_TASK_fflush           = 188
	VerilogParserK_TASK_ferror           = 189
	VerilogParserK_TASK_fclose           = 190
	VerilogParserK_TASK_ftell            = 191
	VerilogParserK_TASK_fseek            = 192
	VerilogParserK_TASK_fopen            = 193
	VerilogParserK_TASK_fread            = 194
	VerilogParserK_TASK_fgets            = 195
	VerilogParserK_TASK_fgetc            = 196
	VerilogParserK_TASK_feof             = 197
	VerilogParserK_TASK_printtimescale   = 198
	VerilogParserK_TASK_timeformat       = 199
	VerilogParserK_TASK_finish           = 200
	VerilogParserK_TASK_stop             = 201
	VerilogParserK_TASK_async_nand_plane = 202
	VerilogParserK_TASK_async_nand_array = 203
	VerilogParserK_TASK_async_nor_plane  = 204
	VerilogParserK_TASK_async_nor_array  = 205
	VerilogParserK_TASK_async_and_plane  = 206
	VerilogParserK_TASK_async_and_array  = 207
	VerilogParserK_TASK_sync_nand_plane  = 208
	VerilogParserK_TASK_sync_nand_array  = 209
	VerilogParserK_TASK_sync_nor_plane   = 210
	VerilogParserK_TASK_sync_nor_array   = 211
	VerilogParserK_TASK_sync_and_plane   = 212
	VerilogParserK_TASK_sync_and_array   = 213
	VerilogParserK_TASK_async_or_plane   = 214
	VerilogParserK_TASK_async_or_array   = 215
	VerilogParserK_TASK_sync_or_plane    = 216
	VerilogParserK_TASK_sync_or_array    = 217
	VerilogParserK_FUNC_q_initialize     = 218
	VerilogParserK_FUNC_q_remove         = 219
	VerilogParserK_FUNC_q_full           = 220
	VerilogParserK_FUNC_q_exam           = 221
	VerilogParserK_FUNC_q_add            = 222
	VerilogParserK_FUNC_realtime         = 223
	VerilogParserK_FUNC_stime            = 224
	VerilogParserK_FUNC_time             = 225
	VerilogParserK_FUNC_shortrealtobits  = 226
	VerilogParserK_FUNC_bitstoshortreal  = 227
	VerilogParserK_FUNC_realtobits       = 228
	VerilogParserK_FUNC_bitstoreal       = 229
	VerilogParserK_FUNC_unsigned         = 230
	VerilogParserK_FUNC_signed           = 231
	VerilogParserK_FUNC_rtoi             = 232
	VerilogParserK_FUNC_itor             = 233
	VerilogParserK_FUNC_cast             = 234
	VerilogParserK_FUNC_random           = 235
	VerilogParserK_FUNC_dist_exponential = 236
	VerilogParserK_FUNC_dist_chi_square  = 237
	VerilogParserK_FUNC_dist_uniform     = 238
	VerilogParserK_FUNC_dist_poisson     = 239
	VerilogParserK_FUNC_dist_normal      = 240
	VerilogParserK_FUNC_dist_erlang      = 241
	VerilogParserK_FUNC_dist_t           = 242
	VerilogParserK_FUNC_test_plusargs    = 243
	VerilogParserK_FUNC_value_plusargs   = 244
	VerilogParserSemicolon               = 245
	VerilogParserColon                   = 246
	VerilogParserDollar                  = 247
	VerilogParserDot                     = 248
	VerilogParserPlus                    = 249
	VerilogParserMinus                   = 250
	VerilogParserComma                   = 251
	VerilogParserQuestion_mark           = 252
	VerilogParserExclamation_mark        = 253
	VerilogParserLeft_parenthes          = 254
	VerilogParserRight_parenthes         = 255
	VerilogParserLeft_bracket            = 256
	VerilogParserRight_bracket           = 257
	VerilogParserLeft_brace              = 258
	VerilogParserRight_brace             = 259
	VerilogParserLeft_angle_bracket      = 260
	VerilogParserRight_angle_bracket     = 261
	VerilogParserSharp                   = 262
	VerilogParserUnderscore              = 263
	VerilogParserSlash                   = 264
	VerilogParserEq                      = 265
	VerilogParserEq_eq                   = 266
	VerilogParserEq_eq_eq                = 267
	VerilogParserNot_eq                  = 268
	VerilogParserNot_eq_eq               = 269
	VerilogParserLeft_angle_eq           = 270
	VerilogParserRight_angle_eq          = 271
	VerilogParserAt                      = 272
	VerilogParserAsterisk                = 273
	VerilogParserLeft_arrow              = 274
	VerilogParserRight_arrow             = 275
	VerilogParserLeft_asterisk_arrow     = 276
	VerilogParserRight_asterisk_arrow    = 277
	VerilogParserPercent                 = 278
	VerilogParserAND3                    = 279
	VerilogParserAND                     = 280
	VerilogParserVertical_line           = 281
	VerilogParserApostrophe              = 282
	VerilogParserTilda                   = 283
	VerilogParserHat                     = 284
	VerilogParserQuotation_mark          = 285
	VerilogParserIgnored                 = 286
	VerilogParserLINE                    = 287
	VerilogParserReal_number             = 288
	VerilogParserDecimal_number          = 289
	VerilogParserBinary_number           = 290
	VerilogParserOctal_number            = 291
	VerilogParserHex_number              = 292
	VerilogParserSingle_Bit_Zero         = 293
	VerilogParserSingle_Bit_One          = 294
	VerilogParserSingle_Bit_X            = 295
	VerilogParserAll_Binary_Zero         = 296
	VerilogParserAll_Binary_One          = 297
	VerilogParserEscaped_identifier      = 298
	VerilogParserSimple_identifier       = 299
	VerilogParserDollar_identifier       = 300
	VerilogParserTime_identifier         = 301
	VerilogParserString_const            = 302
	VerilogParserOne_line_comment        = 303
	VerilogParserBlock_comment           = 304
	VerilogParserZero                    = 305
	VerilogParserOne                     = 306
	VerilogParserEdge_descriptor         = 307
	VerilogParserRising_Edge             = 308
	VerilogParserFalling_Edge            = 309
	VerilogParserX_Rising_Edge           = 310
	VerilogParserX_Falling_Edge          = 311
	VerilogParserWhite_space             = 312
	VerilogParserBad_character           = 313
	VerilogParserLINE_MODE_NUMBER        = 314
	VerilogParserLINE_MODE_STRING        = 315
	VerilogParserLINE_MODE_NEW_LINE      = 316
	VerilogParserLINE_MODE_WHITE_SPACE   = 317
	VerilogParserLINE_MODE               = 318
)

// VerilogParser rules.
const (
	VerilogParserRULE_directive                                = 0
	VerilogParserRULE_timescale_directive                      = 1
	VerilogParserRULE_config_declaration                       = 2
	VerilogParserRULE_design_statement                         = 3
	VerilogParserRULE_config_rule_statement                    = 4
	VerilogParserRULE_default_clause                           = 5
	VerilogParserRULE_inst_clause                              = 6
	VerilogParserRULE_inst_name                                = 7
	VerilogParserRULE_liblist_clause                           = 8
	VerilogParserRULE_cell_clause                              = 9
	VerilogParserRULE_use_clause                               = 10
	VerilogParserRULE_source_text                              = 11
	VerilogParserRULE_description                              = 12
	VerilogParserRULE_module_declaration                       = 13
	VerilogParserRULE_module_keyword                           = 14
	VerilogParserRULE_module_parameter_port_list               = 15
	VerilogParserRULE_list_of_ports                            = 16
	VerilogParserRULE_list_of_port_declarations                = 17
	VerilogParserRULE_port                                     = 18
	VerilogParserRULE_port_expression                          = 19
	VerilogParserRULE_port_reference                           = 20
	VerilogParserRULE_port_declaration                         = 21
	VerilogParserRULE_module_item                              = 22
	VerilogParserRULE_module_or_generate_item                  = 23
	VerilogParserRULE_module_or_generate_item_declaration      = 24
	VerilogParserRULE_parameter_override                       = 25
	VerilogParserRULE_local_parameter_declaration              = 26
	VerilogParserRULE_parameter_declaration                    = 27
	VerilogParserRULE_parameter_declaration_                   = 28
	VerilogParserRULE_specparam_declaration                    = 29
	VerilogParserRULE_inout_declaration                        = 30
	VerilogParserRULE_input_declaration                        = 31
	VerilogParserRULE_output_declaration                       = 32
	VerilogParserRULE_event_declaration                        = 33
	VerilogParserRULE_genvar_declaration                       = 34
	VerilogParserRULE_integer_declaration                      = 35
	VerilogParserRULE_time_declaration                         = 36
	VerilogParserRULE_real_declaration                         = 37
	VerilogParserRULE_realtime_declaration                     = 38
	VerilogParserRULE_reg_declaration                          = 39
	VerilogParserRULE_net_declaration                          = 40
	VerilogParserRULE_net_type                                 = 41
	VerilogParserRULE_output_variable_type                     = 42
	VerilogParserRULE_real_type                                = 43
	VerilogParserRULE_variable_type                            = 44
	VerilogParserRULE_drive_strength                           = 45
	VerilogParserRULE_strength0                                = 46
	VerilogParserRULE_strength1                                = 47
	VerilogParserRULE_charge_strength                          = 48
	VerilogParserRULE_delay3                                   = 49
	VerilogParserRULE_delay2                                   = 50
	VerilogParserRULE_delay_value                              = 51
	VerilogParserRULE_list_of_event_identifiers                = 52
	VerilogParserRULE_list_of_net_identifiers                  = 53
	VerilogParserRULE_list_of_genvar_identifiers               = 54
	VerilogParserRULE_list_of_port_identifiers                 = 55
	VerilogParserRULE_list_of_net_decl_assignments             = 56
	VerilogParserRULE_list_of_param_assignments                = 57
	VerilogParserRULE_list_of_specparam_assignments            = 58
	VerilogParserRULE_list_of_real_identifiers                 = 59
	VerilogParserRULE_list_of_variable_identifiers             = 60
	VerilogParserRULE_list_of_variable_port_identifiers        = 61
	VerilogParserRULE_net_decl_assignment                      = 62
	VerilogParserRULE_param_assignment                         = 63
	VerilogParserRULE_specparam_assignment                     = 64
	VerilogParserRULE_pulse_control_specparam                  = 65
	VerilogParserRULE_error_limit_value                        = 66
	VerilogParserRULE_reject_limit_value                       = 67
	VerilogParserRULE_limit_value                              = 68
	VerilogParserRULE_dimension                                = 69
	VerilogParserRULE_range_                                   = 70
	VerilogParserRULE_function_declaration                     = 71
	VerilogParserRULE_function_item_declaration                = 72
	VerilogParserRULE_function_port_list                       = 73
	VerilogParserRULE_function_port                            = 74
	VerilogParserRULE_range_or_type                            = 75
	VerilogParserRULE_task_declaration                         = 76
	VerilogParserRULE_task_item_declaration                    = 77
	VerilogParserRULE_task_port_list                           = 78
	VerilogParserRULE_task_port_item                           = 79
	VerilogParserRULE_tf_decl_header                           = 80
	VerilogParserRULE_tf_declaration                           = 81
	VerilogParserRULE_task_port_type                           = 82
	VerilogParserRULE_block_item_declaration                   = 83
	VerilogParserRULE_block_reg_declaration                    = 84
	VerilogParserRULE_list_of_block_variable_identifiers       = 85
	VerilogParserRULE_block_variable_type                      = 86
	VerilogParserRULE_gate_instantiation                       = 87
	VerilogParserRULE_cmos_switch_instance                     = 88
	VerilogParserRULE_enable_gate_instance                     = 89
	VerilogParserRULE_mos_switch_instance                      = 90
	VerilogParserRULE_n_input_gate_instance                    = 91
	VerilogParserRULE_n_output_gate_instance                   = 92
	VerilogParserRULE_pass_switch_instance                     = 93
	VerilogParserRULE_pass_enable_switch_instance              = 94
	VerilogParserRULE_pull_gate_instance                       = 95
	VerilogParserRULE_name_of_gate_instance                    = 96
	VerilogParserRULE_pulldown_strength                        = 97
	VerilogParserRULE_pullup_strength                          = 98
	VerilogParserRULE_enable_terminal                          = 99
	VerilogParserRULE_ncontrol_terminal                        = 100
	VerilogParserRULE_pcontrol_terminal                        = 101
	VerilogParserRULE_input_terminal                           = 102
	VerilogParserRULE_inout_terminal                           = 103
	VerilogParserRULE_output_terminal                          = 104
	VerilogParserRULE_cmos_switchtype                          = 105
	VerilogParserRULE_enable_gatetype                          = 106
	VerilogParserRULE_mos_switchtype                           = 107
	VerilogParserRULE_n_input_gatetype                         = 108
	VerilogParserRULE_n_output_gatetype                        = 109
	VerilogParserRULE_pass_en_switchtype                       = 110
	VerilogParserRULE_pass_switchtype                          = 111
	VerilogParserRULE_module_instantiation                     = 112
	VerilogParserRULE_parameter_value_assignment               = 113
	VerilogParserRULE_list_of_parameter_assignments            = 114
	VerilogParserRULE_ordered_parameter_assignment             = 115
	VerilogParserRULE_named_parameter_assignment               = 116
	VerilogParserRULE_module_instance                          = 117
	VerilogParserRULE_name_of_instance                         = 118
	VerilogParserRULE_list_of_port_connections                 = 119
	VerilogParserRULE_ordered_port_connection                  = 120
	VerilogParserRULE_named_port_connection                    = 121
	VerilogParserRULE_generated_instantiation                  = 122
	VerilogParserRULE_generate_item_or_null                    = 123
	VerilogParserRULE_generate_item                            = 124
	VerilogParserRULE_generate_conditional_statement           = 125
	VerilogParserRULE_generate_case_statement                  = 126
	VerilogParserRULE_genvar_case_item                         = 127
	VerilogParserRULE_generate_loop_statement                  = 128
	VerilogParserRULE_genvar_assignment                        = 129
	VerilogParserRULE_generate_block                           = 130
	VerilogParserRULE_continuous_assign                        = 131
	VerilogParserRULE_list_of_net_assignments                  = 132
	VerilogParserRULE_net_assignment                           = 133
	VerilogParserRULE_initial_construct                        = 134
	VerilogParserRULE_always_construct                         = 135
	VerilogParserRULE_blocking_assignment                      = 136
	VerilogParserRULE_nonblocking_assignment                   = 137
	VerilogParserRULE_procedural_continuous_assignments        = 138
	VerilogParserRULE_function_blocking_assignment             = 139
	VerilogParserRULE_function_statement_or_null               = 140
	VerilogParserRULE_function_seq_block                       = 141
	VerilogParserRULE_variable_assignment                      = 142
	VerilogParserRULE_par_block                                = 143
	VerilogParserRULE_seq_block                                = 144
	VerilogParserRULE_statement                                = 145
	VerilogParserRULE_statement_or_null                        = 146
	VerilogParserRULE_function_statement                       = 147
	VerilogParserRULE_delay_or_event_control                   = 148
	VerilogParserRULE_delay_control                            = 149
	VerilogParserRULE_disable_statement                        = 150
	VerilogParserRULE_event_control                            = 151
	VerilogParserRULE_event_trigger                            = 152
	VerilogParserRULE_event_expression                         = 153
	VerilogParserRULE_event_primary                            = 154
	VerilogParserRULE_procedural_timing_control_statement      = 155
	VerilogParserRULE_wait_statement                           = 156
	VerilogParserRULE_conditional_statement                    = 157
	VerilogParserRULE_if_else_if_statement                     = 158
	VerilogParserRULE_function_conditional_statement           = 159
	VerilogParserRULE_function_if_else_if_statement            = 160
	VerilogParserRULE_case_statement                           = 161
	VerilogParserRULE_case_item                                = 162
	VerilogParserRULE_function_case_statement                  = 163
	VerilogParserRULE_function_case_item                       = 164
	VerilogParserRULE_function_loop_statement                  = 165
	VerilogParserRULE_loop_statement                           = 166
	VerilogParserRULE_system_task_enable                       = 167
	VerilogParserRULE_task_enable                              = 168
	VerilogParserRULE_specify_block                            = 169
	VerilogParserRULE_specify_item                             = 170
	VerilogParserRULE_pulsestyle_declaration                   = 171
	VerilogParserRULE_showcancelled_declaration                = 172
	VerilogParserRULE_path_declaration                         = 173
	VerilogParserRULE_simple_path_declaration                  = 174
	VerilogParserRULE_parallel_path_description                = 175
	VerilogParserRULE_full_path_description                    = 176
	VerilogParserRULE_list_of_path_inputs                      = 177
	VerilogParserRULE_list_of_path_outputs                     = 178
	VerilogParserRULE_specify_input_terminal_descriptor        = 179
	VerilogParserRULE_specify_output_terminal_descriptor       = 180
	VerilogParserRULE_input_identifier                         = 181
	VerilogParserRULE_output_identifier                        = 182
	VerilogParserRULE_path_delay_value                         = 183
	VerilogParserRULE_list_of_path_delay_expressions           = 184
	VerilogParserRULE_t_path_delay_expression                  = 185
	VerilogParserRULE_trise_path_delay_expression              = 186
	VerilogParserRULE_tfall_path_delay_expression              = 187
	VerilogParserRULE_tz_path_delay_expression                 = 188
	VerilogParserRULE_t01_path_delay_expression                = 189
	VerilogParserRULE_t10_path_delay_expression                = 190
	VerilogParserRULE_t0z_path_delay_expression                = 191
	VerilogParserRULE_tz1_path_delay_expression                = 192
	VerilogParserRULE_t1z_path_delay_expression                = 193
	VerilogParserRULE_tz0_path_delay_expression                = 194
	VerilogParserRULE_t0x_path_delay_expression                = 195
	VerilogParserRULE_tx1_path_delay_expression                = 196
	VerilogParserRULE_t1x_path_delay_expression                = 197
	VerilogParserRULE_tx0_path_delay_expression                = 198
	VerilogParserRULE_txz_path_delay_expression                = 199
	VerilogParserRULE_tzx_path_delay_expression                = 200
	VerilogParserRULE_path_delay_expression                    = 201
	VerilogParserRULE_edge_sensitive_path_declaration          = 202
	VerilogParserRULE_parallel_edge_sensitive_path_description = 203
	VerilogParserRULE_full_edge_sensitive_path_description     = 204
	VerilogParserRULE_data_source_expression                   = 205
	VerilogParserRULE_edge_identifier                          = 206
	VerilogParserRULE_state_dependent_path_declaration         = 207
	VerilogParserRULE_polarity_operator                        = 208
	VerilogParserRULE_system_timing_check                      = 209
	VerilogParserRULE_setup_timing_check                       = 210
	VerilogParserRULE_hold_timing_check                        = 211
	VerilogParserRULE_setuphold_timing_check                   = 212
	VerilogParserRULE_recovery_timing_check                    = 213
	VerilogParserRULE_removal_timing_check                     = 214
	VerilogParserRULE_recrem_timing_check                      = 215
	VerilogParserRULE_skew_timing_check                        = 216
	VerilogParserRULE_timeskew_timing_check                    = 217
	VerilogParserRULE_fullskew_timing_check                    = 218
	VerilogParserRULE_period_timing_check                      = 219
	VerilogParserRULE_width_timing_check                       = 220
	VerilogParserRULE_nochange_timing_check                    = 221
	VerilogParserRULE_checktime_condition                      = 222
	VerilogParserRULE_controlled_reference_event               = 223
	VerilogParserRULE_data_event                               = 224
	VerilogParserRULE_delayed_data                             = 225
	VerilogParserRULE_delayed_reference                        = 226
	VerilogParserRULE_end_edge_offset                          = 227
	VerilogParserRULE_event_based_flag                         = 228
	VerilogParserRULE_notify_reg                               = 229
	VerilogParserRULE_reference_event                          = 230
	VerilogParserRULE_remain_active_flag                       = 231
	VerilogParserRULE_stamptime_condition                      = 232
	VerilogParserRULE_start_edge_offset                        = 233
	VerilogParserRULE_threshold                                = 234
	VerilogParserRULE_timing_check_limit                       = 235
	VerilogParserRULE_timing_check_event                       = 236
	VerilogParserRULE_controlled_timing_check_event            = 237
	VerilogParserRULE_timing_check_event_control               = 238
	VerilogParserRULE_specify_terminal_descriptor              = 239
	VerilogParserRULE_edge_control_specifier                   = 240
	VerilogParserRULE_timing_check_condition                   = 241
	VerilogParserRULE_scalar_timing_check_condition            = 242
	VerilogParserRULE_scalar_constant                          = 243
	VerilogParserRULE_concatenation                            = 244
	VerilogParserRULE_constant_concatenation                   = 245
	VerilogParserRULE_constant_multiple_concatenation          = 246
	VerilogParserRULE_module_path_concatenation                = 247
	VerilogParserRULE_module_path_multiple_concatenation       = 248
	VerilogParserRULE_multiple_concatenation                   = 249
	VerilogParserRULE_net_concatenation                        = 250
	VerilogParserRULE_net_concatenation_value                  = 251
	VerilogParserRULE_variable_concatenation                   = 252
	VerilogParserRULE_variable_concatenation_value             = 253
	VerilogParserRULE_constant_function_call                   = 254
	VerilogParserRULE_function_call                            = 255
	VerilogParserRULE_system_function_call                     = 256
	VerilogParserRULE_genvar_function_call                     = 257
	VerilogParserRULE_base_expression                          = 258
	VerilogParserRULE_constant_base_expression                 = 259
	VerilogParserRULE_constant_expression                      = 260
	VerilogParserRULE_constant_mintypmax_expression            = 261
	VerilogParserRULE_constant_range_expression                = 262
	VerilogParserRULE_dimension_constant_expression            = 263
	VerilogParserRULE_expression                               = 264
	VerilogParserRULE_term                                     = 265
	VerilogParserRULE_lsb_constant_expression                  = 266
	VerilogParserRULE_mintypmax_expression                     = 267
	VerilogParserRULE_module_path_conditional_expression       = 268
	VerilogParserRULE_module_path_expression                   = 269
	VerilogParserRULE_module_path_mintypmax_expression         = 270
	VerilogParserRULE_msb_constant_expression                  = 271
	VerilogParserRULE_range_expression                         = 272
	VerilogParserRULE_width_constant_expression                = 273
	VerilogParserRULE_constant_primary                         = 274
	VerilogParserRULE_module_path_primary                      = 275
	VerilogParserRULE_primary                                  = 276
	VerilogParserRULE_net_lvalue                               = 277
	VerilogParserRULE_variable_lvalue                          = 278
	VerilogParserRULE_unary_operator                           = 279
	VerilogParserRULE_binary_operator                          = 280
	VerilogParserRULE_unary_module_path_operator               = 281
	VerilogParserRULE_binary_module_path_operator              = 282
	VerilogParserRULE_number                                   = 283
	VerilogParserRULE_attribute_instance                       = 284
	VerilogParserRULE_attr_spec                                = 285
	VerilogParserRULE_attr_name                                = 286
	VerilogParserRULE_arrayed_identifier                       = 287
	VerilogParserRULE_block_identifier                         = 288
	VerilogParserRULE_cell_identifier                          = 289
	VerilogParserRULE_config_identifier                        = 290
	VerilogParserRULE_escaped_arrayed_identifier               = 291
	VerilogParserRULE_escaped_hierarchical_identifier          = 292
	VerilogParserRULE_event_identifier                         = 293
	VerilogParserRULE_function_identifier                      = 294
	VerilogParserRULE_gate_instance_identifier                 = 295
	VerilogParserRULE_generate_block_identifier                = 296
	VerilogParserRULE_genvar_function_identifier               = 297
	VerilogParserRULE_genvar_identifier                        = 298
	VerilogParserRULE_hierarchical_block_identifier            = 299
	VerilogParserRULE_hierarchical_event_identifier            = 300
	VerilogParserRULE_hierarchical_function_identifier         = 301
	VerilogParserRULE_hierarchical_identifier                  = 302
	VerilogParserRULE_hierarchical_net_identifier              = 303
	VerilogParserRULE_hierarchical_variable_identifier         = 304
	VerilogParserRULE_hierarchical_task_identifier             = 305
	VerilogParserRULE_identifier                               = 306
	VerilogParserRULE_inout_port_identifier                    = 307
	VerilogParserRULE_input_port_identifier                    = 308
	VerilogParserRULE_instance_identifier                      = 309
	VerilogParserRULE_library_identifier                       = 310
	VerilogParserRULE_memory_identifier                        = 311
	VerilogParserRULE_module_identifier                        = 312
	VerilogParserRULE_module_instance_identifier               = 313
	VerilogParserRULE_net_identifier                           = 314
	VerilogParserRULE_output_port_identifier                   = 315
	VerilogParserRULE_parameter_identifier                     = 316
	VerilogParserRULE_port_identifier                          = 317
	VerilogParserRULE_real_identifier                          = 318
	VerilogParserRULE_simple_arrayed_identifier                = 319
	VerilogParserRULE_simple_hierarchical_identifier           = 320
	VerilogParserRULE_specparam_identifier                     = 321
	VerilogParserRULE_system_function_identifier               = 322
	VerilogParserRULE_system_task_identifier                   = 323
	VerilogParserRULE_task_identifier                          = 324
	VerilogParserRULE_terminal_identifier                      = 325
	VerilogParserRULE_text_macro_identifier                    = 326
	VerilogParserRULE_topmodule_identifier                     = 327
	VerilogParserRULE_udp_identifier                           = 328
	VerilogParserRULE_udp_instance_identifier                  = 329
	VerilogParserRULE_variable_identifier                      = 330
	VerilogParserRULE_simple_hierarchical_branch               = 331
	VerilogParserRULE_escaped_hierarchical_branch              = 332
)

// IDirectiveContext is an interface to support dynamic dispatch.
type IDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectiveContext differentiates from other interfaces.
	IsDirectiveContext()
}

type DirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectiveContext() *DirectiveContext {
	var p = new(DirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_directive
	return p
}

func (*DirectiveContext) IsDirectiveContext() {}

func NewDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectiveContext {
	var p = new(DirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_directive

	return p
}

func (s *DirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectiveContext) Apostrophe() antlr.TerminalNode {
	return s.GetToken(VerilogParserApostrophe, 0)
}

func (s *DirectiveContext) Timescale_directive() ITimescale_directiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimescale_directiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimescale_directiveContext)
}

func (s *DirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDirective(s)
	}
}

func (s *DirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDirective(s)
	}
}

func (p *VerilogParser) Directive() (localctx IDirectiveContext) {
	localctx = NewDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, VerilogParserRULE_directive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(VerilogParserApostrophe)
	}
	{
		p.SetState(667)
		p.Timescale_directive()
	}

	return localctx
}

// ITimescale_directiveContext is an interface to support dynamic dispatch.
type ITimescale_directiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimescale_directiveContext differentiates from other interfaces.
	IsTimescale_directiveContext()
}

type Timescale_directiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimescale_directiveContext() *Timescale_directiveContext {
	var p = new(Timescale_directiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_timescale_directive
	return p
}

func (*Timescale_directiveContext) IsTimescale_directiveContext() {}

func NewTimescale_directiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timescale_directiveContext {
	var p = new(Timescale_directiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_timescale_directive

	return p
}

func (s *Timescale_directiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Timescale_directiveContext) K_timescale() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_timescale, 0)
}

func (s *Timescale_directiveContext) AllTime_identifier() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserTime_identifier)
}

func (s *Timescale_directiveContext) Time_identifier(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserTime_identifier, i)
}

func (s *Timescale_directiveContext) Slash() antlr.TerminalNode {
	return s.GetToken(VerilogParserSlash, 0)
}

func (s *Timescale_directiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timescale_directiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timescale_directiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTimescale_directive(s)
	}
}

func (s *Timescale_directiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTimescale_directive(s)
	}
}

func (p *VerilogParser) Timescale_directive() (localctx ITimescale_directiveContext) {
	localctx = NewTimescale_directiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, VerilogParserRULE_timescale_directive)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Match(VerilogParserK_timescale)
	}
	{
		p.SetState(670)
		p.Match(VerilogParserTime_identifier)
	}
	{
		p.SetState(671)
		p.Match(VerilogParserSlash)
	}
	{
		p.SetState(672)
		p.Match(VerilogParserTime_identifier)
	}

	return localctx
}

// IConfig_declarationContext is an interface to support dynamic dispatch.
type IConfig_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_declarationContext differentiates from other interfaces.
	IsConfig_declarationContext()
}

type Config_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_declarationContext() *Config_declarationContext {
	var p = new(Config_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_config_declaration
	return p
}

func (*Config_declarationContext) IsConfig_declarationContext() {}

func NewConfig_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_declarationContext {
	var p = new(Config_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_config_declaration

	return p
}

func (s *Config_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_declarationContext) K_config() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_config, 0)
}

func (s *Config_declarationContext) Config_identifier() IConfig_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfig_identifierContext)
}

func (s *Config_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Config_declarationContext) Design_statement() IDesign_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesign_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesign_statementContext)
}

func (s *Config_declarationContext) K_endconfig() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_endconfig, 0)
}

func (s *Config_declarationContext) AllConfig_rule_statement() []IConfig_rule_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfig_rule_statementContext)(nil)).Elem())
	var tst = make([]IConfig_rule_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfig_rule_statementContext)
		}
	}

	return tst
}

func (s *Config_declarationContext) Config_rule_statement(i int) IConfig_rule_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_rule_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfig_rule_statementContext)
}

func (s *Config_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConfig_declaration(s)
	}
}

func (s *Config_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConfig_declaration(s)
	}
}

func (p *VerilogParser) Config_declaration() (localctx IConfig_declarationContext) {
	localctx = NewConfig_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, VerilogParserRULE_config_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.Match(VerilogParserK_config)
	}
	{
		p.SetState(675)
		p.Config_identifier()
	}
	{
		p.SetState(676)
		p.Match(VerilogParserSemicolon)
	}
	{
		p.SetState(677)
		p.Design_statement()
	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserK_cell || _la == VerilogParserK_default || _la == VerilogParserK_instance {
		{
			p.SetState(678)
			p.Config_rule_statement()
		}

		p.SetState(683)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(684)
		p.Match(VerilogParserK_endconfig)
	}

	return localctx
}

// IDesign_statementContext is an interface to support dynamic dispatch.
type IDesign_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesign_statementContext differentiates from other interfaces.
	IsDesign_statementContext()
}

type Design_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesign_statementContext() *Design_statementContext {
	var p = new(Design_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_design_statement
	return p
}

func (*Design_statementContext) IsDesign_statementContext() {}

func NewDesign_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Design_statementContext {
	var p = new(Design_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_design_statement

	return p
}

func (s *Design_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Design_statementContext) K_design() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_design, 0)
}

func (s *Design_statementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Design_statementContext) AllCell_identifier() []ICell_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem())
	var tst = make([]ICell_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICell_identifierContext)
		}
	}

	return tst
}

func (s *Design_statementContext) Cell_identifier(i int) ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Design_statementContext) AllLibrary_identifier() []ILibrary_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem())
	var tst = make([]ILibrary_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_identifierContext)
		}
	}

	return tst
}

func (s *Design_statementContext) Library_identifier(i int) ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Design_statementContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDot)
}

func (s *Design_statementContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, i)
}

func (s *Design_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Design_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Design_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDesign_statement(s)
	}
}

func (s *Design_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDesign_statement(s)
	}
}

func (p *VerilogParser) Design_statement() (localctx IDesign_statementContext) {
	localctx = NewDesign_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, VerilogParserRULE_design_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(VerilogParserK_design)
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		p.SetState(690)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(687)
				p.Library_identifier()
			}
			{
				p.SetState(688)
				p.Match(VerilogParserDot)
			}

		}
		{
			p.SetState(692)
			p.Cell_identifier()
		}

		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(698)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IConfig_rule_statementContext is an interface to support dynamic dispatch.
type IConfig_rule_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_rule_statementContext differentiates from other interfaces.
	IsConfig_rule_statementContext()
}

type Config_rule_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_rule_statementContext() *Config_rule_statementContext {
	var p = new(Config_rule_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_config_rule_statement
	return p
}

func (*Config_rule_statementContext) IsConfig_rule_statementContext() {}

func NewConfig_rule_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_rule_statementContext {
	var p = new(Config_rule_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_config_rule_statement

	return p
}

func (s *Config_rule_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_rule_statementContext) Default_clause() IDefault_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_clauseContext)
}

func (s *Config_rule_statementContext) Liblist_clause() ILiblist_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiblist_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiblist_clauseContext)
}

func (s *Config_rule_statementContext) Inst_clause() IInst_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInst_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInst_clauseContext)
}

func (s *Config_rule_statementContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Config_rule_statementContext) Cell_clause() ICell_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_clauseContext)
}

func (s *Config_rule_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_rule_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_rule_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConfig_rule_statement(s)
	}
}

func (s *Config_rule_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConfig_rule_statement(s)
	}
}

func (p *VerilogParser) Config_rule_statement() (localctx IConfig_rule_statementContext) {
	localctx = NewConfig_rule_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, VerilogParserRULE_config_rule_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(700)
			p.Default_clause()
		}
		{
			p.SetState(701)
			p.Liblist_clause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(703)
			p.Inst_clause()
		}
		{
			p.SetState(704)
			p.Liblist_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(706)
			p.Inst_clause()
		}
		{
			p.SetState(707)
			p.Use_clause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(709)
			p.Cell_clause()
		}
		{
			p.SetState(710)
			p.Liblist_clause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(712)
			p.Cell_clause()
		}
		{
			p.SetState(713)
			p.Use_clause()
		}

	}

	return localctx
}

// IDefault_clauseContext is an interface to support dynamic dispatch.
type IDefault_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_clauseContext differentiates from other interfaces.
	IsDefault_clauseContext()
}

type Default_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_clauseContext() *Default_clauseContext {
	var p = new(Default_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_default_clause
	return p
}

func (*Default_clauseContext) IsDefault_clauseContext() {}

func NewDefault_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_clauseContext {
	var p = new(Default_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_default_clause

	return p
}

func (s *Default_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Default_clauseContext) K_default() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_default, 0)
}

func (s *Default_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDefault_clause(s)
	}
}

func (s *Default_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDefault_clause(s)
	}
}

func (p *VerilogParser) Default_clause() (localctx IDefault_clauseContext) {
	localctx = NewDefault_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, VerilogParserRULE_default_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.Match(VerilogParserK_default)
	}

	return localctx
}

// IInst_clauseContext is an interface to support dynamic dispatch.
type IInst_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInst_clauseContext differentiates from other interfaces.
	IsInst_clauseContext()
}

type Inst_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInst_clauseContext() *Inst_clauseContext {
	var p = new(Inst_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inst_clause
	return p
}

func (*Inst_clauseContext) IsInst_clauseContext() {}

func NewInst_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inst_clauseContext {
	var p = new(Inst_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inst_clause

	return p
}

func (s *Inst_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Inst_clauseContext) K_instance() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_instance, 0)
}

func (s *Inst_clauseContext) Inst_name() IInst_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInst_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInst_nameContext)
}

func (s *Inst_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inst_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inst_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInst_clause(s)
	}
}

func (s *Inst_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInst_clause(s)
	}
}

func (p *VerilogParser) Inst_clause() (localctx IInst_clauseContext) {
	localctx = NewInst_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, VerilogParserRULE_inst_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(719)
		p.Match(VerilogParserK_instance)
	}
	{
		p.SetState(720)
		p.Inst_name()
	}

	return localctx
}

// IInst_nameContext is an interface to support dynamic dispatch.
type IInst_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInst_nameContext differentiates from other interfaces.
	IsInst_nameContext()
}

type Inst_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInst_nameContext() *Inst_nameContext {
	var p = new(Inst_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inst_name
	return p
}

func (*Inst_nameContext) IsInst_nameContext() {}

func NewInst_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inst_nameContext {
	var p = new(Inst_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inst_name

	return p
}

func (s *Inst_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Inst_nameContext) Topmodule_identifier() ITopmodule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopmodule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopmodule_identifierContext)
}

func (s *Inst_nameContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDot)
}

func (s *Inst_nameContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, i)
}

func (s *Inst_nameContext) AllInstance_identifier() []IInstance_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstance_identifierContext)(nil)).Elem())
	var tst = make([]IInstance_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstance_identifierContext)
		}
	}

	return tst
}

func (s *Inst_nameContext) Instance_identifier(i int) IInstance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstance_identifierContext)
}

func (s *Inst_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inst_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inst_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInst_name(s)
	}
}

func (s *Inst_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInst_name(s)
	}
}

func (p *VerilogParser) Inst_name() (localctx IInst_nameContext) {
	localctx = NewInst_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, VerilogParserRULE_inst_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(722)
		p.Topmodule_identifier()
	}
	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserDot {
		{
			p.SetState(723)
			p.Match(VerilogParserDot)
		}
		{
			p.SetState(724)
			p.Instance_identifier()
		}

		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILiblist_clauseContext is an interface to support dynamic dispatch.
type ILiblist_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiblist_clauseContext differentiates from other interfaces.
	IsLiblist_clauseContext()
}

type Liblist_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiblist_clauseContext() *Liblist_clauseContext {
	var p = new(Liblist_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_liblist_clause
	return p
}

func (*Liblist_clauseContext) IsLiblist_clauseContext() {}

func NewLiblist_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Liblist_clauseContext {
	var p = new(Liblist_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_liblist_clause

	return p
}

func (s *Liblist_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Liblist_clauseContext) K_liblist() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_liblist, 0)
}

func (s *Liblist_clauseContext) AllLibrary_identifier() []ILibrary_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem())
	var tst = make([]ILibrary_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_identifierContext)
		}
	}

	return tst
}

func (s *Liblist_clauseContext) Library_identifier(i int) ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Liblist_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Liblist_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Liblist_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLiblist_clause(s)
	}
}

func (s *Liblist_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLiblist_clause(s)
	}
}

func (p *VerilogParser) Liblist_clause() (localctx ILiblist_clauseContext) {
	localctx = NewLiblist_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, VerilogParserRULE_liblist_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.Match(VerilogParserK_liblist)
	}
	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(731)
			p.Library_identifier()
		}

		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICell_clauseContext is an interface to support dynamic dispatch.
type ICell_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_clauseContext differentiates from other interfaces.
	IsCell_clauseContext()
}

type Cell_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_clauseContext() *Cell_clauseContext {
	var p = new(Cell_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cell_clause
	return p
}

func (*Cell_clauseContext) IsCell_clauseContext() {}

func NewCell_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_clauseContext {
	var p = new(Cell_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cell_clause

	return p
}

func (s *Cell_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_clauseContext) K_cell() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_cell, 0)
}

func (s *Cell_clauseContext) Cell_identifier() ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Cell_clauseContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Cell_clauseContext) Dot() antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, 0)
}

func (s *Cell_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCell_clause(s)
	}
}

func (s *Cell_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCell_clause(s)
	}
}

func (p *VerilogParser) Cell_clause() (localctx ICell_clauseContext) {
	localctx = NewCell_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, VerilogParserRULE_cell_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		p.Match(VerilogParserK_cell)
	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(738)
			p.Library_identifier()
		}
		{
			p.SetState(739)
			p.Match(VerilogParserDot)
		}

	}
	{
		p.SetState(743)
		p.Cell_identifier()
	}

	return localctx
}

// IUse_clauseContext is an interface to support dynamic dispatch.
type IUse_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUse_clauseContext differentiates from other interfaces.
	IsUse_clauseContext()
}

type Use_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_clauseContext() *Use_clauseContext {
	var p = new(Use_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_use_clause
	return p
}

func (*Use_clauseContext) IsUse_clauseContext() {}

func NewUse_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_clauseContext {
	var p = new(Use_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_use_clause

	return p
}

func (s *Use_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_clauseContext) K_use() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_use, 0)
}

func (s *Use_clauseContext) Cell_identifier() ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Use_clauseContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Use_clauseContext) Dot() antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, 0)
}

func (s *Use_clauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Use_clauseContext) K_config() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_config, 0)
}

func (s *Use_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUse_clause(s)
	}
}

func (s *Use_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUse_clause(s)
	}
}

func (p *VerilogParser) Use_clause() (localctx IUse_clauseContext) {
	localctx = NewUse_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, VerilogParserRULE_use_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Match(VerilogParserK_use)
	}
	p.SetState(749)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(746)
			p.Library_identifier()
		}
		{
			p.SetState(747)
			p.Match(VerilogParserDot)
		}

	}
	{
		p.SetState(751)
		p.Cell_identifier()
	}
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserColon {
		{
			p.SetState(752)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(753)
			p.Match(VerilogParserK_config)
		}

	}

	return localctx
}

// ISource_textContext is an interface to support dynamic dispatch.
type ISource_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSource_textContext differentiates from other interfaces.
	IsSource_textContext()
}

type Source_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySource_textContext() *Source_textContext {
	var p = new(Source_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_source_text
	return p
}

func (*Source_textContext) IsSource_textContext() {}

func NewSource_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Source_textContext {
	var p = new(Source_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_source_text

	return p
}

func (s *Source_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Source_textContext) EOF() antlr.TerminalNode {
	return s.GetToken(VerilogParserEOF, 0)
}

func (s *Source_textContext) AllDirective() []IDirectiveContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDirectiveContext)(nil)).Elem())
	var tst = make([]IDirectiveContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDirectiveContext)
		}
	}

	return tst
}

func (s *Source_textContext) Directive(i int) IDirectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectiveContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDirectiveContext)
}

func (s *Source_textContext) AllDescription() []IDescriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDescriptionContext)(nil)).Elem())
	var tst = make([]IDescriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDescriptionContext)
		}
	}

	return tst
}

func (s *Source_textContext) Description(i int) IDescriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *Source_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Source_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Source_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSource_text(s)
	}
}

func (s *Source_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSource_text(s)
	}
}

func (p *VerilogParser) Source_text() (localctx ISource_textContext) {
	localctx = NewSource_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, VerilogParserRULE_source_text)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(760)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserK_module || _la == VerilogParserK_macromodule || _la == VerilogParserLeft_parenthes || _la == VerilogParserApostrophe {
		p.SetState(758)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case VerilogParserApostrophe:
			{
				p.SetState(756)
				p.Directive()
			}

		case VerilogParserK_module, VerilogParserK_macromodule, VerilogParserLeft_parenthes:
			{
				p.SetState(757)
				p.Description()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(763)
		p.Match(VerilogParserEOF)
	}

	return localctx
}

// IDescriptionContext is an interface to support dynamic dispatch.
type IDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescriptionContext differentiates from other interfaces.
	IsDescriptionContext()
}

type DescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptionContext() *DescriptionContext {
	var p = new(DescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_description
	return p
}

func (*DescriptionContext) IsDescriptionContext() {}

func NewDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptionContext {
	var p = new(DescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_description

	return p
}

func (s *DescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptionContext) Module_declaration() IModule_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_declarationContext)
}

func (s *DescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDescription(s)
	}
}

func (s *DescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDescription(s)
	}
}

func (p *VerilogParser) Description() (localctx IDescriptionContext) {
	localctx = NewDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, VerilogParserRULE_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.Module_declaration()
	}

	return localctx
}

// IModule_declarationContext is an interface to support dynamic dispatch.
type IModule_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_declarationContext differentiates from other interfaces.
	IsModule_declarationContext()
}

type Module_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_declarationContext() *Module_declarationContext {
	var p = new(Module_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_declaration
	return p
}

func (*Module_declarationContext) IsModule_declarationContext() {}

func NewModule_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_declarationContext {
	var p = new(Module_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_declaration

	return p
}

func (s *Module_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_declarationContext) Module_keyword() IModule_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_keywordContext)
}

func (s *Module_declarationContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Module_declarationContext) K_endmodule() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_endmodule, 0)
}

func (s *Module_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_declarationContext) Module_parameter_port_list() IModule_parameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_parameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_parameter_port_listContext)
}

func (s *Module_declarationContext) List_of_port_declarations() IList_of_port_declarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_declarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_declarationsContext)
}

func (s *Module_declarationContext) List_of_ports() IList_of_portsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_portsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_portsContext)
}

func (s *Module_declarationContext) AllModule_item() []IModule_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_itemContext)(nil)).Elem())
	var tst = make([]IModule_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_itemContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Module_item(i int) IModule_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_itemContext)
}

func (s *Module_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_declaration(s)
	}
}

func (s *Module_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_declaration(s)
	}
}

func (p *VerilogParser) Module_declaration() (localctx IModule_declarationContext) {
	localctx = NewModule_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, VerilogParserRULE_module_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(770)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserLeft_parenthes {
		{
			p.SetState(767)
			p.Attribute_instance()
		}

		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(773)
		p.Module_keyword()
	}
	{
		p.SetState(774)
		p.Module_identifier()
	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserSharp {
		{
			p.SetState(775)
			p.Module_parameter_port_list()
		}

	}
	p.SetState(780)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(778)
			p.List_of_port_declarations()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(779)
			p.List_of_ports()
		}

	}
	{
		p.SetState(782)
		p.Match(VerilogParserSemicolon)
	}
	p.SetState(786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserK_always)|(1<<VerilogParserK_and)|(1<<VerilogParserK_assign)|(1<<VerilogParserK_buf)|(1<<VerilogParserK_bufif0)|(1<<VerilogParserK_bufif1)|(1<<VerilogParserK_cmos)|(1<<VerilogParserK_defparam))) != 0) || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(VerilogParserK_event-40))|(1<<(VerilogParserK_function-40))|(1<<(VerilogParserK_generate-40))|(1<<(VerilogParserK_genvar-40))|(1<<(VerilogParserK_initial-40))|(1<<(VerilogParserK_inout-40))|(1<<(VerilogParserK_input-40))|(1<<(VerilogParserK_integer-40))|(1<<(VerilogParserK_localparam-40))|(1<<(VerilogParserK_nand-40))|(1<<(VerilogParserK_nmos-40))|(1<<(VerilogParserK_nor-40))|(1<<(VerilogParserK_not-40))|(1<<(VerilogParserK_notif0-40)))) != 0) || (((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(VerilogParserK_notif1-72))|(1<<(VerilogParserK_or-72))|(1<<(VerilogParserK_output-72))|(1<<(VerilogParserK_parameter-72))|(1<<(VerilogParserK_pmos-72))|(1<<(VerilogParserK_pulldown-72))|(1<<(VerilogParserK_pullup-72))|(1<<(VerilogParserK_rcmos-72))|(1<<(VerilogParserK_real-72))|(1<<(VerilogParserK_realtime-72))|(1<<(VerilogParserK_reg-72))|(1<<(VerilogParserK_rnmos-72))|(1<<(VerilogParserK_rpmos-72))|(1<<(VerilogParserK_rtran-72))|(1<<(VerilogParserK_rtranif0-72))|(1<<(VerilogParserK_rtranif1-72))|(1<<(VerilogParserK_specify-72))|(1<<(VerilogParserK_specparam-72)))) != 0) || (((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(VerilogParserK_supply0-104))|(1<<(VerilogParserK_supply1-104))|(1<<(VerilogParserK_task-104))|(1<<(VerilogParserK_time-104))|(1<<(VerilogParserK_tran-104))|(1<<(VerilogParserK_tranif0-104))|(1<<(VerilogParserK_tranif1-104))|(1<<(VerilogParserK_tri-104))|(1<<(VerilogParserK_tri0-104))|(1<<(VerilogParserK_tri1-104))|(1<<(VerilogParserK_triand-104))|(1<<(VerilogParserK_trior-104))|(1<<(VerilogParserK_trireg-104))|(1<<(VerilogParserK_wand-104))|(1<<(VerilogParserK_wire-104))|(1<<(VerilogParserK_wor-104))|(1<<(VerilogParserK_xnor-104))|(1<<(VerilogParserK_xor-104)))) != 0) || _la == VerilogParserLeft_parenthes || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(783)
			p.Module_item()
		}

		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(789)
		p.Match(VerilogParserK_endmodule)
	}

	return localctx
}

// IModule_keywordContext is an interface to support dynamic dispatch.
type IModule_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_keywordContext differentiates from other interfaces.
	IsModule_keywordContext()
}

type Module_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_keywordContext() *Module_keywordContext {
	var p = new(Module_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_keyword
	return p
}

func (*Module_keywordContext) IsModule_keywordContext() {}

func NewModule_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_keywordContext {
	var p = new(Module_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_keyword

	return p
}

func (s *Module_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_keywordContext) K_module() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_module, 0)
}

func (s *Module_keywordContext) K_macromodule() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_macromodule, 0)
}

func (s *Module_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_keyword(s)
	}
}

func (s *Module_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_keyword(s)
	}
}

func (p *VerilogParser) Module_keyword() (localctx IModule_keywordContext) {
	localctx = NewModule_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, VerilogParserRULE_module_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserK_module || _la == VerilogParserK_macromodule) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IModule_parameter_port_listContext is an interface to support dynamic dispatch.
type IModule_parameter_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_parameter_port_listContext differentiates from other interfaces.
	IsModule_parameter_port_listContext()
}

type Module_parameter_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_parameter_port_listContext() *Module_parameter_port_listContext {
	var p = new(Module_parameter_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_parameter_port_list
	return p
}

func (*Module_parameter_port_listContext) IsModule_parameter_port_listContext() {}

func NewModule_parameter_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_parameter_port_listContext {
	var p = new(Module_parameter_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_parameter_port_list

	return p
}

func (s *Module_parameter_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_parameter_port_listContext) Sharp() antlr.TerminalNode {
	return s.GetToken(VerilogParserSharp, 0)
}

func (s *Module_parameter_port_listContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Module_parameter_port_listContext) AllParameter_declaration_() []IParameter_declaration_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameter_declaration_Context)(nil)).Elem())
	var tst = make([]IParameter_declaration_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameter_declaration_Context)
		}
	}

	return tst
}

func (s *Module_parameter_port_listContext) Parameter_declaration_(i int) IParameter_declaration_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_Context)
}

func (s *Module_parameter_port_listContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Module_parameter_port_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Module_parameter_port_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Module_parameter_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_parameter_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_parameter_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_parameter_port_list(s)
	}
}

func (s *Module_parameter_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_parameter_port_list(s)
	}
}

func (p *VerilogParser) Module_parameter_port_list() (localctx IModule_parameter_port_listContext) {
	localctx = NewModule_parameter_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, VerilogParserRULE_module_parameter_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Match(VerilogParserSharp)
	}
	{
		p.SetState(794)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(795)
		p.Parameter_declaration_()
	}
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(796)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(797)
			p.Parameter_declaration_()
		}

		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(803)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IList_of_portsContext is an interface to support dynamic dispatch.
type IList_of_portsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_portsContext differentiates from other interfaces.
	IsList_of_portsContext()
}

type List_of_portsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_portsContext() *List_of_portsContext {
	var p = new(List_of_portsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_ports
	return p
}

func (*List_of_portsContext) IsList_of_portsContext() {}

func NewList_of_portsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_portsContext {
	var p = new(List_of_portsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_ports

	return p
}

func (s *List_of_portsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_portsContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *List_of_portsContext) AllPort() []IPortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPortContext)(nil)).Elem())
	var tst = make([]IPortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPortContext)
		}
	}

	return tst
}

func (s *List_of_portsContext) Port(i int) IPortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPortContext)
}

func (s *List_of_portsContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *List_of_portsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_portsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_portsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_portsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_portsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_ports(s)
	}
}

func (s *List_of_portsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_ports(s)
	}
}

func (p *VerilogParser) List_of_ports() (localctx IList_of_portsContext) {
	localctx = NewList_of_portsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, VerilogParserRULE_list_of_ports)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(806)
		p.Port()
	}
	p.SetState(811)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(807)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(808)
			p.Port()
		}

		p.SetState(813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(814)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IList_of_port_declarationsContext is an interface to support dynamic dispatch.
type IList_of_port_declarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_declarationsContext differentiates from other interfaces.
	IsList_of_port_declarationsContext()
}

type List_of_port_declarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_declarationsContext() *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_port_declarations
	return p
}

func (*List_of_port_declarationsContext) IsList_of_port_declarationsContext() {}

func NewList_of_port_declarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_port_declarations

	return p
}

func (s *List_of_port_declarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_declarationsContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *List_of_port_declarationsContext) AllPort_declaration() []IPort_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem())
	var tst = make([]IPort_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_declarationContext)
		}
	}

	return tst
}

func (s *List_of_port_declarationsContext) Port_declaration(i int) IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *List_of_port_declarationsContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *List_of_port_declarationsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_port_declarationsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_port_declarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_declarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_declarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_port_declarations(s)
	}
}

func (s *List_of_port_declarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_port_declarations(s)
	}
}

func (p *VerilogParser) List_of_port_declarations() (localctx IList_of_port_declarationsContext) {
	localctx = NewList_of_port_declarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, VerilogParserRULE_list_of_port_declarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(816)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(817)
			p.Port_declaration()
		}
		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(818)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(819)
				p.Port_declaration()
			}

			p.SetState(824)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(825)
			p.Match(VerilogParserRight_parenthes)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(827)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(828)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IPortContext is an interface to support dynamic dispatch.
type IPortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPortContext differentiates from other interfaces.
	IsPortContext()
}

type PortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPortContext() *PortContext {
	var p = new(PortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port
	return p
}

func (*PortContext) IsPortContext() {}

func NewPortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PortContext {
	var p = new(PortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port

	return p
}

func (s *PortContext) GetParser() antlr.Parser { return s.parser }

func (s *PortContext) Port_expression() IPort_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_expressionContext)
}

func (s *PortContext) Dot() antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, 0)
}

func (s *PortContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *PortContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *PortContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *PortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort(s)
	}
}

func (s *PortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort(s)
	}
}

func (p *VerilogParser) Port() (localctx IPortContext) {
	localctx = NewPortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, VerilogParserRULE_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(842)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserComma, VerilogParserRight_parenthes, VerilogParserLeft_brace, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_brace || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(831)
				p.Port_expression()
			}

		}

	case VerilogParserDot:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(834)
			p.Match(VerilogParserDot)
		}
		{
			p.SetState(835)
			p.Port_identifier()
		}
		{
			p.SetState(836)
			p.Match(VerilogParserLeft_parenthes)
		}
		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_brace || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(837)
				p.Port_expression()
			}

		}
		{
			p.SetState(840)
			p.Match(VerilogParserRight_parenthes)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPort_expressionContext is an interface to support dynamic dispatch.
type IPort_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_expressionContext differentiates from other interfaces.
	IsPort_expressionContext()
}

type Port_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_expressionContext() *Port_expressionContext {
	var p = new(Port_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_expression
	return p
}

func (*Port_expressionContext) IsPort_expressionContext() {}

func NewPort_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_expressionContext {
	var p = new(Port_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_expression

	return p
}

func (s *Port_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_expressionContext) AllPort_reference() []IPort_referenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_referenceContext)(nil)).Elem())
	var tst = make([]IPort_referenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_referenceContext)
		}
	}

	return tst
}

func (s *Port_expressionContext) Port_reference(i int) IPort_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_referenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_referenceContext)
}

func (s *Port_expressionContext) Left_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_brace, 0)
}

func (s *Port_expressionContext) Right_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_brace, 0)
}

func (s *Port_expressionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Port_expressionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Port_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort_expression(s)
	}
}

func (s *Port_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort_expression(s)
	}
}

func (p *VerilogParser) Port_expression() (localctx IPort_expressionContext) {
	localctx = NewPort_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, VerilogParserRULE_port_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(856)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(844)
			p.Port_reference()
		}

	case VerilogParserLeft_brace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(845)
			p.Match(VerilogParserLeft_brace)
		}
		{
			p.SetState(846)
			p.Port_reference()
		}
		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(847)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(848)
				p.Port_reference()
			}

			p.SetState(853)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(854)
			p.Match(VerilogParserRight_brace)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPort_referenceContext is an interface to support dynamic dispatch.
type IPort_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_referenceContext differentiates from other interfaces.
	IsPort_referenceContext()
}

type Port_referenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_referenceContext() *Port_referenceContext {
	var p = new(Port_referenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_reference
	return p
}

func (*Port_referenceContext) IsPort_referenceContext() {}

func NewPort_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_referenceContext {
	var p = new(Port_referenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_reference

	return p
}

func (s *Port_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_referenceContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Port_referenceContext) Left_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, 0)
}

func (s *Port_referenceContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Port_referenceContext) Right_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, 0)
}

func (s *Port_referenceContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Port_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort_reference(s)
	}
}

func (s *Port_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort_reference(s)
	}
}

func (p *VerilogParser) Port_reference() (localctx IPort_referenceContext) {
	localctx = NewPort_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, VerilogParserRULE_port_reference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(869)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(858)
			p.Port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(859)
			p.Port_identifier()
		}
		{
			p.SetState(860)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(861)
			p.Constant_expression()
		}
		{
			p.SetState(862)
			p.Match(VerilogParserRight_bracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(864)
			p.Port_identifier()
		}
		{
			p.SetState(865)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(866)
			p.Range_expression()
		}
		{
			p.SetState(867)
			p.Match(VerilogParserRight_bracket)
		}

	}

	return localctx
}

// IPort_declarationContext is an interface to support dynamic dispatch.
type IPort_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_declarationContext differentiates from other interfaces.
	IsPort_declarationContext()
}

type Port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_declarationContext() *Port_declarationContext {
	var p = new(Port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_declaration
	return p
}

func (*Port_declarationContext) IsPort_declarationContext() {}

func NewPort_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_declarationContext {
	var p = new(Port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_declaration

	return p
}

func (s *Port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_declarationContext) Inout_declaration() IInout_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_declarationContext)
}

func (s *Port_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Port_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Port_declarationContext) Input_declaration() IInput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_declarationContext)
}

func (s *Port_declarationContext) Output_declaration() IOutput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_declarationContext)
}

func (s *Port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort_declaration(s)
	}
}

func (s *Port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort_declaration(s)
	}
}

func (p *VerilogParser) Port_declaration() (localctx IPort_declarationContext) {
	localctx = NewPort_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, VerilogParserRULE_port_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(871)
				p.Attribute_instance()
			}

			p.SetState(876)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(877)
			p.Inout_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(878)
				p.Attribute_instance()
			}

			p.SetState(883)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(884)
			p.Input_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(885)
				p.Attribute_instance()
			}

			p.SetState(890)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(891)
			p.Output_declaration()
		}

	}

	return localctx
}

// IModule_itemContext is an interface to support dynamic dispatch.
type IModule_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_itemContext differentiates from other interfaces.
	IsModule_itemContext()
}

type Module_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_itemContext() *Module_itemContext {
	var p = new(Module_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_item
	return p
}

func (*Module_itemContext) IsModule_itemContext() {}

func NewModule_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_itemContext {
	var p = new(Module_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_item

	return p
}

func (s *Module_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_itemContext) Module_or_generate_item() IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Module_itemContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Module_itemContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Module_itemContext) Generated_instantiation() IGenerated_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerated_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerated_instantiationContext)
}

func (s *Module_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_itemContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Module_itemContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Module_itemContext) Specify_block() ISpecify_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_blockContext)
}

func (s *Module_itemContext) Specparam_declaration() ISpecparam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_declarationContext)
}

func (s *Module_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_item(s)
	}
}

func (s *Module_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_item(s)
	}
}

func (p *VerilogParser) Module_item() (localctx IModule_itemContext) {
	localctx = NewModule_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, VerilogParserRULE_module_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(933)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(894)
			p.Module_or_generate_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(895)
			p.Port_declaration()
		}
		{
			p.SetState(896)
			p.Match(VerilogParserSemicolon)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(898)
				p.Attribute_instance()
			}

			p.SetState(903)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(904)
			p.Generated_instantiation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(905)
				p.Attribute_instance()
			}

			p.SetState(910)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(911)
			p.Local_parameter_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(912)
				p.Attribute_instance()
			}

			p.SetState(917)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(918)
			p.Parameter_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(919)
				p.Attribute_instance()
			}

			p.SetState(924)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(925)
			p.Specify_block()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(926)
				p.Attribute_instance()
			}

			p.SetState(931)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(932)
			p.Specparam_declaration()
		}

	}

	return localctx
}

// IModule_or_generate_itemContext is an interface to support dynamic dispatch.
type IModule_or_generate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_or_generate_itemContext differentiates from other interfaces.
	IsModule_or_generate_itemContext()
}

type Module_or_generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_or_generate_itemContext() *Module_or_generate_itemContext {
	var p = new(Module_or_generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_or_generate_item
	return p
}

func (*Module_or_generate_itemContext) IsModule_or_generate_itemContext() {}

func NewModule_or_generate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_or_generate_itemContext {
	var p = new(Module_or_generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_or_generate_item

	return p
}

func (s *Module_or_generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_or_generate_itemContext) Module_or_generate_item_declaration() IModule_or_generate_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_item_declarationContext)
}

func (s *Module_or_generate_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_or_generate_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_or_generate_itemContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Module_or_generate_itemContext) Parameter_override() IParameter_overrideContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_overrideContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_overrideContext)
}

func (s *Module_or_generate_itemContext) Continuous_assign() IContinuous_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinuous_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinuous_assignContext)
}

func (s *Module_or_generate_itemContext) Gate_instantiation() IGate_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instantiationContext)
}

func (s *Module_or_generate_itemContext) Module_instantiation() IModule_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instantiationContext)
}

func (s *Module_or_generate_itemContext) Initial_construct() IInitial_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitial_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitial_constructContext)
}

func (s *Module_or_generate_itemContext) Always_construct() IAlways_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlways_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlways_constructContext)
}

func (s *Module_or_generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_or_generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_or_generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_or_generate_item(s)
	}
}

func (s *Module_or_generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_or_generate_item(s)
	}
}

func (p *VerilogParser) Module_or_generate_item() (localctx IModule_or_generate_itemContext) {
	localctx = NewModule_or_generate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, VerilogParserRULE_module_or_generate_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(938)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(935)
				p.Attribute_instance()
			}

			p.SetState(940)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(941)
			p.Module_or_generate_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(942)
				p.Attribute_instance()
			}

			p.SetState(947)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(948)
			p.Local_parameter_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(952)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(949)
				p.Attribute_instance()
			}

			p.SetState(954)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(955)
			p.Parameter_override()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(956)
				p.Attribute_instance()
			}

			p.SetState(961)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(962)
			p.Continuous_assign()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(966)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(963)
				p.Attribute_instance()
			}

			p.SetState(968)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(969)
			p.Gate_instantiation()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(973)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(970)
				p.Attribute_instance()
			}

			p.SetState(975)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(976)
			p.Module_instantiation()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(980)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(977)
				p.Attribute_instance()
			}

			p.SetState(982)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(983)
			p.Initial_construct()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(987)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(984)
				p.Attribute_instance()
			}

			p.SetState(989)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(990)
			p.Always_construct()
		}

	}

	return localctx
}

// IModule_or_generate_item_declarationContext is an interface to support dynamic dispatch.
type IModule_or_generate_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_or_generate_item_declarationContext differentiates from other interfaces.
	IsModule_or_generate_item_declarationContext()
}

type Module_or_generate_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_or_generate_item_declarationContext() *Module_or_generate_item_declarationContext {
	var p = new(Module_or_generate_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_or_generate_item_declaration
	return p
}

func (*Module_or_generate_item_declarationContext) IsModule_or_generate_item_declarationContext() {}

func NewModule_or_generate_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_or_generate_item_declarationContext {
	var p = new(Module_or_generate_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_or_generate_item_declaration

	return p
}

func (s *Module_or_generate_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_or_generate_item_declarationContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Reg_declaration() IReg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReg_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Realtime_declaration() IRealtime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealtime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealtime_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Event_declaration() IEvent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Genvar_declaration() IGenvar_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Task_declaration() ITask_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_or_generate_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_or_generate_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_or_generate_item_declaration(s)
	}
}

func (s *Module_or_generate_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_or_generate_item_declaration(s)
	}
}

func (p *VerilogParser) Module_or_generate_item_declaration() (localctx IModule_or_generate_item_declarationContext) {
	localctx = NewModule_or_generate_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, VerilogParserRULE_module_or_generate_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1003)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_supply0, VerilogParserK_supply1, VerilogParserK_tri, VerilogParserK_tri0, VerilogParserK_tri1, VerilogParserK_triand, VerilogParserK_trior, VerilogParserK_trireg, VerilogParserK_wand, VerilogParserK_wire, VerilogParserK_wor:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(993)
			p.Net_declaration()
		}

	case VerilogParserK_reg:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(994)
			p.Reg_declaration()
		}

	case VerilogParserK_integer:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(995)
			p.Integer_declaration()
		}

	case VerilogParserK_real:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(996)
			p.Real_declaration()
		}

	case VerilogParserK_time:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(997)
			p.Time_declaration()
		}

	case VerilogParserK_realtime:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(998)
			p.Realtime_declaration()
		}

	case VerilogParserK_event:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(999)
			p.Event_declaration()
		}

	case VerilogParserK_genvar:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1000)
			p.Genvar_declaration()
		}

	case VerilogParserK_task:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1001)
			p.Task_declaration()
		}

	case VerilogParserK_function:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1002)
			p.Function_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParameter_overrideContext is an interface to support dynamic dispatch.
type IParameter_overrideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_overrideContext differentiates from other interfaces.
	IsParameter_overrideContext()
}

type Parameter_overrideContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_overrideContext() *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_override
	return p
}

func (*Parameter_overrideContext) IsParameter_overrideContext() {}

func NewParameter_overrideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_override

	return p
}

func (s *Parameter_overrideContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_overrideContext) K_defparam() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_defparam, 0)
}

func (s *Parameter_overrideContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Parameter_overrideContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Parameter_overrideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_overrideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_overrideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_override(s)
	}
}

func (s *Parameter_overrideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_override(s)
	}
}

func (p *VerilogParser) Parameter_override() (localctx IParameter_overrideContext) {
	localctx = NewParameter_overrideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, VerilogParserRULE_parameter_override)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1005)
		p.Match(VerilogParserK_defparam)
	}
	{
		p.SetState(1006)
		p.List_of_param_assignments()
	}
	{
		p.SetState(1007)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// ILocal_parameter_declarationContext is an interface to support dynamic dispatch.
type ILocal_parameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocal_parameter_declarationContext differentiates from other interfaces.
	IsLocal_parameter_declarationContext()
}

type Local_parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocal_parameter_declarationContext() *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_local_parameter_declaration
	return p
}

func (*Local_parameter_declarationContext) IsLocal_parameter_declarationContext() {}

func NewLocal_parameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_local_parameter_declaration

	return p
}

func (s *Local_parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Local_parameter_declarationContext) K_localparam() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_localparam, 0)
}

func (s *Local_parameter_declarationContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Local_parameter_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Local_parameter_declarationContext) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Local_parameter_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Local_parameter_declarationContext) K_integer() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_integer, 0)
}

func (s *Local_parameter_declarationContext) K_real() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_real, 0)
}

func (s *Local_parameter_declarationContext) K_realtime() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_realtime, 0)
}

func (s *Local_parameter_declarationContext) K_time() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_time, 0)
}

func (s *Local_parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Local_parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Local_parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLocal_parameter_declaration(s)
	}
}

func (s *Local_parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLocal_parameter_declaration(s)
	}
}

func (p *VerilogParser) Local_parameter_declaration() (localctx ILocal_parameter_declarationContext) {
	localctx = NewLocal_parameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, VerilogParserRULE_local_parameter_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1009)
			p.Match(VerilogParserK_localparam)
		}
		p.SetState(1011)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1010)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1014)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_bracket {
			{
				p.SetState(1013)
				p.Range_()
			}

		}
		{
			p.SetState(1016)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1017)
			p.Match(VerilogParserSemicolon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1019)
			p.Match(VerilogParserK_localparam)
		}
		{
			p.SetState(1020)
			p.Match(VerilogParserK_integer)
		}
		{
			p.SetState(1021)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1022)
			p.Match(VerilogParserSemicolon)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1024)
			p.Match(VerilogParserK_localparam)
		}
		{
			p.SetState(1025)
			p.Match(VerilogParserK_real)
		}
		{
			p.SetState(1026)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1027)
			p.Match(VerilogParserSemicolon)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1029)
			p.Match(VerilogParserK_localparam)
		}
		{
			p.SetState(1030)
			p.Match(VerilogParserK_realtime)
		}
		{
			p.SetState(1031)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1032)
			p.Match(VerilogParserSemicolon)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1034)
			p.Match(VerilogParserK_localparam)
		}
		{
			p.SetState(1035)
			p.Match(VerilogParserK_time)
		}
		{
			p.SetState(1036)
			p.List_of_param_assignments()
		}
		{
			p.SetState(1037)
			p.Match(VerilogParserSemicolon)
		}

	}

	return localctx
}

// IParameter_declarationContext is an interface to support dynamic dispatch.
type IParameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declarationContext differentiates from other interfaces.
	IsParameter_declarationContext()
}

type Parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declarationContext() *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_declaration
	return p
}

func (*Parameter_declarationContext) IsParameter_declarationContext() {}

func NewParameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_declaration

	return p
}

func (s *Parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declarationContext) Parameter_declaration_() IParameter_declaration_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_Context)
}

func (s *Parameter_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_declaration(s)
	}
}

func (p *VerilogParser) Parameter_declaration() (localctx IParameter_declarationContext) {
	localctx = NewParameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, VerilogParserRULE_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1041)
		p.Parameter_declaration_()
	}
	{
		p.SetState(1042)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IParameter_declaration_Context is an interface to support dynamic dispatch.
type IParameter_declaration_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declaration_Context differentiates from other interfaces.
	IsParameter_declaration_Context()
}

type Parameter_declaration_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declaration_Context() *Parameter_declaration_Context {
	var p = new(Parameter_declaration_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_declaration_
	return p
}

func (*Parameter_declaration_Context) IsParameter_declaration_Context() {}

func NewParameter_declaration_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declaration_Context {
	var p = new(Parameter_declaration_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_declaration_

	return p
}

func (s *Parameter_declaration_Context) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declaration_Context) K_parameter() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_parameter, 0)
}

func (s *Parameter_declaration_Context) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Parameter_declaration_Context) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Parameter_declaration_Context) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Parameter_declaration_Context) K_integer() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_integer, 0)
}

func (s *Parameter_declaration_Context) K_real() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_real, 0)
}

func (s *Parameter_declaration_Context) K_realtime() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_realtime, 0)
}

func (s *Parameter_declaration_Context) K_time() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_time, 0)
}

func (s *Parameter_declaration_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declaration_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declaration_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_declaration_(s)
	}
}

func (s *Parameter_declaration_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_declaration_(s)
	}
}

func (p *VerilogParser) Parameter_declaration_() (localctx IParameter_declaration_Context) {
	localctx = NewParameter_declaration_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, VerilogParserRULE_parameter_declaration_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1044)
			p.Match(VerilogParserK_parameter)
		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1045)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_bracket {
			{
				p.SetState(1048)
				p.Range_()
			}

		}
		{
			p.SetState(1051)
			p.List_of_param_assignments()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1052)
			p.Match(VerilogParserK_parameter)
		}
		{
			p.SetState(1053)
			p.Match(VerilogParserK_integer)
		}
		{
			p.SetState(1054)
			p.List_of_param_assignments()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1055)
			p.Match(VerilogParserK_parameter)
		}
		{
			p.SetState(1056)
			p.Match(VerilogParserK_real)
		}
		{
			p.SetState(1057)
			p.List_of_param_assignments()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1058)
			p.Match(VerilogParserK_parameter)
		}
		{
			p.SetState(1059)
			p.Match(VerilogParserK_realtime)
		}
		{
			p.SetState(1060)
			p.List_of_param_assignments()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1061)
			p.Match(VerilogParserK_parameter)
		}
		{
			p.SetState(1062)
			p.Match(VerilogParserK_time)
		}
		{
			p.SetState(1063)
			p.List_of_param_assignments()
		}

	}

	return localctx
}

// ISpecparam_declarationContext is an interface to support dynamic dispatch.
type ISpecparam_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_declarationContext differentiates from other interfaces.
	IsSpecparam_declarationContext()
}

type Specparam_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_declarationContext() *Specparam_declarationContext {
	var p = new(Specparam_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specparam_declaration
	return p
}

func (*Specparam_declarationContext) IsSpecparam_declarationContext() {}

func NewSpecparam_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_declarationContext {
	var p = new(Specparam_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specparam_declaration

	return p
}

func (s *Specparam_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_declarationContext) K_specparam() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_specparam, 0)
}

func (s *Specparam_declarationContext) List_of_specparam_assignments() IList_of_specparam_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_specparam_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_specparam_assignmentsContext)
}

func (s *Specparam_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Specparam_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Specparam_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecparam_declaration(s)
	}
}

func (s *Specparam_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecparam_declaration(s)
	}
}

func (p *VerilogParser) Specparam_declaration() (localctx ISpecparam_declarationContext) {
	localctx = NewSpecparam_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, VerilogParserRULE_specparam_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1066)
		p.Match(VerilogParserK_specparam)
	}
	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_bracket {
		{
			p.SetState(1067)
			p.Range_()
		}

	}
	{
		p.SetState(1070)
		p.List_of_specparam_assignments()
	}
	{
		p.SetState(1071)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IInout_declarationContext is an interface to support dynamic dispatch.
type IInout_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_declarationContext differentiates from other interfaces.
	IsInout_declarationContext()
}

type Inout_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_declarationContext() *Inout_declarationContext {
	var p = new(Inout_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inout_declaration
	return p
}

func (*Inout_declarationContext) IsInout_declarationContext() {}

func NewInout_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_declarationContext {
	var p = new(Inout_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inout_declaration

	return p
}

func (s *Inout_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_declarationContext) K_inout() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_inout, 0)
}

func (s *Inout_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Inout_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Inout_declarationContext) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Inout_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Inout_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInout_declaration(s)
	}
}

func (s *Inout_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInout_declaration(s)
	}
}

func (p *VerilogParser) Inout_declaration() (localctx IInout_declarationContext) {
	localctx = NewInout_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, VerilogParserRULE_inout_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		p.Match(VerilogParserK_inout)
	}
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(VerilogParserK_supply0-104))|(1<<(VerilogParserK_supply1-104))|(1<<(VerilogParserK_tri-104))|(1<<(VerilogParserK_tri0-104))|(1<<(VerilogParserK_tri1-104))|(1<<(VerilogParserK_triand-104))|(1<<(VerilogParserK_trior-104))|(1<<(VerilogParserK_wand-104))|(1<<(VerilogParserK_wire-104))|(1<<(VerilogParserK_wor-104)))) != 0 {
		{
			p.SetState(1074)
			p.Net_type()
		}

	}
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_signed {
		{
			p.SetState(1077)
			p.Match(VerilogParserK_signed)
		}

	}
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_bracket {
		{
			p.SetState(1080)
			p.Range_()
		}

	}
	{
		p.SetState(1083)
		p.List_of_port_identifiers()
	}

	return localctx
}

// IInput_declarationContext is an interface to support dynamic dispatch.
type IInput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_declarationContext differentiates from other interfaces.
	IsInput_declarationContext()
}

type Input_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_declarationContext() *Input_declarationContext {
	var p = new(Input_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_declaration
	return p
}

func (*Input_declarationContext) IsInput_declarationContext() {}

func NewInput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_declarationContext {
	var p = new(Input_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_declaration

	return p
}

func (s *Input_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_declarationContext) K_input() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_input, 0)
}

func (s *Input_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Input_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Input_declarationContext) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Input_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Input_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInput_declaration(s)
	}
}

func (s *Input_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInput_declaration(s)
	}
}

func (p *VerilogParser) Input_declaration() (localctx IInput_declarationContext) {
	localctx = NewInput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, VerilogParserRULE_input_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.Match(VerilogParserK_input)
	}
	p.SetState(1087)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(VerilogParserK_supply0-104))|(1<<(VerilogParserK_supply1-104))|(1<<(VerilogParserK_tri-104))|(1<<(VerilogParserK_tri0-104))|(1<<(VerilogParserK_tri1-104))|(1<<(VerilogParserK_triand-104))|(1<<(VerilogParserK_trior-104))|(1<<(VerilogParserK_wand-104))|(1<<(VerilogParserK_wire-104))|(1<<(VerilogParserK_wor-104)))) != 0 {
		{
			p.SetState(1086)
			p.Net_type()
		}

	}
	p.SetState(1090)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_signed {
		{
			p.SetState(1089)
			p.Match(VerilogParserK_signed)
		}

	}
	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_bracket {
		{
			p.SetState(1092)
			p.Range_()
		}

	}
	{
		p.SetState(1095)
		p.List_of_port_identifiers()
	}

	return localctx
}

// IOutput_declarationContext is an interface to support dynamic dispatch.
type IOutput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_declarationContext differentiates from other interfaces.
	IsOutput_declarationContext()
}

type Output_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_declarationContext() *Output_declarationContext {
	var p = new(Output_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_declaration
	return p
}

func (*Output_declarationContext) IsOutput_declarationContext() {}

func NewOutput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_declarationContext {
	var p = new(Output_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_declaration

	return p
}

func (s *Output_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_declarationContext) K_output() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_output, 0)
}

func (s *Output_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Output_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Output_declarationContext) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Output_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Output_declarationContext) K_reg() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_reg, 0)
}

func (s *Output_declarationContext) List_of_variable_port_identifiers() IList_of_variable_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_port_identifiersContext)
}

func (s *Output_declarationContext) Output_variable_type() IOutput_variable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_variable_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_variable_typeContext)
}

func (s *Output_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_declaration(s)
	}
}

func (s *Output_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_declaration(s)
	}
}

func (p *VerilogParser) Output_declaration() (localctx IOutput_declarationContext) {
	localctx = NewOutput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, VerilogParserRULE_output_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1097)
			p.Match(VerilogParserK_output)
		}
		p.SetState(1099)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(VerilogParserK_supply0-104))|(1<<(VerilogParserK_supply1-104))|(1<<(VerilogParserK_tri-104))|(1<<(VerilogParserK_tri0-104))|(1<<(VerilogParserK_tri1-104))|(1<<(VerilogParserK_triand-104))|(1<<(VerilogParserK_trior-104))|(1<<(VerilogParserK_wand-104))|(1<<(VerilogParserK_wire-104))|(1<<(VerilogParserK_wor-104)))) != 0 {
			{
				p.SetState(1098)
				p.Net_type()
			}

		}
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1101)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1105)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_bracket {
			{
				p.SetState(1104)
				p.Range_()
			}

		}
		{
			p.SetState(1107)
			p.List_of_port_identifiers()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1108)
			p.Match(VerilogParserK_output)
		}
		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_reg {
			{
				p.SetState(1109)
				p.Match(VerilogParserK_reg)
			}

		}
		p.SetState(1113)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1112)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_bracket {
			{
				p.SetState(1115)
				p.Range_()
			}

		}
		{
			p.SetState(1118)
			p.List_of_port_identifiers()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1119)
			p.Match(VerilogParserK_output)
		}
		{
			p.SetState(1120)
			p.Match(VerilogParserK_reg)
		}
		p.SetState(1122)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1121)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_bracket {
			{
				p.SetState(1124)
				p.Range_()
			}

		}
		{
			p.SetState(1127)
			p.List_of_variable_port_identifiers()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1128)
			p.Match(VerilogParserK_output)
		}
		p.SetState(1130)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_integer || _la == VerilogParserK_time {
			{
				p.SetState(1129)
				p.Output_variable_type()
			}

		}
		{
			p.SetState(1132)
			p.List_of_port_identifiers()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1133)
			p.Match(VerilogParserK_output)
		}
		{
			p.SetState(1134)
			p.Output_variable_type()
		}
		{
			p.SetState(1135)
			p.List_of_variable_port_identifiers()
		}

	}

	return localctx
}

// IEvent_declarationContext is an interface to support dynamic dispatch.
type IEvent_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_declarationContext differentiates from other interfaces.
	IsEvent_declarationContext()
}

type Event_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_declarationContext() *Event_declarationContext {
	var p = new(Event_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_declaration
	return p
}

func (*Event_declarationContext) IsEvent_declarationContext() {}

func NewEvent_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_declarationContext {
	var p = new(Event_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_declaration

	return p
}

func (s *Event_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_declarationContext) K_event() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_event, 0)
}

func (s *Event_declarationContext) List_of_event_identifiers() IList_of_event_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_event_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_event_identifiersContext)
}

func (s *Event_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Event_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_declaration(s)
	}
}

func (s *Event_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_declaration(s)
	}
}

func (p *VerilogParser) Event_declaration() (localctx IEvent_declarationContext) {
	localctx = NewEvent_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, VerilogParserRULE_event_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1139)
		p.Match(VerilogParserK_event)
	}
	{
		p.SetState(1140)
		p.List_of_event_identifiers()
	}
	{
		p.SetState(1141)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IGenvar_declarationContext is an interface to support dynamic dispatch.
type IGenvar_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_declarationContext differentiates from other interfaces.
	IsGenvar_declarationContext()
}

type Genvar_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_declarationContext() *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_declaration
	return p
}

func (*Genvar_declarationContext) IsGenvar_declarationContext() {}

func NewGenvar_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_declaration

	return p
}

func (s *Genvar_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_declarationContext) K_genvar() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_genvar, 0)
}

func (s *Genvar_declarationContext) List_of_genvar_identifiers() IList_of_genvar_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_genvar_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_genvar_identifiersContext)
}

func (s *Genvar_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Genvar_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_declaration(s)
	}
}

func (s *Genvar_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_declaration(s)
	}
}

func (p *VerilogParser) Genvar_declaration() (localctx IGenvar_declarationContext) {
	localctx = NewGenvar_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, VerilogParserRULE_genvar_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1143)
		p.Match(VerilogParserK_genvar)
	}
	{
		p.SetState(1144)
		p.List_of_genvar_identifiers()
	}
	{
		p.SetState(1145)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IInteger_declarationContext is an interface to support dynamic dispatch.
type IInteger_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_declarationContext differentiates from other interfaces.
	IsInteger_declarationContext()
}

type Integer_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_declarationContext() *Integer_declarationContext {
	var p = new(Integer_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_integer_declaration
	return p
}

func (*Integer_declarationContext) IsInteger_declarationContext() {}

func NewInteger_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_declarationContext {
	var p = new(Integer_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_integer_declaration

	return p
}

func (s *Integer_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_declarationContext) K_integer() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_integer, 0)
}

func (s *Integer_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Integer_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Integer_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInteger_declaration(s)
	}
}

func (s *Integer_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInteger_declaration(s)
	}
}

func (p *VerilogParser) Integer_declaration() (localctx IInteger_declarationContext) {
	localctx = NewInteger_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, VerilogParserRULE_integer_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1147)
		p.Match(VerilogParserK_integer)
	}
	{
		p.SetState(1148)
		p.List_of_variable_identifiers()
	}
	{
		p.SetState(1149)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// ITime_declarationContext is an interface to support dynamic dispatch.
type ITime_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTime_declarationContext differentiates from other interfaces.
	IsTime_declarationContext()
}

type Time_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTime_declarationContext() *Time_declarationContext {
	var p = new(Time_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_time_declaration
	return p
}

func (*Time_declarationContext) IsTime_declarationContext() {}

func NewTime_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Time_declarationContext {
	var p = new(Time_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_time_declaration

	return p
}

func (s *Time_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Time_declarationContext) K_time() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_time, 0)
}

func (s *Time_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Time_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Time_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Time_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Time_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTime_declaration(s)
	}
}

func (s *Time_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTime_declaration(s)
	}
}

func (p *VerilogParser) Time_declaration() (localctx ITime_declarationContext) {
	localctx = NewTime_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, VerilogParserRULE_time_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1151)
		p.Match(VerilogParserK_time)
	}
	{
		p.SetState(1152)
		p.List_of_variable_identifiers()
	}
	{
		p.SetState(1153)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IReal_declarationContext is an interface to support dynamic dispatch.
type IReal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_declarationContext differentiates from other interfaces.
	IsReal_declarationContext()
}

type Real_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_declarationContext() *Real_declarationContext {
	var p = new(Real_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_declaration
	return p
}

func (*Real_declarationContext) IsReal_declarationContext() {}

func NewReal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_declarationContext {
	var p = new(Real_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_declaration

	return p
}

func (s *Real_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_declarationContext) K_real() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_real, 0)
}

func (s *Real_declarationContext) List_of_real_identifiers() IList_of_real_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_real_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_real_identifiersContext)
}

func (s *Real_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Real_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReal_declaration(s)
	}
}

func (s *Real_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReal_declaration(s)
	}
}

func (p *VerilogParser) Real_declaration() (localctx IReal_declarationContext) {
	localctx = NewReal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, VerilogParserRULE_real_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1155)
		p.Match(VerilogParserK_real)
	}
	{
		p.SetState(1156)
		p.List_of_real_identifiers()
	}
	{
		p.SetState(1157)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IRealtime_declarationContext is an interface to support dynamic dispatch.
type IRealtime_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRealtime_declarationContext differentiates from other interfaces.
	IsRealtime_declarationContext()
}

type Realtime_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealtime_declarationContext() *Realtime_declarationContext {
	var p = new(Realtime_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_realtime_declaration
	return p
}

func (*Realtime_declarationContext) IsRealtime_declarationContext() {}

func NewRealtime_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Realtime_declarationContext {
	var p = new(Realtime_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_realtime_declaration

	return p
}

func (s *Realtime_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Realtime_declarationContext) K_realtime() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_realtime, 0)
}

func (s *Realtime_declarationContext) List_of_real_identifiers() IList_of_real_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_real_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_real_identifiersContext)
}

func (s *Realtime_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Realtime_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Realtime_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Realtime_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRealtime_declaration(s)
	}
}

func (s *Realtime_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRealtime_declaration(s)
	}
}

func (p *VerilogParser) Realtime_declaration() (localctx IRealtime_declarationContext) {
	localctx = NewRealtime_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, VerilogParserRULE_realtime_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1159)
		p.Match(VerilogParserK_realtime)
	}
	{
		p.SetState(1160)
		p.List_of_real_identifiers()
	}
	{
		p.SetState(1161)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IReg_declarationContext is an interface to support dynamic dispatch.
type IReg_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReg_declarationContext differentiates from other interfaces.
	IsReg_declarationContext()
}

type Reg_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReg_declarationContext() *Reg_declarationContext {
	var p = new(Reg_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_reg_declaration
	return p
}

func (*Reg_declarationContext) IsReg_declarationContext() {}

func NewReg_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reg_declarationContext {
	var p = new(Reg_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_reg_declaration

	return p
}

func (s *Reg_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Reg_declarationContext) K_reg() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_reg, 0)
}

func (s *Reg_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Reg_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Reg_declarationContext) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Reg_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Reg_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reg_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reg_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReg_declaration(s)
	}
}

func (s *Reg_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReg_declaration(s)
	}
}

func (p *VerilogParser) Reg_declaration() (localctx IReg_declarationContext) {
	localctx = NewReg_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, VerilogParserRULE_reg_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1163)
		p.Match(VerilogParserK_reg)
	}
	p.SetState(1165)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_signed {
		{
			p.SetState(1164)
			p.Match(VerilogParserK_signed)
		}

	}
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_bracket {
		{
			p.SetState(1167)
			p.Range_()
		}

	}
	{
		p.SetState(1170)
		p.List_of_variable_identifiers()
	}
	{
		p.SetState(1171)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// INet_declarationContext is an interface to support dynamic dispatch.
type INet_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_declarationContext differentiates from other interfaces.
	IsNet_declarationContext()
}

type Net_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_declarationContext() *Net_declarationContext {
	var p = new(Net_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_declaration
	return p
}

func (*Net_declarationContext) IsNet_declarationContext() {}

func NewNet_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_declarationContext {
	var p = new(Net_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_declaration

	return p
}

func (s *Net_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Net_declarationContext) List_of_net_identifiers() IList_of_net_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_identifiersContext)
}

func (s *Net_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Net_declarationContext) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Net_declarationContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Net_declarationContext) List_of_net_decl_assignments() IList_of_net_decl_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_decl_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_decl_assignmentsContext)
}

func (s *Net_declarationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Net_declarationContext) K_trireg() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_trireg, 0)
}

func (s *Net_declarationContext) Charge_strength() ICharge_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharge_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharge_strengthContext)
}

func (s *Net_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Net_declarationContext) K_vectored() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_vectored, 0)
}

func (s *Net_declarationContext) K_scalared() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_scalared, 0)
}

func (s *Net_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_declaration(s)
	}
}

func (s *Net_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_declaration(s)
	}
}

func (p *VerilogParser) Net_declaration() (localctx INet_declarationContext) {
	localctx = NewNet_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, VerilogParserRULE_net_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1287)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1173)
			p.Net_type()
		}
		p.SetState(1175)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1174)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1178)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1177)
				p.Delay3()
			}

		}
		{
			p.SetState(1180)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1181)
			p.Match(VerilogParserSemicolon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1183)
			p.Net_type()
		}
		p.SetState(1185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_highz0 || _la == VerilogParserK_highz1 || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserK_pull0-79))|(1<<(VerilogParserK_pull1-79))|(1<<(VerilogParserK_strong0-79))|(1<<(VerilogParserK_strong1-79))|(1<<(VerilogParserK_supply0-79))|(1<<(VerilogParserK_supply1-79)))) != 0) || _la == VerilogParserK_weak0 || _la == VerilogParserK_weak1 {
			{
				p.SetState(1184)
				p.Drive_strength()
			}

		}
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1187)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1190)
				p.Delay3()
			}

		}
		{
			p.SetState(1193)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1194)
			p.Match(VerilogParserSemicolon)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1196)
			p.Match(VerilogParserK_trireg)
		}
		p.SetState(1198)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_highz0 || _la == VerilogParserK_highz1 || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserK_pull0-79))|(1<<(VerilogParserK_pull1-79))|(1<<(VerilogParserK_strong0-79))|(1<<(VerilogParserK_strong1-79))|(1<<(VerilogParserK_supply0-79))|(1<<(VerilogParserK_supply1-79)))) != 0) || _la == VerilogParserK_weak0 || _la == VerilogParserK_weak1 {
			{
				p.SetState(1197)
				p.Drive_strength()
			}

		}
		p.SetState(1201)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1200)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1203)
				p.Delay3()
			}

		}
		{
			p.SetState(1206)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1207)
			p.Match(VerilogParserSemicolon)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1209)
			p.Match(VerilogParserK_trireg)
		}
		p.SetState(1211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1210)
				p.Charge_strength()
			}

		}
		p.SetState(1214)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1213)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1216)
				p.Delay3()
			}

		}
		{
			p.SetState(1219)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1220)
			p.Match(VerilogParserSemicolon)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1222)
			p.Match(VerilogParserK_trireg)
		}
		p.SetState(1224)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1223)
				p.Charge_strength()
			}

		}
		p.SetState(1227)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_scalared || _la == VerilogParserK_vectored {
			{
				p.SetState(1226)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserK_scalared || _la == VerilogParserK_vectored) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1229)
				p.Match(VerilogParserK_signed)
			}

		}
		{
			p.SetState(1232)
			p.Range_()
		}
		p.SetState(1234)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1233)
				p.Delay3()
			}

		}
		{
			p.SetState(1236)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1237)
			p.Match(VerilogParserSemicolon)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1239)
			p.Match(VerilogParserK_trireg)
		}
		p.SetState(1241)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_highz0 || _la == VerilogParserK_highz1 || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserK_pull0-79))|(1<<(VerilogParserK_pull1-79))|(1<<(VerilogParserK_strong0-79))|(1<<(VerilogParserK_strong1-79))|(1<<(VerilogParserK_supply0-79))|(1<<(VerilogParserK_supply1-79)))) != 0) || _la == VerilogParserK_weak0 || _la == VerilogParserK_weak1 {
			{
				p.SetState(1240)
				p.Drive_strength()
			}

		}
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_scalared || _la == VerilogParserK_vectored {
			{
				p.SetState(1243)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserK_scalared || _la == VerilogParserK_vectored) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1247)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1246)
				p.Match(VerilogParserK_signed)
			}

		}
		{
			p.SetState(1249)
			p.Range_()
		}
		p.SetState(1251)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1250)
				p.Delay3()
			}

		}
		{
			p.SetState(1253)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1254)
			p.Match(VerilogParserSemicolon)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1256)
			p.Net_type()
		}
		p.SetState(1258)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_highz0 || _la == VerilogParserK_highz1 || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserK_pull0-79))|(1<<(VerilogParserK_pull1-79))|(1<<(VerilogParserK_strong0-79))|(1<<(VerilogParserK_strong1-79))|(1<<(VerilogParserK_supply0-79))|(1<<(VerilogParserK_supply1-79)))) != 0) || _la == VerilogParserK_weak0 || _la == VerilogParserK_weak1 {
			{
				p.SetState(1257)
				p.Drive_strength()
			}

		}
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_scalared || _la == VerilogParserK_vectored {
			{
				p.SetState(1260)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserK_scalared || _la == VerilogParserK_vectored) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1264)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1263)
				p.Match(VerilogParserK_signed)
			}

		}
		{
			p.SetState(1266)
			p.Range_()
		}
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1267)
				p.Delay3()
			}

		}
		{
			p.SetState(1270)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(1271)
			p.Match(VerilogParserSemicolon)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1273)
			p.Net_type()
		}
		p.SetState(1275)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_scalared || _la == VerilogParserK_vectored {
			{
				p.SetState(1274)
				_la = p.GetTokenStream().LA(1)

				if !(_la == VerilogParserK_scalared || _la == VerilogParserK_vectored) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1278)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1277)
				p.Match(VerilogParserK_signed)
			}

		}
		{
			p.SetState(1280)
			p.Range_()
		}
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1281)
				p.Delay3()
			}

		}
		{
			p.SetState(1284)
			p.List_of_net_identifiers()
		}
		{
			p.SetState(1285)
			p.Match(VerilogParserSemicolon)
		}

	}

	return localctx
}

// INet_typeContext is an interface to support dynamic dispatch.
type INet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_typeContext differentiates from other interfaces.
	IsNet_typeContext()
}

type Net_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_typeContext() *Net_typeContext {
	var p = new(Net_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_type
	return p
}

func (*Net_typeContext) IsNet_typeContext() {}

func NewNet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_typeContext {
	var p = new(Net_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_type

	return p
}

func (s *Net_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_typeContext) K_supply0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_supply0, 0)
}

func (s *Net_typeContext) K_supply1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_supply1, 0)
}

func (s *Net_typeContext) K_tri() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_tri, 0)
}

func (s *Net_typeContext) K_triand() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_triand, 0)
}

func (s *Net_typeContext) K_trior() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_trior, 0)
}

func (s *Net_typeContext) K_tri0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_tri0, 0)
}

func (s *Net_typeContext) K_tri1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_tri1, 0)
}

func (s *Net_typeContext) K_wire() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_wire, 0)
}

func (s *Net_typeContext) K_wand() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_wand, 0)
}

func (s *Net_typeContext) K_wor() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_wor, 0)
}

func (s *Net_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_type(s)
	}
}

func (s *Net_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_type(s)
	}
}

func (p *VerilogParser) Net_type() (localctx INet_typeContext) {
	localctx = NewNet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, VerilogParserRULE_net_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1289)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(VerilogParserK_supply0-104))|(1<<(VerilogParserK_supply1-104))|(1<<(VerilogParserK_tri-104))|(1<<(VerilogParserK_tri0-104))|(1<<(VerilogParserK_tri1-104))|(1<<(VerilogParserK_triand-104))|(1<<(VerilogParserK_trior-104))|(1<<(VerilogParserK_wand-104))|(1<<(VerilogParserK_wire-104))|(1<<(VerilogParserK_wor-104)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOutput_variable_typeContext is an interface to support dynamic dispatch.
type IOutput_variable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_variable_typeContext differentiates from other interfaces.
	IsOutput_variable_typeContext()
}

type Output_variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_variable_typeContext() *Output_variable_typeContext {
	var p = new(Output_variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_variable_type
	return p
}

func (*Output_variable_typeContext) IsOutput_variable_typeContext() {}

func NewOutput_variable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_variable_typeContext {
	var p = new(Output_variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_variable_type

	return p
}

func (s *Output_variable_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_variable_typeContext) K_integer() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_integer, 0)
}

func (s *Output_variable_typeContext) K_time() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_time, 0)
}

func (s *Output_variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_variable_type(s)
	}
}

func (s *Output_variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_variable_type(s)
	}
}

func (p *VerilogParser) Output_variable_type() (localctx IOutput_variable_typeContext) {
	localctx = NewOutput_variable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, VerilogParserRULE_output_variable_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1291)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserK_integer || _la == VerilogParserK_time) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReal_typeContext is an interface to support dynamic dispatch.
type IReal_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_typeContext differentiates from other interfaces.
	IsReal_typeContext()
}

type Real_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_typeContext() *Real_typeContext {
	var p = new(Real_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_type
	return p
}

func (*Real_typeContext) IsReal_typeContext() {}

func NewReal_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_typeContext {
	var p = new(Real_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_type

	return p
}

func (s *Real_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_typeContext) Real_identifier() IReal_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_identifierContext)
}

func (s *Real_typeContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Real_typeContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Real_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Real_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Real_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReal_type(s)
	}
}

func (s *Real_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReal_type(s)
	}
}

func (p *VerilogParser) Real_type() (localctx IReal_typeContext) {
	localctx = NewReal_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, VerilogParserRULE_real_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1306)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1293)
			p.Real_identifier()
		}
		p.SetState(1296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEq {
			{
				p.SetState(1294)
				p.Match(VerilogParserEq)
			}
			{
				p.SetState(1295)
				p.Constant_expression()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1298)
			p.Real_identifier()
		}
		{
			p.SetState(1299)
			p.Dimension()
		}
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_bracket {
			{
				p.SetState(1300)
				p.Dimension()
			}

			p.SetState(1305)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IVariable_typeContext is an interface to support dynamic dispatch.
type IVariable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_typeContext differentiates from other interfaces.
	IsVariable_typeContext()
}

type Variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_typeContext() *Variable_typeContext {
	var p = new(Variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_type
	return p
}

func (*Variable_typeContext) IsVariable_typeContext() {}

func NewVariable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_typeContext {
	var p = new(Variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_type

	return p
}

func (s *Variable_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_typeContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Variable_typeContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Variable_typeContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Variable_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Variable_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_type(s)
	}
}

func (s *Variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_type(s)
	}
}

func (p *VerilogParser) Variable_type() (localctx IVariable_typeContext) {
	localctx = NewVariable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, VerilogParserRULE_variable_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1321)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1308)
			p.Variable_identifier()
		}
		p.SetState(1311)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEq {
			{
				p.SetState(1309)
				p.Match(VerilogParserEq)
			}
			{
				p.SetState(1310)
				p.Constant_expression()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1313)
			p.Variable_identifier()
		}
		{
			p.SetState(1314)
			p.Dimension()
		}
		p.SetState(1318)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_bracket {
			{
				p.SetState(1315)
				p.Dimension()
			}

			p.SetState(1320)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IDrive_strengthContext is an interface to support dynamic dispatch.
type IDrive_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrive_strengthContext differentiates from other interfaces.
	IsDrive_strengthContext()
}

type Drive_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrive_strengthContext() *Drive_strengthContext {
	var p = new(Drive_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_drive_strength
	return p
}

func (*Drive_strengthContext) IsDrive_strengthContext() {}

func NewDrive_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drive_strengthContext {
	var p = new(Drive_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_drive_strength

	return p
}

func (s *Drive_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Drive_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Drive_strengthContext) Comma() antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, 0)
}

func (s *Drive_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Drive_strengthContext) K_highz1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_highz1, 0)
}

func (s *Drive_strengthContext) K_highz0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_highz0, 0)
}

func (s *Drive_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drive_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drive_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDrive_strength(s)
	}
}

func (s *Drive_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDrive_strength(s)
	}
}

func (p *VerilogParser) Drive_strength() (localctx IDrive_strengthContext) {
	localctx = NewDrive_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, VerilogParserRULE_drive_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1345)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1323)
			p.Strength0()
		}
		{
			p.SetState(1324)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1325)
			p.Strength1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1327)
			p.Strength1()
		}
		{
			p.SetState(1328)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1329)
			p.Strength0()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1331)
			p.Strength0()
		}
		{
			p.SetState(1332)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1333)
			p.Match(VerilogParserK_highz1)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1335)
			p.Strength1()
		}
		{
			p.SetState(1336)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1337)
			p.Match(VerilogParserK_highz0)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1339)
			p.Match(VerilogParserK_highz0)
		}
		{
			p.SetState(1340)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1341)
			p.Strength1()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1342)
			p.Match(VerilogParserK_highz1)
		}
		{
			p.SetState(1343)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1344)
			p.Strength0()
		}

	}

	return localctx
}

// IStrength0Context is an interface to support dynamic dispatch.
type IStrength0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength0Context differentiates from other interfaces.
	IsStrength0Context()
}

type Strength0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength0Context() *Strength0Context {
	var p = new(Strength0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_strength0
	return p
}

func (*Strength0Context) IsStrength0Context() {}

func NewStrength0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength0Context {
	var p = new(Strength0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_strength0

	return p
}

func (s *Strength0Context) GetParser() antlr.Parser { return s.parser }

func (s *Strength0Context) K_supply0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_supply0, 0)
}

func (s *Strength0Context) K_strong0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_strong0, 0)
}

func (s *Strength0Context) K_pull0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_pull0, 0)
}

func (s *Strength0Context) K_weak0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_weak0, 0)
}

func (s *Strength0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStrength0(s)
	}
}

func (s *Strength0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStrength0(s)
	}
}

func (p *VerilogParser) Strength0() (localctx IStrength0Context) {
	localctx = NewStrength0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, VerilogParserRULE_strength0)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1347)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserK_pull0-79))|(1<<(VerilogParserK_strong0-79))|(1<<(VerilogParserK_supply0-79)))) != 0) || _la == VerilogParserK_weak0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStrength1Context is an interface to support dynamic dispatch.
type IStrength1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength1Context differentiates from other interfaces.
	IsStrength1Context()
}

type Strength1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength1Context() *Strength1Context {
	var p = new(Strength1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_strength1
	return p
}

func (*Strength1Context) IsStrength1Context() {}

func NewStrength1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength1Context {
	var p = new(Strength1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_strength1

	return p
}

func (s *Strength1Context) GetParser() antlr.Parser { return s.parser }

func (s *Strength1Context) K_supply1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_supply1, 0)
}

func (s *Strength1Context) K_strong1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_strong1, 0)
}

func (s *Strength1Context) K_pull1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_pull1, 0)
}

func (s *Strength1Context) K_weak1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_weak1, 0)
}

func (s *Strength1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStrength1(s)
	}
}

func (s *Strength1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStrength1(s)
	}
}

func (p *VerilogParser) Strength1() (localctx IStrength1Context) {
	localctx = NewStrength1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, VerilogParserRULE_strength1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-80)&-(0x1f+1)) == 0 && ((1<<uint((_la-80)))&((1<<(VerilogParserK_pull1-80))|(1<<(VerilogParserK_strong1-80))|(1<<(VerilogParserK_supply1-80)))) != 0) || _la == VerilogParserK_weak1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICharge_strengthContext is an interface to support dynamic dispatch.
type ICharge_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharge_strengthContext differentiates from other interfaces.
	IsCharge_strengthContext()
}

type Charge_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharge_strengthContext() *Charge_strengthContext {
	var p = new(Charge_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_charge_strength
	return p
}

func (*Charge_strengthContext) IsCharge_strengthContext() {}

func NewCharge_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charge_strengthContext {
	var p = new(Charge_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_charge_strength

	return p
}

func (s *Charge_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Charge_strengthContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Charge_strengthContext) K_small() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_small, 0)
}

func (s *Charge_strengthContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Charge_strengthContext) K_medium() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_medium, 0)
}

func (s *Charge_strengthContext) K_large() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_large, 0)
}

func (s *Charge_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charge_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charge_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCharge_strength(s)
	}
}

func (s *Charge_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCharge_strength(s)
	}
}

func (p *VerilogParser) Charge_strength() (localctx ICharge_strengthContext) {
	localctx = NewCharge_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, VerilogParserRULE_charge_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1360)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1351)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(1352)
			p.Match(VerilogParserK_small)
		}
		{
			p.SetState(1353)
			p.Match(VerilogParserRight_parenthes)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1354)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(1355)
			p.Match(VerilogParserK_medium)
		}
		{
			p.SetState(1356)
			p.Match(VerilogParserRight_parenthes)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1357)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(1358)
			p.Match(VerilogParserK_large)
		}
		{
			p.SetState(1359)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IDelay3Context is an interface to support dynamic dispatch.
type IDelay3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay3Context differentiates from other interfaces.
	IsDelay3Context()
}

type Delay3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay3Context() *Delay3Context {
	var p = new(Delay3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay3
	return p
}

func (*Delay3Context) IsDelay3Context() {}

func NewDelay3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay3Context {
	var p = new(Delay3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay3

	return p
}

func (s *Delay3Context) GetParser() antlr.Parser { return s.parser }

func (s *Delay3Context) Sharp() antlr.TerminalNode {
	return s.GetToken(VerilogParserSharp, 0)
}

func (s *Delay3Context) AllDelay_value() []IDelay_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem())
	var tst = make([]IDelay_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDelay_valueContext)
		}
	}

	return tst
}

func (s *Delay3Context) Delay_value(i int) IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay3Context) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Delay3Context) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Delay3Context) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Delay3Context) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Delay3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay3(s)
	}
}

func (s *Delay3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay3(s)
	}
}

func (p *VerilogParser) Delay3() (localctx IDelay3Context) {
	localctx = NewDelay3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, VerilogParserRULE_delay3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1377)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1362)
			p.Match(VerilogParserSharp)
		}
		{
			p.SetState(1363)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1364)
			p.Match(VerilogParserSharp)
		}
		{
			p.SetState(1365)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(1366)
			p.Delay_value()
		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserComma {
			{
				p.SetState(1367)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1368)
				p.Delay_value()
			}
			p.SetState(1371)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserComma {
				{
					p.SetState(1369)
					p.Match(VerilogParserComma)
				}
				{
					p.SetState(1370)
					p.Delay_value()
				}

			}

		}
		{
			p.SetState(1375)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IDelay2Context is an interface to support dynamic dispatch.
type IDelay2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay2Context differentiates from other interfaces.
	IsDelay2Context()
}

type Delay2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay2Context() *Delay2Context {
	var p = new(Delay2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay2
	return p
}

func (*Delay2Context) IsDelay2Context() {}

func NewDelay2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay2Context {
	var p = new(Delay2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay2

	return p
}

func (s *Delay2Context) GetParser() antlr.Parser { return s.parser }

func (s *Delay2Context) Sharp() antlr.TerminalNode {
	return s.GetToken(VerilogParserSharp, 0)
}

func (s *Delay2Context) AllDelay_value() []IDelay_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem())
	var tst = make([]IDelay_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDelay_valueContext)
		}
	}

	return tst
}

func (s *Delay2Context) Delay_value(i int) IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay2Context) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Delay2Context) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Delay2Context) Comma() antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, 0)
}

func (s *Delay2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay2(s)
	}
}

func (s *Delay2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay2(s)
	}
}

func (p *VerilogParser) Delay2() (localctx IDelay2Context) {
	localctx = NewDelay2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, VerilogParserRULE_delay2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1379)
			p.Match(VerilogParserSharp)
		}
		{
			p.SetState(1380)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1381)
			p.Match(VerilogParserSharp)
		}
		{
			p.SetState(1382)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(1383)
			p.Delay_value()
		}
		p.SetState(1386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserComma {
			{
				p.SetState(1384)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1385)
				p.Delay_value()
			}

		}
		{
			p.SetState(1388)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IDelay_valueContext is an interface to support dynamic dispatch.
type IDelay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_valueContext differentiates from other interfaces.
	IsDelay_valueContext()
}

type Delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_valueContext() *Delay_valueContext {
	var p = new(Delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay_value
	return p
}

func (*Delay_valueContext) IsDelay_valueContext() {}

func NewDelay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_valueContext {
	var p = new(Delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay_value

	return p
}

func (s *Delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_valueContext) Decimal_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserDecimal_number, 0)
}

func (s *Delay_valueContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Delay_valueContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Delay_valueContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay_value(s)
	}
}

func (s *Delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay_value(s)
	}
}

func (p *VerilogParser) Delay_value() (localctx IDelay_valueContext) {
	localctx = NewDelay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, VerilogParserRULE_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1392)
			p.Match(VerilogParserDecimal_number)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1393)
			p.Parameter_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1394)
			p.Specparam_identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1395)
			p.Mintypmax_expression()
		}

	}

	return localctx
}

// IList_of_event_identifiersContext is an interface to support dynamic dispatch.
type IList_of_event_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_event_identifiersContext differentiates from other interfaces.
	IsList_of_event_identifiersContext()
}

type List_of_event_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_event_identifiersContext() *List_of_event_identifiersContext {
	var p = new(List_of_event_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_event_identifiers
	return p
}

func (*List_of_event_identifiersContext) IsList_of_event_identifiersContext() {}

func NewList_of_event_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_event_identifiersContext {
	var p = new(List_of_event_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_event_identifiers

	return p
}

func (s *List_of_event_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_event_identifiersContext) AllEvent_identifier() []IEvent_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvent_identifierContext)(nil)).Elem())
	var tst = make([]IEvent_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvent_identifierContext)
		}
	}

	return tst
}

func (s *List_of_event_identifiersContext) Event_identifier(i int) IEvent_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvent_identifierContext)
}

func (s *List_of_event_identifiersContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *List_of_event_identifiersContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *List_of_event_identifiersContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_event_identifiersContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_event_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_event_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_event_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_event_identifiers(s)
	}
}

func (s *List_of_event_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_event_identifiers(s)
	}
}

func (p *VerilogParser) List_of_event_identifiers() (localctx IList_of_event_identifiersContext) {
	localctx = NewList_of_event_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, VerilogParserRULE_list_of_event_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1398)
		p.Event_identifier()
	}
	p.SetState(1406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_bracket {
		{
			p.SetState(1399)
			p.Dimension()
		}
		p.SetState(1403)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_bracket {
			{
				p.SetState(1400)
				p.Dimension()
			}

			p.SetState(1405)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1408)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1409)
			p.Event_identifier()
		}
		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_bracket {
			{
				p.SetState(1410)
				p.Dimension()
			}
			p.SetState(1414)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == VerilogParserLeft_bracket {
				{
					p.SetState(1411)
					p.Dimension()
				}

				p.SetState(1416)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

		p.SetState(1423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_net_identifiersContext is an interface to support dynamic dispatch.
type IList_of_net_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_identifiersContext differentiates from other interfaces.
	IsList_of_net_identifiersContext()
}

type List_of_net_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_identifiersContext() *List_of_net_identifiersContext {
	var p = new(List_of_net_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_net_identifiers
	return p
}

func (*List_of_net_identifiersContext) IsList_of_net_identifiersContext() {}

func NewList_of_net_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_identifiersContext {
	var p = new(List_of_net_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_net_identifiers

	return p
}

func (s *List_of_net_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_identifiersContext) AllNet_identifier() []INet_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_identifierContext)(nil)).Elem())
	var tst = make([]INet_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_identifierContext)
		}
	}

	return tst
}

func (s *List_of_net_identifiersContext) Net_identifier(i int) INet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_identifierContext)
}

func (s *List_of_net_identifiersContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *List_of_net_identifiersContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *List_of_net_identifiersContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_net_identifiersContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_net_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_net_identifiers(s)
	}
}

func (s *List_of_net_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_net_identifiers(s)
	}
}

func (p *VerilogParser) List_of_net_identifiers() (localctx IList_of_net_identifiersContext) {
	localctx = NewList_of_net_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, VerilogParserRULE_list_of_net_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1424)
		p.Net_identifier()
	}
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_bracket {
		{
			p.SetState(1425)
			p.Dimension()
		}
		p.SetState(1429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_bracket {
			{
				p.SetState(1426)
				p.Dimension()
			}

			p.SetState(1431)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1447)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1434)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1435)
			p.Net_identifier()
		}
		p.SetState(1443)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_bracket {
			{
				p.SetState(1436)
				p.Dimension()
			}
			p.SetState(1440)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == VerilogParserLeft_bracket {
				{
					p.SetState(1437)
					p.Dimension()
				}

				p.SetState(1442)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

		p.SetState(1449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_genvar_identifiersContext is an interface to support dynamic dispatch.
type IList_of_genvar_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_genvar_identifiersContext differentiates from other interfaces.
	IsList_of_genvar_identifiersContext()
}

type List_of_genvar_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_genvar_identifiersContext() *List_of_genvar_identifiersContext {
	var p = new(List_of_genvar_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_genvar_identifiers
	return p
}

func (*List_of_genvar_identifiersContext) IsList_of_genvar_identifiersContext() {}

func NewList_of_genvar_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_genvar_identifiersContext {
	var p = new(List_of_genvar_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_genvar_identifiers

	return p
}

func (s *List_of_genvar_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_genvar_identifiersContext) AllGenvar_identifier() []IGenvar_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem())
	var tst = make([]IGenvar_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenvar_identifierContext)
		}
	}

	return tst
}

func (s *List_of_genvar_identifiersContext) Genvar_identifier(i int) IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *List_of_genvar_identifiersContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_genvar_identifiersContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_genvar_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_genvar_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_genvar_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_genvar_identifiers(s)
	}
}

func (s *List_of_genvar_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_genvar_identifiers(s)
	}
}

func (p *VerilogParser) List_of_genvar_identifiers() (localctx IList_of_genvar_identifiersContext) {
	localctx = NewList_of_genvar_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, VerilogParserRULE_list_of_genvar_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1450)
		p.Genvar_identifier()
	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1451)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1452)
			p.Genvar_identifier()
		}

		p.SetState(1457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_identifiersContext differentiates from other interfaces.
	IsList_of_port_identifiersContext()
}

type List_of_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_identifiersContext() *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_port_identifiers
	return p
}

func (*List_of_port_identifiersContext) IsList_of_port_identifiersContext() {}

func NewList_of_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_port_identifiers

	return p
}

func (s *List_of_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_port_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_port_identifiersContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_port_identifiersContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_port_identifiers(s)
	}
}

func (s *List_of_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_port_identifiers(s)
	}
}

func (p *VerilogParser) List_of_port_identifiers() (localctx IList_of_port_identifiersContext) {
	localctx = NewList_of_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, VerilogParserRULE_list_of_port_identifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1458)
		p.Port_identifier()
	}
	p.SetState(1463)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1459)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1460)
				p.Port_identifier()
			}

		}
		p.SetState(1465)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())
	}

	return localctx
}

// IList_of_net_decl_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_net_decl_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_decl_assignmentsContext differentiates from other interfaces.
	IsList_of_net_decl_assignmentsContext()
}

type List_of_net_decl_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_decl_assignmentsContext() *List_of_net_decl_assignmentsContext {
	var p = new(List_of_net_decl_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_net_decl_assignments
	return p
}

func (*List_of_net_decl_assignmentsContext) IsList_of_net_decl_assignmentsContext() {}

func NewList_of_net_decl_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_decl_assignmentsContext {
	var p = new(List_of_net_decl_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_net_decl_assignments

	return p
}

func (s *List_of_net_decl_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_decl_assignmentsContext) AllNet_decl_assignment() []INet_decl_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_decl_assignmentContext)(nil)).Elem())
	var tst = make([]INet_decl_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_decl_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_net_decl_assignmentsContext) Net_decl_assignment(i int) INet_decl_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_decl_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_decl_assignmentContext)
}

func (s *List_of_net_decl_assignmentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_net_decl_assignmentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_net_decl_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_decl_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_decl_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_net_decl_assignments(s)
	}
}

func (s *List_of_net_decl_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_net_decl_assignments(s)
	}
}

func (p *VerilogParser) List_of_net_decl_assignments() (localctx IList_of_net_decl_assignmentsContext) {
	localctx = NewList_of_net_decl_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, VerilogParserRULE_list_of_net_decl_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1466)
		p.Net_decl_assignment()
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1467)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1468)
			p.Net_decl_assignment()
		}

		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_param_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_param_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_param_assignmentsContext differentiates from other interfaces.
	IsList_of_param_assignmentsContext()
}

type List_of_param_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_param_assignmentsContext() *List_of_param_assignmentsContext {
	var p = new(List_of_param_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_param_assignments
	return p
}

func (*List_of_param_assignmentsContext) IsList_of_param_assignmentsContext() {}

func NewList_of_param_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_param_assignmentsContext {
	var p = new(List_of_param_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_param_assignments

	return p
}

func (s *List_of_param_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_param_assignmentsContext) AllParam_assignment() []IParam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParam_assignmentContext)(nil)).Elem())
	var tst = make([]IParam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_param_assignmentsContext) Param_assignment(i int) IParam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParam_assignmentContext)
}

func (s *List_of_param_assignmentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_param_assignmentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_param_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_param_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_param_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_param_assignments(s)
	}
}

func (s *List_of_param_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_param_assignments(s)
	}
}

func (p *VerilogParser) List_of_param_assignments() (localctx IList_of_param_assignmentsContext) {
	localctx = NewList_of_param_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, VerilogParserRULE_list_of_param_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1474)
		p.Param_assignment()
	}
	p.SetState(1479)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1475)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1476)
				p.Param_assignment()
			}

		}
		p.SetState(1481)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())
	}

	return localctx
}

// IList_of_specparam_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_specparam_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_specparam_assignmentsContext differentiates from other interfaces.
	IsList_of_specparam_assignmentsContext()
}

type List_of_specparam_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_specparam_assignmentsContext() *List_of_specparam_assignmentsContext {
	var p = new(List_of_specparam_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_specparam_assignments
	return p
}

func (*List_of_specparam_assignmentsContext) IsList_of_specparam_assignmentsContext() {}

func NewList_of_specparam_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_specparam_assignmentsContext {
	var p = new(List_of_specparam_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_specparam_assignments

	return p
}

func (s *List_of_specparam_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_specparam_assignmentsContext) AllSpecparam_assignment() []ISpecparam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecparam_assignmentContext)(nil)).Elem())
	var tst = make([]ISpecparam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecparam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_specparam_assignmentsContext) Specparam_assignment(i int) ISpecparam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_assignmentContext)
}

func (s *List_of_specparam_assignmentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_specparam_assignmentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_specparam_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_specparam_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_specparam_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_specparam_assignments(s)
	}
}

func (s *List_of_specparam_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_specparam_assignments(s)
	}
}

func (p *VerilogParser) List_of_specparam_assignments() (localctx IList_of_specparam_assignmentsContext) {
	localctx = NewList_of_specparam_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, VerilogParserRULE_list_of_specparam_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1482)
		p.Specparam_assignment()
	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1483)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1484)
			p.Specparam_assignment()
		}

		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_real_identifiersContext is an interface to support dynamic dispatch.
type IList_of_real_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_real_identifiersContext differentiates from other interfaces.
	IsList_of_real_identifiersContext()
}

type List_of_real_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_real_identifiersContext() *List_of_real_identifiersContext {
	var p = new(List_of_real_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_real_identifiers
	return p
}

func (*List_of_real_identifiersContext) IsList_of_real_identifiersContext() {}

func NewList_of_real_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_real_identifiersContext {
	var p = new(List_of_real_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_real_identifiers

	return p
}

func (s *List_of_real_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_real_identifiersContext) AllReal_type() []IReal_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReal_typeContext)(nil)).Elem())
	var tst = make([]IReal_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReal_typeContext)
		}
	}

	return tst
}

func (s *List_of_real_identifiersContext) Real_type(i int) IReal_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReal_typeContext)
}

func (s *List_of_real_identifiersContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_real_identifiersContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_real_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_real_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_real_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_real_identifiers(s)
	}
}

func (s *List_of_real_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_real_identifiers(s)
	}
}

func (p *VerilogParser) List_of_real_identifiers() (localctx IList_of_real_identifiersContext) {
	localctx = NewList_of_real_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, VerilogParserRULE_list_of_real_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1490)
		p.Real_type()
	}
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1491)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1492)
			p.Real_type()
		}

		p.SetState(1497)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_variable_identifiersContext is an interface to support dynamic dispatch.
type IList_of_variable_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_identifiersContext differentiates from other interfaces.
	IsList_of_variable_identifiersContext()
}

type List_of_variable_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_identifiersContext() *List_of_variable_identifiersContext {
	var p = new(List_of_variable_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_variable_identifiers
	return p
}

func (*List_of_variable_identifiersContext) IsList_of_variable_identifiersContext() {}

func NewList_of_variable_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_identifiersContext {
	var p = new(List_of_variable_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_variable_identifiers

	return p
}

func (s *List_of_variable_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_identifiersContext) AllVariable_type() []IVariable_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_typeContext)(nil)).Elem())
	var tst = make([]IVariable_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_typeContext)
		}
	}

	return tst
}

func (s *List_of_variable_identifiersContext) Variable_type(i int) IVariable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_typeContext)
}

func (s *List_of_variable_identifiersContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_variable_identifiersContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_variable_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_variable_identifiers(s)
	}
}

func (s *List_of_variable_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_variable_identifiers(s)
	}
}

func (p *VerilogParser) List_of_variable_identifiers() (localctx IList_of_variable_identifiersContext) {
	localctx = NewList_of_variable_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, VerilogParserRULE_list_of_variable_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1498)
		p.Variable_type()
	}
	p.SetState(1503)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1499)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1500)
			p.Variable_type()
		}

		p.SetState(1505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_variable_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_variable_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_port_identifiersContext differentiates from other interfaces.
	IsList_of_variable_port_identifiersContext()
}

type List_of_variable_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_port_identifiersContext() *List_of_variable_port_identifiersContext {
	var p = new(List_of_variable_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_variable_port_identifiers
	return p
}

func (*List_of_variable_port_identifiersContext) IsList_of_variable_port_identifiersContext() {}

func NewList_of_variable_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_port_identifiersContext {
	var p = new(List_of_variable_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_variable_port_identifiers

	return p
}

func (s *List_of_variable_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_port_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_variable_port_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_variable_port_identifiersContext) AllEq() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserEq)
}

func (s *List_of_variable_port_identifiersContext) Eq(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, i)
}

func (s *List_of_variable_port_identifiersContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *List_of_variable_port_identifiersContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *List_of_variable_port_identifiersContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_variable_port_identifiersContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_variable_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_variable_port_identifiers(s)
	}
}

func (s *List_of_variable_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_variable_port_identifiers(s)
	}
}

func (p *VerilogParser) List_of_variable_port_identifiers() (localctx IList_of_variable_port_identifiersContext) {
	localctx = NewList_of_variable_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, VerilogParserRULE_list_of_variable_port_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1506)
		p.Port_identifier()
	}
	p.SetState(1509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEq {
		{
			p.SetState(1507)
			p.Match(VerilogParserEq)
		}
		{
			p.SetState(1508)
			p.Constant_expression()
		}

	}
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1511)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1512)
				p.Port_identifier()
			}
			p.SetState(1515)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserEq {
				{
					p.SetState(1513)
					p.Match(VerilogParserEq)
				}
				{
					p.SetState(1514)
					p.Constant_expression()
				}

			}

		}
		p.SetState(1521)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
	}

	return localctx
}

// INet_decl_assignmentContext is an interface to support dynamic dispatch.
type INet_decl_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_decl_assignmentContext differentiates from other interfaces.
	IsNet_decl_assignmentContext()
}

type Net_decl_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_decl_assignmentContext() *Net_decl_assignmentContext {
	var p = new(Net_decl_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_decl_assignment
	return p
}

func (*Net_decl_assignmentContext) IsNet_decl_assignmentContext() {}

func NewNet_decl_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_decl_assignmentContext {
	var p = new(Net_decl_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_decl_assignment

	return p
}

func (s *Net_decl_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_decl_assignmentContext) Net_identifier() INet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_identifierContext)
}

func (s *Net_decl_assignmentContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Net_decl_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_decl_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_decl_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_decl_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_decl_assignment(s)
	}
}

func (s *Net_decl_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_decl_assignment(s)
	}
}

func (p *VerilogParser) Net_decl_assignment() (localctx INet_decl_assignmentContext) {
	localctx = NewNet_decl_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, VerilogParserRULE_net_decl_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1522)
		p.Net_identifier()
	}
	{
		p.SetState(1523)
		p.Match(VerilogParserEq)
	}
	{
		p.SetState(1524)
		p.Expression()
	}

	return localctx
}

// IParam_assignmentContext is an interface to support dynamic dispatch.
type IParam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_assignmentContext differentiates from other interfaces.
	IsParam_assignmentContext()
}

type Param_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_assignmentContext() *Param_assignmentContext {
	var p = new(Param_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_param_assignment
	return p
}

func (*Param_assignmentContext) IsParam_assignmentContext() {}

func NewParam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_assignmentContext {
	var p = new(Param_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_param_assignment

	return p
}

func (s *Param_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_assignmentContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Param_assignmentContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Param_assignmentContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Param_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParam_assignment(s)
	}
}

func (s *Param_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParam_assignment(s)
	}
}

func (p *VerilogParser) Param_assignment() (localctx IParam_assignmentContext) {
	localctx = NewParam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, VerilogParserRULE_param_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1526)
		p.Parameter_identifier()
	}
	{
		p.SetState(1527)
		p.Match(VerilogParserEq)
	}
	{
		p.SetState(1528)
		p.Constant_expression()
	}

	return localctx
}

// ISpecparam_assignmentContext is an interface to support dynamic dispatch.
type ISpecparam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_assignmentContext differentiates from other interfaces.
	IsSpecparam_assignmentContext()
}

type Specparam_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_assignmentContext() *Specparam_assignmentContext {
	var p = new(Specparam_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specparam_assignment
	return p
}

func (*Specparam_assignmentContext) IsSpecparam_assignmentContext() {}

func NewSpecparam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_assignmentContext {
	var p = new(Specparam_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specparam_assignment

	return p
}

func (s *Specparam_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_assignmentContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Specparam_assignmentContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Specparam_assignmentContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Specparam_assignmentContext) Pulse_control_specparam() IPulse_control_specparamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulse_control_specparamContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulse_control_specparamContext)
}

func (s *Specparam_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecparam_assignment(s)
	}
}

func (s *Specparam_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecparam_assignment(s)
	}
}

func (p *VerilogParser) Specparam_assignment() (localctx ISpecparam_assignmentContext) {
	localctx = NewSpecparam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, VerilogParserRULE_specparam_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1535)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1530)
			p.Specparam_identifier()
		}
		{
			p.SetState(1531)
			p.Match(VerilogParserEq)
		}
		{
			p.SetState(1532)
			p.Constant_mintypmax_expression()
		}

	case VerilogParserK_PATHPULSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1534)
			p.Pulse_control_specparam()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPulse_control_specparamContext is an interface to support dynamic dispatch.
type IPulse_control_specparamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulse_control_specparamContext differentiates from other interfaces.
	IsPulse_control_specparamContext()
}

type Pulse_control_specparamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulse_control_specparamContext() *Pulse_control_specparamContext {
	var p = new(Pulse_control_specparamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pulse_control_specparam
	return p
}

func (*Pulse_control_specparamContext) IsPulse_control_specparamContext() {}

func NewPulse_control_specparamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulse_control_specparamContext {
	var p = new(Pulse_control_specparamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pulse_control_specparam

	return p
}

func (s *Pulse_control_specparamContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulse_control_specparamContext) K_PATHPULSE() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_PATHPULSE, 0)
}

func (s *Pulse_control_specparamContext) AllDollar() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDollar)
}

func (s *Pulse_control_specparamContext) Dollar(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDollar, i)
}

func (s *Pulse_control_specparamContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Pulse_control_specparamContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Pulse_control_specparamContext) Reject_limit_value() IReject_limit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReject_limit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReject_limit_valueContext)
}

func (s *Pulse_control_specparamContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Pulse_control_specparamContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Pulse_control_specparamContext) Comma() antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, 0)
}

func (s *Pulse_control_specparamContext) Error_limit_value() IError_limit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_limit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_limit_valueContext)
}

func (s *Pulse_control_specparamContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Pulse_control_specparamContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Pulse_control_specparamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulse_control_specparamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulse_control_specparamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPulse_control_specparam(s)
	}
}

func (s *Pulse_control_specparamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPulse_control_specparam(s)
	}
}

func (p *VerilogParser) Pulse_control_specparam() (localctx IPulse_control_specparamContext) {
	localctx = NewPulse_control_specparamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, VerilogParserRULE_pulse_control_specparam)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1564)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1537)
			p.Match(VerilogParserK_PATHPULSE)
		}
		{
			p.SetState(1538)
			p.Match(VerilogParserDollar)
		}
		{
			p.SetState(1539)
			p.Match(VerilogParserEq)
		}
		{
			p.SetState(1540)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(1541)
			p.Reject_limit_value()
		}
		p.SetState(1544)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserComma {
			{
				p.SetState(1542)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1543)
				p.Error_limit_value()
			}

		}
		{
			p.SetState(1546)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(1547)
			p.Match(VerilogParserSemicolon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1549)
			p.Match(VerilogParserK_PATHPULSE)
		}
		{
			p.SetState(1550)
			p.Match(VerilogParserDollar)
		}
		{
			p.SetState(1551)
			p.Specify_input_terminal_descriptor()
		}
		{
			p.SetState(1552)
			p.Match(VerilogParserDollar)
		}
		{
			p.SetState(1553)
			p.Specify_output_terminal_descriptor()
		}
		{
			p.SetState(1554)
			p.Match(VerilogParserEq)
		}
		{
			p.SetState(1555)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(1556)
			p.Reject_limit_value()
		}
		p.SetState(1559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserComma {
			{
				p.SetState(1557)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1558)
				p.Error_limit_value()
			}

		}
		{
			p.SetState(1561)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(1562)
			p.Match(VerilogParserSemicolon)
		}

	}

	return localctx
}

// IError_limit_valueContext is an interface to support dynamic dispatch.
type IError_limit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsError_limit_valueContext differentiates from other interfaces.
	IsError_limit_valueContext()
}

type Error_limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_limit_valueContext() *Error_limit_valueContext {
	var p = new(Error_limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_error_limit_value
	return p
}

func (*Error_limit_valueContext) IsError_limit_valueContext() {}

func NewError_limit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_limit_valueContext {
	var p = new(Error_limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_error_limit_value

	return p
}

func (s *Error_limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_limit_valueContext) Limit_value() ILimit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimit_valueContext)
}

func (s *Error_limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterError_limit_value(s)
	}
}

func (s *Error_limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitError_limit_value(s)
	}
}

func (p *VerilogParser) Error_limit_value() (localctx IError_limit_valueContext) {
	localctx = NewError_limit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, VerilogParserRULE_error_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1566)
		p.Limit_value()
	}

	return localctx
}

// IReject_limit_valueContext is an interface to support dynamic dispatch.
type IReject_limit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReject_limit_valueContext differentiates from other interfaces.
	IsReject_limit_valueContext()
}

type Reject_limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReject_limit_valueContext() *Reject_limit_valueContext {
	var p = new(Reject_limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_reject_limit_value
	return p
}

func (*Reject_limit_valueContext) IsReject_limit_valueContext() {}

func NewReject_limit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reject_limit_valueContext {
	var p = new(Reject_limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_reject_limit_value

	return p
}

func (s *Reject_limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Reject_limit_valueContext) Limit_value() ILimit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimit_valueContext)
}

func (s *Reject_limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reject_limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reject_limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReject_limit_value(s)
	}
}

func (s *Reject_limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReject_limit_value(s)
	}
}

func (p *VerilogParser) Reject_limit_value() (localctx IReject_limit_valueContext) {
	localctx = NewReject_limit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, VerilogParserRULE_reject_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1568)
		p.Limit_value()
	}

	return localctx
}

// ILimit_valueContext is an interface to support dynamic dispatch.
type ILimit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimit_valueContext differentiates from other interfaces.
	IsLimit_valueContext()
}

type Limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_valueContext() *Limit_valueContext {
	var p = new(Limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_limit_value
	return p
}

func (*Limit_valueContext) IsLimit_valueContext() {}

func NewLimit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_valueContext {
	var p = new(Limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_limit_value

	return p
}

func (s *Limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_valueContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLimit_value(s)
	}
}

func (s *Limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLimit_value(s)
	}
}

func (p *VerilogParser) Limit_value() (localctx ILimit_valueContext) {
	localctx = NewLimit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, VerilogParserRULE_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1570)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IDimensionContext is an interface to support dynamic dispatch.
type IDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimensionContext differentiates from other interfaces.
	IsDimensionContext()
}

type DimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimensionContext() *DimensionContext {
	var p = new(DimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dimension
	return p
}

func (*DimensionContext) IsDimensionContext() {}

func NewDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimensionContext {
	var p = new(DimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dimension

	return p
}

func (s *DimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *DimensionContext) Left_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, 0)
}

func (s *DimensionContext) AllDimension_constant_expression() []IDimension_constant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimension_constant_expressionContext)(nil)).Elem())
	var tst = make([]IDimension_constant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimension_constant_expressionContext)
		}
	}

	return tst
}

func (s *DimensionContext) Dimension_constant_expression(i int) IDimension_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimension_constant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimension_constant_expressionContext)
}

func (s *DimensionContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *DimensionContext) Right_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, 0)
}

func (s *DimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDimension(s)
	}
}

func (s *DimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDimension(s)
	}
}

func (p *VerilogParser) Dimension() (localctx IDimensionContext) {
	localctx = NewDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, VerilogParserRULE_dimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1572)
		p.Match(VerilogParserLeft_bracket)
	}
	{
		p.SetState(1573)
		p.Dimension_constant_expression()
	}
	{
		p.SetState(1574)
		p.Match(VerilogParserColon)
	}
	{
		p.SetState(1575)
		p.Dimension_constant_expression()
	}
	{
		p.SetState(1576)
		p.Match(VerilogParserRight_bracket)
	}

	return localctx
}

// IRange_Context is an interface to support dynamic dispatch.
type IRange_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_Context differentiates from other interfaces.
	IsRange_Context()
}

type Range_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_Context() *Range_Context {
	var p = new(Range_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_range_
	return p
}

func (*Range_Context) IsRange_Context() {}

func NewRange_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_Context {
	var p = new(Range_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_range_

	return p
}

func (s *Range_Context) GetParser() antlr.Parser { return s.parser }

func (s *Range_Context) Left_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, 0)
}

func (s *Range_Context) Msb_constant_expression() IMsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMsb_constant_expressionContext)
}

func (s *Range_Context) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Range_Context) Lsb_constant_expression() ILsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsb_constant_expressionContext)
}

func (s *Range_Context) Right_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, 0)
}

func (s *Range_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRange_(s)
	}
}

func (s *Range_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRange_(s)
	}
}

func (p *VerilogParser) Range_() (localctx IRange_Context) {
	localctx = NewRange_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, VerilogParserRULE_range_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1578)
		p.Match(VerilogParserLeft_bracket)
	}
	{
		p.SetState(1579)
		p.Msb_constant_expression()
	}
	{
		p.SetState(1580)
		p.Match(VerilogParserColon)
	}
	{
		p.SetState(1581)
		p.Lsb_constant_expression()
	}
	{
		p.SetState(1582)
		p.Match(VerilogParserRight_bracket)
	}

	return localctx
}

// IFunction_declarationContext is an interface to support dynamic dispatch.
type IFunction_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_declarationContext differentiates from other interfaces.
	IsFunction_declarationContext()
}

type Function_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_declarationContext() *Function_declarationContext {
	var p = new(Function_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_declaration
	return p
}

func (*Function_declarationContext) IsFunction_declarationContext() {}

func NewFunction_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_declarationContext {
	var p = new(Function_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_declaration

	return p
}

func (s *Function_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_declarationContext) K_function() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_function, 0)
}

func (s *Function_declarationContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Function_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Function_declarationContext) K_endfunction() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_endfunction, 0)
}

func (s *Function_declarationContext) K_automatic() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_automatic, 0)
}

func (s *Function_declarationContext) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Function_declarationContext) Range_or_type() IRange_or_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_or_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_or_typeContext)
}

func (s *Function_declarationContext) AllFunction_item_declaration() []IFunction_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_item_declarationContext)(nil)).Elem())
	var tst = make([]IFunction_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_declarationContext) Function_item_declaration(i int) IFunction_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_item_declarationContext)
}

func (s *Function_declarationContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_declarationContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Function_declarationContext) Function_port_list() IFunction_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_port_listContext)
}

func (s *Function_declarationContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Function_declarationContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_declarationContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_declaration(s)
	}
}

func (s *Function_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_declaration(s)
	}
}

func (p *VerilogParser) Function_declaration() (localctx IFunction_declarationContext) {
	localctx = NewFunction_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, VerilogParserRULE_function_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1633)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1584)
			p.Match(VerilogParserK_function)
		}
		p.SetState(1586)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_automatic {
			{
				p.SetState(1585)
				p.Match(VerilogParserK_automatic)
			}

		}
		p.SetState(1589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1588)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1592)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(VerilogParserK_integer-57))|(1<<(VerilogParserK_real-57))|(1<<(VerilogParserK_realtime-57)))) != 0) || _la == VerilogParserK_time || _la == VerilogParserLeft_bracket {
			{
				p.SetState(1591)
				p.Range_or_type()
			}

		}
		{
			p.SetState(1594)
			p.Function_identifier()
		}
		{
			p.SetState(1595)
			p.Match(VerilogParserSemicolon)
		}
		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1596)
					p.Function_item_declaration()
				}

			}
			p.SetState(1601)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())
		}
		p.SetState(1603)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserK_begin)|(1<<VerilogParserK_case)|(1<<VerilogParserK_casex)|(1<<VerilogParserK_casez)|(1<<VerilogParserK_disable))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserK_for-41))|(1<<(VerilogParserK_forever-41))|(1<<(VerilogParserK_if-41)))) != 0) || _la == VerilogParserK_repeat || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(VerilogParserK_while-125))|(1<<(VerilogParserK_TASK_monitoroff-125))|(1<<(VerilogParserK_TASK_monitoron-125))|(1<<(VerilogParserK_TASK_monitorb-125))|(1<<(VerilogParserK_TASK_displayo-125))|(1<<(VerilogParserK_TASK_displayh-125))|(1<<(VerilogParserK_TASK_displayb-125))|(1<<(VerilogParserK_TASK_strobeo-125))|(1<<(VerilogParserK_TASK_strobeh-125))|(1<<(VerilogParserK_TASK_strobeb-125))|(1<<(VerilogParserK_TASK_monitor-125))|(1<<(VerilogParserK_TASK_display-125)))) != 0) || (((_la-157)&-(0x1f+1)) == 0 && ((1<<uint((_la-157)))&((1<<(VerilogParserK_TASK_writeo-157))|(1<<(VerilogParserK_TASK_writeh-157))|(1<<(VerilogParserK_TASK_strobe-157))|(1<<(VerilogParserK_TASK_write-157))|(1<<(VerilogParserK_TASK_fmonitoro-157))|(1<<(VerilogParserK_TASK_fmonitorh-157))|(1<<(VerilogParserK_TASK_fmonitorb-157))|(1<<(VerilogParserK_TASK_fdisplayo-157))|(1<<(VerilogParserK_TASK_fdisplayh-157))|(1<<(VerilogParserK_TASK_fdisplayb-157))|(1<<(VerilogParserK_TASK_fmonitor-157))|(1<<(VerilogParserK_TASK_fdisplay-157))|(1<<(VerilogParserK_TASK_fstrobeo-157))|(1<<(VerilogParserK_TASK_fstrobeh-157))|(1<<(VerilogParserK_TASK_fstrobeb-157))|(1<<(VerilogParserK_TASK_sformatf-157))|(1<<(VerilogParserK_TASK_swriteo-157))|(1<<(VerilogParserK_TASK_swriteh-157))|(1<<(VerilogParserK_TASK_swriteb-157))|(1<<(VerilogParserK_TASK_sformat-157))|(1<<(VerilogParserK_TASK_fwriteo-157))|(1<<(VerilogParserK_TASK_fwriteh-157))|(1<<(VerilogParserK_TASK_fwriteb-157))|(1<<(VerilogParserK_TASK_fstrobe-157))|(1<<(VerilogParserK_TASK_ungetc-157))|(1<<(VerilogParserK_TASK_swrite-157))|(1<<(VerilogParserK_TASK_sscanf-157))|(1<<(VerilogParserK_TASK_rewind-157))|(1<<(VerilogParserK_TASK_fwrite-157))|(1<<(VerilogParserK_TASK_fscanf-157))|(1<<(VerilogParserK_TASK_fflush-157)))) != 0) || (((_la-189)&-(0x1f+1)) == 0 && ((1<<uint((_la-189)))&((1<<(VerilogParserK_TASK_ferror-189))|(1<<(VerilogParserK_TASK_fclose-189))|(1<<(VerilogParserK_TASK_ftell-189))|(1<<(VerilogParserK_TASK_fseek-189))|(1<<(VerilogParserK_TASK_fopen-189))|(1<<(VerilogParserK_TASK_fread-189))|(1<<(VerilogParserK_TASK_fgets-189))|(1<<(VerilogParserK_TASK_fgetc-189))|(1<<(VerilogParserK_TASK_feof-189))|(1<<(VerilogParserK_TASK_printtimescale-189))|(1<<(VerilogParserK_TASK_timeformat-189))|(1<<(VerilogParserK_TASK_finish-189))|(1<<(VerilogParserK_TASK_stop-189))|(1<<(VerilogParserK_TASK_async_nand_plane-189))|(1<<(VerilogParserK_TASK_async_nand_array-189))|(1<<(VerilogParserK_TASK_async_nor_plane-189))|(1<<(VerilogParserK_TASK_async_nor_array-189))|(1<<(VerilogParserK_TASK_async_and_plane-189))|(1<<(VerilogParserK_TASK_async_and_array-189))|(1<<(VerilogParserK_TASK_sync_nand_plane-189))|(1<<(VerilogParserK_TASK_sync_nand_array-189))|(1<<(VerilogParserK_TASK_sync_nor_plane-189))|(1<<(VerilogParserK_TASK_sync_nor_array-189))|(1<<(VerilogParserK_TASK_sync_and_plane-189))|(1<<(VerilogParserK_TASK_sync_and_array-189))|(1<<(VerilogParserK_TASK_async_or_plane-189))|(1<<(VerilogParserK_TASK_async_or_array-189))|(1<<(VerilogParserK_TASK_sync_or_plane-189))|(1<<(VerilogParserK_TASK_sync_or_array-189)))) != 0) || _la == VerilogParserLeft_parenthes || _la == VerilogParserLeft_brace || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(1602)
				p.Function_statement()
			}

		}
		{
			p.SetState(1605)
			p.Match(VerilogParserK_endfunction)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1607)
			p.Match(VerilogParserK_function)
		}
		p.SetState(1609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_automatic {
			{
				p.SetState(1608)
				p.Match(VerilogParserK_automatic)
			}

		}
		p.SetState(1612)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1611)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1615)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(VerilogParserK_integer-57))|(1<<(VerilogParserK_real-57))|(1<<(VerilogParserK_realtime-57)))) != 0) || _la == VerilogParserK_time || _la == VerilogParserLeft_bracket {
			{
				p.SetState(1614)
				p.Range_or_type()
			}

		}
		{
			p.SetState(1617)
			p.Function_identifier()
		}
		{
			p.SetState(1618)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(1619)
			p.Function_port_list()
		}
		{
			p.SetState(1620)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(1621)
			p.Match(VerilogParserSemicolon)
		}
		p.SetState(1625)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1622)
					p.Block_item_declaration()
				}

			}
			p.SetState(1627)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())
		}
		p.SetState(1629)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserK_begin)|(1<<VerilogParserK_case)|(1<<VerilogParserK_casex)|(1<<VerilogParserK_casez)|(1<<VerilogParserK_disable))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserK_for-41))|(1<<(VerilogParserK_forever-41))|(1<<(VerilogParserK_if-41)))) != 0) || _la == VerilogParserK_repeat || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(VerilogParserK_while-125))|(1<<(VerilogParserK_TASK_monitoroff-125))|(1<<(VerilogParserK_TASK_monitoron-125))|(1<<(VerilogParserK_TASK_monitorb-125))|(1<<(VerilogParserK_TASK_displayo-125))|(1<<(VerilogParserK_TASK_displayh-125))|(1<<(VerilogParserK_TASK_displayb-125))|(1<<(VerilogParserK_TASK_strobeo-125))|(1<<(VerilogParserK_TASK_strobeh-125))|(1<<(VerilogParserK_TASK_strobeb-125))|(1<<(VerilogParserK_TASK_monitor-125))|(1<<(VerilogParserK_TASK_display-125)))) != 0) || (((_la-157)&-(0x1f+1)) == 0 && ((1<<uint((_la-157)))&((1<<(VerilogParserK_TASK_writeo-157))|(1<<(VerilogParserK_TASK_writeh-157))|(1<<(VerilogParserK_TASK_strobe-157))|(1<<(VerilogParserK_TASK_write-157))|(1<<(VerilogParserK_TASK_fmonitoro-157))|(1<<(VerilogParserK_TASK_fmonitorh-157))|(1<<(VerilogParserK_TASK_fmonitorb-157))|(1<<(VerilogParserK_TASK_fdisplayo-157))|(1<<(VerilogParserK_TASK_fdisplayh-157))|(1<<(VerilogParserK_TASK_fdisplayb-157))|(1<<(VerilogParserK_TASK_fmonitor-157))|(1<<(VerilogParserK_TASK_fdisplay-157))|(1<<(VerilogParserK_TASK_fstrobeo-157))|(1<<(VerilogParserK_TASK_fstrobeh-157))|(1<<(VerilogParserK_TASK_fstrobeb-157))|(1<<(VerilogParserK_TASK_sformatf-157))|(1<<(VerilogParserK_TASK_swriteo-157))|(1<<(VerilogParserK_TASK_swriteh-157))|(1<<(VerilogParserK_TASK_swriteb-157))|(1<<(VerilogParserK_TASK_sformat-157))|(1<<(VerilogParserK_TASK_fwriteo-157))|(1<<(VerilogParserK_TASK_fwriteh-157))|(1<<(VerilogParserK_TASK_fwriteb-157))|(1<<(VerilogParserK_TASK_fstrobe-157))|(1<<(VerilogParserK_TASK_ungetc-157))|(1<<(VerilogParserK_TASK_swrite-157))|(1<<(VerilogParserK_TASK_sscanf-157))|(1<<(VerilogParserK_TASK_rewind-157))|(1<<(VerilogParserK_TASK_fwrite-157))|(1<<(VerilogParserK_TASK_fscanf-157))|(1<<(VerilogParserK_TASK_fflush-157)))) != 0) || (((_la-189)&-(0x1f+1)) == 0 && ((1<<uint((_la-189)))&((1<<(VerilogParserK_TASK_ferror-189))|(1<<(VerilogParserK_TASK_fclose-189))|(1<<(VerilogParserK_TASK_ftell-189))|(1<<(VerilogParserK_TASK_fseek-189))|(1<<(VerilogParserK_TASK_fopen-189))|(1<<(VerilogParserK_TASK_fread-189))|(1<<(VerilogParserK_TASK_fgets-189))|(1<<(VerilogParserK_TASK_fgetc-189))|(1<<(VerilogParserK_TASK_feof-189))|(1<<(VerilogParserK_TASK_printtimescale-189))|(1<<(VerilogParserK_TASK_timeformat-189))|(1<<(VerilogParserK_TASK_finish-189))|(1<<(VerilogParserK_TASK_stop-189))|(1<<(VerilogParserK_TASK_async_nand_plane-189))|(1<<(VerilogParserK_TASK_async_nand_array-189))|(1<<(VerilogParserK_TASK_async_nor_plane-189))|(1<<(VerilogParserK_TASK_async_nor_array-189))|(1<<(VerilogParserK_TASK_async_and_plane-189))|(1<<(VerilogParserK_TASK_async_and_array-189))|(1<<(VerilogParserK_TASK_sync_nand_plane-189))|(1<<(VerilogParserK_TASK_sync_nand_array-189))|(1<<(VerilogParserK_TASK_sync_nor_plane-189))|(1<<(VerilogParserK_TASK_sync_nor_array-189))|(1<<(VerilogParserK_TASK_sync_and_plane-189))|(1<<(VerilogParserK_TASK_sync_and_array-189))|(1<<(VerilogParserK_TASK_async_or_plane-189))|(1<<(VerilogParserK_TASK_async_or_array-189))|(1<<(VerilogParserK_TASK_sync_or_plane-189))|(1<<(VerilogParserK_TASK_sync_or_array-189)))) != 0) || _la == VerilogParserLeft_parenthes || _la == VerilogParserLeft_brace || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(1628)
				p.Function_statement()
			}

		}
		{
			p.SetState(1631)
			p.Match(VerilogParserK_endfunction)
		}

	}

	return localctx
}

// IFunction_item_declarationContext is an interface to support dynamic dispatch.
type IFunction_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_item_declarationContext differentiates from other interfaces.
	IsFunction_item_declarationContext()
}

type Function_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_item_declarationContext() *Function_item_declarationContext {
	var p = new(Function_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_item_declaration
	return p
}

func (*Function_item_declarationContext) IsFunction_item_declarationContext() {}

func NewFunction_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_item_declarationContext {
	var p = new(Function_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_item_declaration

	return p
}

func (s *Function_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_item_declarationContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_item_declarationContext) Tf_declaration() ITf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_declarationContext)
}

func (s *Function_item_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Function_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_item_declaration(s)
	}
}

func (s *Function_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_item_declaration(s)
	}
}

func (p *VerilogParser) Function_item_declaration() (localctx IFunction_item_declarationContext) {
	localctx = NewFunction_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, VerilogParserRULE_function_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1639)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_event, VerilogParserK_integer, VerilogParserK_localparam, VerilogParserK_parameter, VerilogParserK_real, VerilogParserK_realtime, VerilogParserK_reg, VerilogParserK_time, VerilogParserLeft_parenthes:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1635)
			p.Block_item_declaration()
		}

	case VerilogParserK_inout, VerilogParserK_input, VerilogParserK_output:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1636)
			p.Tf_declaration()
		}
		{
			p.SetState(1637)
			p.Match(VerilogParserSemicolon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_port_listContext is an interface to support dynamic dispatch.
type IFunction_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_port_listContext differentiates from other interfaces.
	IsFunction_port_listContext()
}

type Function_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_port_listContext() *Function_port_listContext {
	var p = new(Function_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_port_list
	return p
}

func (*Function_port_listContext) IsFunction_port_listContext() {}

func NewFunction_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_port_listContext {
	var p = new(Function_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_port_list

	return p
}

func (s *Function_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_port_listContext) AllFunction_port() []IFunction_portContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_portContext)(nil)).Elem())
	var tst = make([]IFunction_portContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_portContext)
		}
	}

	return tst
}

func (s *Function_port_listContext) Function_port(i int) IFunction_portContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_portContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_portContext)
}

func (s *Function_port_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Function_port_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Function_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_port_list(s)
	}
}

func (s *Function_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_port_list(s)
	}
}

func (p *VerilogParser) Function_port_list() (localctx IFunction_port_listContext) {
	localctx = NewFunction_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, VerilogParserRULE_function_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1641)
		p.Function_port()
	}
	p.SetState(1646)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1642)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1643)
			p.Function_port()
		}

		p.SetState(1648)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunction_portContext is an interface to support dynamic dispatch.
type IFunction_portContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_portContext differentiates from other interfaces.
	IsFunction_portContext()
}

type Function_portContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_portContext() *Function_portContext {
	var p = new(Function_portContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_port
	return p
}

func (*Function_portContext) IsFunction_portContext() {}

func NewFunction_portContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_portContext {
	var p = new(Function_portContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_port

	return p
}

func (s *Function_portContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_portContext) Tf_declaration() ITf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_declarationContext)
}

func (s *Function_portContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_portContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_portContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_portContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_portContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_port(s)
	}
}

func (s *Function_portContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_port(s)
	}
}

func (p *VerilogParser) Function_port() (localctx IFunction_portContext) {
	localctx = NewFunction_portContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, VerilogParserRULE_function_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserLeft_parenthes {
		{
			p.SetState(1649)
			p.Attribute_instance()
		}

		p.SetState(1654)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1655)
		p.Tf_declaration()
	}

	return localctx
}

// IRange_or_typeContext is an interface to support dynamic dispatch.
type IRange_or_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_or_typeContext differentiates from other interfaces.
	IsRange_or_typeContext()
}

type Range_or_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_or_typeContext() *Range_or_typeContext {
	var p = new(Range_or_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_range_or_type
	return p
}

func (*Range_or_typeContext) IsRange_or_typeContext() {}

func NewRange_or_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_or_typeContext {
	var p = new(Range_or_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_range_or_type

	return p
}

func (s *Range_or_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_or_typeContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Range_or_typeContext) K_integer() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_integer, 0)
}

func (s *Range_or_typeContext) K_real() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_real, 0)
}

func (s *Range_or_typeContext) K_realtime() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_realtime, 0)
}

func (s *Range_or_typeContext) K_time() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_time, 0)
}

func (s *Range_or_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_or_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_or_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRange_or_type(s)
	}
}

func (s *Range_or_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRange_or_type(s)
	}
}

func (p *VerilogParser) Range_or_type() (localctx IRange_or_typeContext) {
	localctx = NewRange_or_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, VerilogParserRULE_range_or_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1662)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserLeft_bracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1657)
			p.Range_()
		}

	case VerilogParserK_integer:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1658)
			p.Match(VerilogParserK_integer)
		}

	case VerilogParserK_real:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1659)
			p.Match(VerilogParserK_real)
		}

	case VerilogParserK_realtime:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1660)
			p.Match(VerilogParserK_realtime)
		}

	case VerilogParserK_time:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1661)
			p.Match(VerilogParserK_time)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITask_declarationContext is an interface to support dynamic dispatch.
type ITask_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_declarationContext differentiates from other interfaces.
	IsTask_declarationContext()
}

type Task_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_declarationContext() *Task_declarationContext {
	var p = new(Task_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_declaration
	return p
}

func (*Task_declarationContext) IsTask_declarationContext() {}

func NewTask_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_declarationContext {
	var p = new(Task_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_declaration

	return p
}

func (s *Task_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_declarationContext) K_task() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_task, 0)
}

func (s *Task_declarationContext) Task_identifier() ITask_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_identifierContext)
}

func (s *Task_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Task_declarationContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Task_declarationContext) K_endtask() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_endtask, 0)
}

func (s *Task_declarationContext) K_automatic() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_automatic, 0)
}

func (s *Task_declarationContext) AllTask_item_declaration() []ITask_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITask_item_declarationContext)(nil)).Elem())
	var tst = make([]ITask_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITask_item_declarationContext)
		}
	}

	return tst
}

func (s *Task_declarationContext) Task_item_declaration(i int) ITask_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITask_item_declarationContext)
}

func (s *Task_declarationContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Task_declarationContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Task_declarationContext) Task_port_list() ITask_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_port_listContext)
}

func (s *Task_declarationContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Task_declarationContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Task_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_declaration(s)
	}
}

func (s *Task_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_declaration(s)
	}
}

func (p *VerilogParser) Task_declaration() (localctx ITask_declarationContext) {
	localctx = NewTask_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, VerilogParserRULE_task_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1699)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1664)
			p.Match(VerilogParserK_task)
		}
		p.SetState(1666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_automatic {
			{
				p.SetState(1665)
				p.Match(VerilogParserK_automatic)
			}

		}
		{
			p.SetState(1668)
			p.Task_identifier()
		}
		{
			p.SetState(1669)
			p.Match(VerilogParserSemicolon)
		}
		p.SetState(1673)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1670)
					p.Task_item_declaration()
				}

			}
			p.SetState(1675)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
		}
		{
			p.SetState(1676)
			p.Statement()
		}
		{
			p.SetState(1677)
			p.Match(VerilogParserK_endtask)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1679)
			p.Match(VerilogParserK_task)
		}
		p.SetState(1681)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_automatic {
			{
				p.SetState(1680)
				p.Match(VerilogParserK_automatic)
			}

		}
		{
			p.SetState(1683)
			p.Task_identifier()
		}
		{
			p.SetState(1684)
			p.Match(VerilogParserLeft_parenthes)
		}
		p.SetState(1686)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(VerilogParserK_inout-54))|(1<<(VerilogParserK_input-54))|(1<<(VerilogParserK_output-54)))) != 0) || _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1685)
				p.Task_port_list()
			}

		}
		{
			p.SetState(1688)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(1689)
			p.Match(VerilogParserSemicolon)
		}
		p.SetState(1693)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1690)
					p.Block_item_declaration()
				}

			}
			p.SetState(1695)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())
		}
		{
			p.SetState(1696)
			p.Statement()
		}
		{
			p.SetState(1697)
			p.Match(VerilogParserK_endtask)
		}

	}

	return localctx
}

// ITask_item_declarationContext is an interface to support dynamic dispatch.
type ITask_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_item_declarationContext differentiates from other interfaces.
	IsTask_item_declarationContext()
}

type Task_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_item_declarationContext() *Task_item_declarationContext {
	var p = new(Task_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_item_declaration
	return p
}

func (*Task_item_declarationContext) IsTask_item_declarationContext() {}

func NewTask_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_item_declarationContext {
	var p = new(Task_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_item_declaration

	return p
}

func (s *Task_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_item_declarationContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Task_item_declarationContext) Tf_declaration() ITf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_declarationContext)
}

func (s *Task_item_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Task_item_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Task_item_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Task_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_item_declaration(s)
	}
}

func (s *Task_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_item_declaration(s)
	}
}

func (p *VerilogParser) Task_item_declaration() (localctx ITask_item_declarationContext) {
	localctx = NewTask_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, VerilogParserRULE_task_item_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1711)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1701)
			p.Block_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1705)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1702)
				p.Attribute_instance()
			}

			p.SetState(1707)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1708)
			p.Tf_declaration()
		}
		{
			p.SetState(1709)
			p.Match(VerilogParserSemicolon)
		}

	}

	return localctx
}

// ITask_port_listContext is an interface to support dynamic dispatch.
type ITask_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_port_listContext differentiates from other interfaces.
	IsTask_port_listContext()
}

type Task_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_port_listContext() *Task_port_listContext {
	var p = new(Task_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_port_list
	return p
}

func (*Task_port_listContext) IsTask_port_listContext() {}

func NewTask_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_port_listContext {
	var p = new(Task_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_port_list

	return p
}

func (s *Task_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_port_listContext) AllTask_port_item() []ITask_port_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITask_port_itemContext)(nil)).Elem())
	var tst = make([]ITask_port_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITask_port_itemContext)
		}
	}

	return tst
}

func (s *Task_port_listContext) Task_port_item(i int) ITask_port_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITask_port_itemContext)
}

func (s *Task_port_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Task_port_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Task_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_port_list(s)
	}
}

func (s *Task_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_port_list(s)
	}
}

func (p *VerilogParser) Task_port_list() (localctx ITask_port_listContext) {
	localctx = NewTask_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, VerilogParserRULE_task_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1713)
		p.Task_port_item()
	}
	p.SetState(1718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1714)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1715)
			p.Task_port_item()
		}

		p.SetState(1720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITask_port_itemContext is an interface to support dynamic dispatch.
type ITask_port_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_port_itemContext differentiates from other interfaces.
	IsTask_port_itemContext()
}

type Task_port_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_port_itemContext() *Task_port_itemContext {
	var p = new(Task_port_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_port_item
	return p
}

func (*Task_port_itemContext) IsTask_port_itemContext() {}

func NewTask_port_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_port_itemContext {
	var p = new(Task_port_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_port_item

	return p
}

func (s *Task_port_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_port_itemContext) Tf_declaration() ITf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_declarationContext)
}

func (s *Task_port_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Task_port_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Task_port_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_port_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_port_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_port_item(s)
	}
}

func (s *Task_port_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_port_item(s)
	}
}

func (p *VerilogParser) Task_port_item() (localctx ITask_port_itemContext) {
	localctx = NewTask_port_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, VerilogParserRULE_task_port_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1724)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserLeft_parenthes {
		{
			p.SetState(1721)
			p.Attribute_instance()
		}

		p.SetState(1726)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1727)
		p.Tf_declaration()
	}

	return localctx
}

// ITf_decl_headerContext is an interface to support dynamic dispatch.
type ITf_decl_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_decl_headerContext differentiates from other interfaces.
	IsTf_decl_headerContext()
}

type Tf_decl_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_decl_headerContext() *Tf_decl_headerContext {
	var p = new(Tf_decl_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tf_decl_header
	return p
}

func (*Tf_decl_headerContext) IsTf_decl_headerContext() {}

func NewTf_decl_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_decl_headerContext {
	var p = new(Tf_decl_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tf_decl_header

	return p
}

func (s *Tf_decl_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_decl_headerContext) K_input() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_input, 0)
}

func (s *Tf_decl_headerContext) K_output() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_output, 0)
}

func (s *Tf_decl_headerContext) K_inout() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_inout, 0)
}

func (s *Tf_decl_headerContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Tf_decl_headerContext) K_reg() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_reg, 0)
}

func (s *Tf_decl_headerContext) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Tf_decl_headerContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Tf_decl_headerContext) Task_port_type() ITask_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_port_typeContext)
}

func (s *Tf_decl_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_decl_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_decl_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTf_decl_header(s)
	}
}

func (s *Tf_decl_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTf_decl_header(s)
	}
}

func (p *VerilogParser) Tf_decl_header() (localctx ITf_decl_headerContext) {
	localctx = NewTf_decl_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, VerilogParserRULE_tf_decl_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1749)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1729)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(VerilogParserK_inout-54))|(1<<(VerilogParserK_input-54))|(1<<(VerilogParserK_output-54)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(VerilogParserK_supply0-104))|(1<<(VerilogParserK_supply1-104))|(1<<(VerilogParserK_tri-104))|(1<<(VerilogParserK_tri0-104))|(1<<(VerilogParserK_tri1-104))|(1<<(VerilogParserK_triand-104))|(1<<(VerilogParserK_trior-104))|(1<<(VerilogParserK_wand-104))|(1<<(VerilogParserK_wire-104))|(1<<(VerilogParserK_wor-104)))) != 0 {
			{
				p.SetState(1730)
				p.Net_type()
			}

		}
		p.SetState(1734)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_reg {
			{
				p.SetState(1733)
				p.Match(VerilogParserK_reg)
			}

		}
		p.SetState(1737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_signed {
			{
				p.SetState(1736)
				p.Match(VerilogParserK_signed)
			}

		}
		p.SetState(1740)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserLeft_bracket {
			{
				p.SetState(1739)
				p.Range_()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1742)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(VerilogParserK_inout-54))|(1<<(VerilogParserK_input-54))|(1<<(VerilogParserK_output-54)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1744)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(VerilogParserK_supply0-104))|(1<<(VerilogParserK_supply1-104))|(1<<(VerilogParserK_tri-104))|(1<<(VerilogParserK_tri0-104))|(1<<(VerilogParserK_tri1-104))|(1<<(VerilogParserK_triand-104))|(1<<(VerilogParserK_trior-104))|(1<<(VerilogParserK_wand-104))|(1<<(VerilogParserK_wire-104))|(1<<(VerilogParserK_wor-104)))) != 0 {
			{
				p.SetState(1743)
				p.Net_type()
			}

		}
		p.SetState(1747)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(VerilogParserK_integer-57))|(1<<(VerilogParserK_real-57))|(1<<(VerilogParserK_realtime-57)))) != 0) || _la == VerilogParserK_time {
			{
				p.SetState(1746)
				p.Task_port_type()
			}

		}

	}

	return localctx
}

// ITf_declarationContext is an interface to support dynamic dispatch.
type ITf_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_declarationContext differentiates from other interfaces.
	IsTf_declarationContext()
}

type Tf_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_declarationContext() *Tf_declarationContext {
	var p = new(Tf_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tf_declaration
	return p
}

func (*Tf_declarationContext) IsTf_declarationContext() {}

func NewTf_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_declarationContext {
	var p = new(Tf_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tf_declaration

	return p
}

func (s *Tf_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_declarationContext) Tf_decl_header() ITf_decl_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_decl_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_decl_headerContext)
}

func (s *Tf_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Tf_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTf_declaration(s)
	}
}

func (s *Tf_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTf_declaration(s)
	}
}

func (p *VerilogParser) Tf_declaration() (localctx ITf_declarationContext) {
	localctx = NewTf_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, VerilogParserRULE_tf_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1751)
		p.Tf_decl_header()
	}
	{
		p.SetState(1752)
		p.List_of_port_identifiers()
	}

	return localctx
}

// ITask_port_typeContext is an interface to support dynamic dispatch.
type ITask_port_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_port_typeContext differentiates from other interfaces.
	IsTask_port_typeContext()
}

type Task_port_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_port_typeContext() *Task_port_typeContext {
	var p = new(Task_port_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_port_type
	return p
}

func (*Task_port_typeContext) IsTask_port_typeContext() {}

func NewTask_port_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_port_typeContext {
	var p = new(Task_port_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_port_type

	return p
}

func (s *Task_port_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_port_typeContext) K_time() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_time, 0)
}

func (s *Task_port_typeContext) K_real() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_real, 0)
}

func (s *Task_port_typeContext) K_realtime() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_realtime, 0)
}

func (s *Task_port_typeContext) K_integer() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_integer, 0)
}

func (s *Task_port_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_port_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_port_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_port_type(s)
	}
}

func (s *Task_port_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_port_type(s)
	}
}

func (p *VerilogParser) Task_port_type() (localctx ITask_port_typeContext) {
	localctx = NewTask_port_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, VerilogParserRULE_task_port_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1754)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(VerilogParserK_integer-57))|(1<<(VerilogParserK_real-57))|(1<<(VerilogParserK_realtime-57)))) != 0) || _la == VerilogParserK_time) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBlock_item_declarationContext is an interface to support dynamic dispatch.
type IBlock_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_item_declarationContext differentiates from other interfaces.
	IsBlock_item_declarationContext()
}

type Block_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_item_declarationContext() *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_item_declaration
	return p
}

func (*Block_item_declarationContext) IsBlock_item_declarationContext() {}

func NewBlock_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_item_declaration

	return p
}

func (s *Block_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_item_declarationContext) Block_reg_declaration() IBlock_reg_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_reg_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_reg_declarationContext)
}

func (s *Block_item_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Block_item_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Block_item_declarationContext) Event_declaration() IEvent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declarationContext)
}

func (s *Block_item_declarationContext) Integer_declaration() IInteger_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_declarationContext)
}

func (s *Block_item_declarationContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Block_item_declarationContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Block_item_declarationContext) Real_declaration() IReal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_declarationContext)
}

func (s *Block_item_declarationContext) Realtime_declaration() IRealtime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRealtime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRealtime_declarationContext)
}

func (s *Block_item_declarationContext) Time_declaration() ITime_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_declarationContext)
}

func (s *Block_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlock_item_declaration(s)
	}
}

func (s *Block_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlock_item_declaration(s)
	}
}

func (p *VerilogParser) Block_item_declaration() (localctx IBlock_item_declarationContext) {
	localctx = NewBlock_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, VerilogParserRULE_block_item_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1812)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1759)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1756)
				p.Attribute_instance()
			}

			p.SetState(1761)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1762)
			p.Block_reg_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1763)
				p.Attribute_instance()
			}

			p.SetState(1768)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1769)
			p.Event_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1770)
				p.Attribute_instance()
			}

			p.SetState(1775)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1776)
			p.Integer_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1780)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1777)
				p.Attribute_instance()
			}

			p.SetState(1782)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1783)
			p.Local_parameter_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1787)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1784)
				p.Attribute_instance()
			}

			p.SetState(1789)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1790)
			p.Parameter_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1794)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1791)
				p.Attribute_instance()
			}

			p.SetState(1796)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1797)
			p.Real_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(1801)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1798)
				p.Attribute_instance()
			}

			p.SetState(1803)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1804)
			p.Realtime_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1808)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(1805)
				p.Attribute_instance()
			}

			p.SetState(1810)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1811)
			p.Time_declaration()
		}

	}

	return localctx
}

// IBlock_reg_declarationContext is an interface to support dynamic dispatch.
type IBlock_reg_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_reg_declarationContext differentiates from other interfaces.
	IsBlock_reg_declarationContext()
}

type Block_reg_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_reg_declarationContext() *Block_reg_declarationContext {
	var p = new(Block_reg_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_reg_declaration
	return p
}

func (*Block_reg_declarationContext) IsBlock_reg_declarationContext() {}

func NewBlock_reg_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_reg_declarationContext {
	var p = new(Block_reg_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_reg_declaration

	return p
}

func (s *Block_reg_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_reg_declarationContext) K_reg() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_reg, 0)
}

func (s *Block_reg_declarationContext) List_of_block_variable_identifiers() IList_of_block_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_block_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_block_variable_identifiersContext)
}

func (s *Block_reg_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Block_reg_declarationContext) K_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_signed, 0)
}

func (s *Block_reg_declarationContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Block_reg_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_reg_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_reg_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlock_reg_declaration(s)
	}
}

func (s *Block_reg_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlock_reg_declaration(s)
	}
}

func (p *VerilogParser) Block_reg_declaration() (localctx IBlock_reg_declarationContext) {
	localctx = NewBlock_reg_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, VerilogParserRULE_block_reg_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1814)
		p.Match(VerilogParserK_reg)
	}
	p.SetState(1816)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_signed {
		{
			p.SetState(1815)
			p.Match(VerilogParserK_signed)
		}

	}
	p.SetState(1819)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_bracket {
		{
			p.SetState(1818)
			p.Range_()
		}

	}
	{
		p.SetState(1821)
		p.List_of_block_variable_identifiers()
	}
	{
		p.SetState(1822)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IList_of_block_variable_identifiersContext is an interface to support dynamic dispatch.
type IList_of_block_variable_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_block_variable_identifiersContext differentiates from other interfaces.
	IsList_of_block_variable_identifiersContext()
}

type List_of_block_variable_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_block_variable_identifiersContext() *List_of_block_variable_identifiersContext {
	var p = new(List_of_block_variable_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_block_variable_identifiers
	return p
}

func (*List_of_block_variable_identifiersContext) IsList_of_block_variable_identifiersContext() {}

func NewList_of_block_variable_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_block_variable_identifiersContext {
	var p = new(List_of_block_variable_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_block_variable_identifiers

	return p
}

func (s *List_of_block_variable_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_block_variable_identifiersContext) AllBlock_variable_type() []IBlock_variable_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_variable_typeContext)(nil)).Elem())
	var tst = make([]IBlock_variable_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_variable_typeContext)
		}
	}

	return tst
}

func (s *List_of_block_variable_identifiersContext) Block_variable_type(i int) IBlock_variable_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_variable_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_variable_typeContext)
}

func (s *List_of_block_variable_identifiersContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_block_variable_identifiersContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_block_variable_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_block_variable_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_block_variable_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_block_variable_identifiers(s)
	}
}

func (s *List_of_block_variable_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_block_variable_identifiers(s)
	}
}

func (p *VerilogParser) List_of_block_variable_identifiers() (localctx IList_of_block_variable_identifiersContext) {
	localctx = NewList_of_block_variable_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, VerilogParserRULE_list_of_block_variable_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1824)
		p.Block_variable_type()
	}
	p.SetState(1829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(1825)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(1826)
			p.Block_variable_type()
		}

		p.SetState(1831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlock_variable_typeContext is an interface to support dynamic dispatch.
type IBlock_variable_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_variable_typeContext differentiates from other interfaces.
	IsBlock_variable_typeContext()
}

type Block_variable_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_variable_typeContext() *Block_variable_typeContext {
	var p = new(Block_variable_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_variable_type
	return p
}

func (*Block_variable_typeContext) IsBlock_variable_typeContext() {}

func NewBlock_variable_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_variable_typeContext {
	var p = new(Block_variable_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_variable_type

	return p
}

func (s *Block_variable_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_variable_typeContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Block_variable_typeContext) AllDimension() []IDimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDimensionContext)(nil)).Elem())
	var tst = make([]IDimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDimensionContext)
		}
	}

	return tst
}

func (s *Block_variable_typeContext) Dimension(i int) IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Block_variable_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_variable_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_variable_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlock_variable_type(s)
	}
}

func (s *Block_variable_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlock_variable_type(s)
	}
}

func (p *VerilogParser) Block_variable_type() (localctx IBlock_variable_typeContext) {
	localctx = NewBlock_variable_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, VerilogParserRULE_block_variable_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1841)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1832)
			p.Variable_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1833)
			p.Variable_identifier()
		}
		{
			p.SetState(1834)
			p.Dimension()
		}
		p.SetState(1838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_bracket {
			{
				p.SetState(1835)
				p.Dimension()
			}

			p.SetState(1840)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IGate_instantiationContext is an interface to support dynamic dispatch.
type IGate_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGate_instantiationContext differentiates from other interfaces.
	IsGate_instantiationContext()
}

type Gate_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGate_instantiationContext() *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_gate_instantiation
	return p
}

func (*Gate_instantiationContext) IsGate_instantiationContext() {}

func NewGate_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_gate_instantiation

	return p
}

func (s *Gate_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Gate_instantiationContext) Cmos_switchtype() ICmos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmos_switchtypeContext)
}

func (s *Gate_instantiationContext) AllCmos_switch_instance() []ICmos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem())
	var tst = make([]ICmos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICmos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Cmos_switch_instance(i int) ICmos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICmos_switch_instanceContext)
}

func (s *Gate_instantiationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Gate_instantiationContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Gate_instantiationContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Gate_instantiationContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Gate_instantiationContext) Mos_switchtype() IMos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMos_switchtypeContext)
}

func (s *Gate_instantiationContext) AllMos_switch_instance() []IMos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem())
	var tst = make([]IMos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Mos_switch_instance(i int) IMos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMos_switch_instanceContext)
}

func (s *Gate_instantiationContext) Pass_switchtype() IPass_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_switchtypeContext)
}

func (s *Gate_instantiationContext) AllPass_switch_instance() []IPass_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem())
	var tst = make([]IPass_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPass_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pass_switch_instance(i int) IPass_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPass_switch_instanceContext)
}

func (s *Gate_instantiationContext) K_pulldown() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_pulldown, 0)
}

func (s *Gate_instantiationContext) AllPull_gate_instance() []IPull_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem())
	var tst = make([]IPull_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPull_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pull_gate_instance(i int) IPull_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPull_gate_instanceContext)
}

func (s *Gate_instantiationContext) Pulldown_strength() IPulldown_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulldown_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulldown_strengthContext)
}

func (s *Gate_instantiationContext) K_pullup() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_pullup, 0)
}

func (s *Gate_instantiationContext) Pullup_strength() IPullup_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPullup_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPullup_strengthContext)
}

func (s *Gate_instantiationContext) Enable_gatetype() IEnable_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_gatetypeContext)
}

func (s *Gate_instantiationContext) AllEnable_gate_instance() []IEnable_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem())
	var tst = make([]IEnable_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnable_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Enable_gate_instance(i int) IEnable_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnable_gate_instanceContext)
}

func (s *Gate_instantiationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Gate_instantiationContext) N_input_gatetype() IN_input_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_input_gatetypeContext)
}

func (s *Gate_instantiationContext) AllN_input_gate_instance() []IN_input_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem())
	var tst = make([]IN_input_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IN_input_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) N_input_gate_instance(i int) IN_input_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IN_input_gate_instanceContext)
}

func (s *Gate_instantiationContext) Delay2() IDelay2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay2Context)
}

func (s *Gate_instantiationContext) N_output_gatetype() IN_output_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_output_gatetypeContext)
}

func (s *Gate_instantiationContext) AllN_output_gate_instance() []IN_output_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem())
	var tst = make([]IN_output_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IN_output_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) N_output_gate_instance(i int) IN_output_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IN_output_gate_instanceContext)
}

func (s *Gate_instantiationContext) Pass_en_switchtype() IPass_en_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_en_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_en_switchtypeContext)
}

func (s *Gate_instantiationContext) AllPass_enable_switch_instance() []IPass_enable_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem())
	var tst = make([]IPass_enable_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPass_enable_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pass_enable_switch_instance(i int) IPass_enable_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPass_enable_switch_instanceContext)
}

func (s *Gate_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Gate_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Gate_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGate_instantiation(s)
	}
}

func (s *Gate_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGate_instantiation(s)
	}
}

func (p *VerilogParser) Gate_instantiation() (localctx IGate_instantiationContext) {
	localctx = NewGate_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, VerilogParserRULE_gate_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1975)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_cmos, VerilogParserK_rcmos:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1843)
			p.Cmos_switchtype()
		}
		p.SetState(1845)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1844)
				p.Delay3()
			}

		}
		{
			p.SetState(1847)
			p.Cmos_switch_instance()
		}
		p.SetState(1852)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(1848)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1849)
				p.Cmos_switch_instance()
			}

			p.SetState(1854)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1855)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_nmos, VerilogParserK_pmos, VerilogParserK_rnmos, VerilogParserK_rpmos:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1857)
			p.Mos_switchtype()
		}
		p.SetState(1859)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1858)
				p.Delay3()
			}

		}
		{
			p.SetState(1861)
			p.Mos_switch_instance()
		}
		p.SetState(1866)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(1862)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1863)
				p.Mos_switch_instance()
			}

			p.SetState(1868)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1869)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_rtran, VerilogParserK_tran:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1871)
			p.Pass_switchtype()
		}
		{
			p.SetState(1872)
			p.Pass_switch_instance()
		}
		p.SetState(1877)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(1873)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1874)
				p.Pass_switch_instance()
			}

			p.SetState(1879)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1880)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_pulldown:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1882)
			p.Match(VerilogParserK_pulldown)
		}
		p.SetState(1884)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1883)
				p.Pulldown_strength()
			}

		}
		{
			p.SetState(1886)
			p.Pull_gate_instance()
		}
		p.SetState(1891)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(1887)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1888)
				p.Pull_gate_instance()
			}

			p.SetState(1893)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1894)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_pullup:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1896)
			p.Match(VerilogParserK_pullup)
		}
		p.SetState(1898)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1897)
				p.Pullup_strength()
			}

		}
		{
			p.SetState(1900)
			p.Pull_gate_instance()
		}
		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(1901)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1902)
				p.Pull_gate_instance()
			}

			p.SetState(1907)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1908)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_bufif0, VerilogParserK_bufif1, VerilogParserK_notif0, VerilogParserK_notif1:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1910)
			p.Enable_gatetype()
		}
		p.SetState(1912)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_highz0 || _la == VerilogParserK_highz1 || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserK_pull0-79))|(1<<(VerilogParserK_pull1-79))|(1<<(VerilogParserK_strong0-79))|(1<<(VerilogParserK_strong1-79))|(1<<(VerilogParserK_supply0-79))|(1<<(VerilogParserK_supply1-79)))) != 0) || _la == VerilogParserK_weak0 || _la == VerilogParserK_weak1 {
			{
				p.SetState(1911)
				p.Drive_strength()
			}

		}
		p.SetState(1915)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1914)
				p.Delay3()
			}

		}
		{
			p.SetState(1917)
			p.Enable_gate_instance()
		}
		p.SetState(1922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(1918)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1919)
				p.Enable_gate_instance()
			}

			p.SetState(1924)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1925)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_and, VerilogParserK_nand, VerilogParserK_nor, VerilogParserK_or, VerilogParserK_xnor, VerilogParserK_xor:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1927)
			p.N_input_gatetype()
		}
		p.SetState(1929)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_highz0 || _la == VerilogParserK_highz1 || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserK_pull0-79))|(1<<(VerilogParserK_pull1-79))|(1<<(VerilogParserK_strong0-79))|(1<<(VerilogParserK_strong1-79))|(1<<(VerilogParserK_supply0-79))|(1<<(VerilogParserK_supply1-79)))) != 0) || _la == VerilogParserK_weak0 || _la == VerilogParserK_weak1 {
			{
				p.SetState(1928)
				p.Drive_strength()
			}

		}
		p.SetState(1932)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1931)
				p.Delay2()
			}

		}
		{
			p.SetState(1934)
			p.N_input_gate_instance()
		}
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(1935)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1936)
				p.N_input_gate_instance()
			}

			p.SetState(1941)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1942)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_buf, VerilogParserK_not:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1944)
			p.N_output_gatetype()
		}
		p.SetState(1946)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserK_highz0 || _la == VerilogParserK_highz1 || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserK_pull0-79))|(1<<(VerilogParserK_pull1-79))|(1<<(VerilogParserK_strong0-79))|(1<<(VerilogParserK_strong1-79))|(1<<(VerilogParserK_supply0-79))|(1<<(VerilogParserK_supply1-79)))) != 0) || _la == VerilogParserK_weak0 || _la == VerilogParserK_weak1 {
			{
				p.SetState(1945)
				p.Drive_strength()
			}

		}
		p.SetState(1949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1948)
				p.Delay2()
			}

		}
		{
			p.SetState(1951)
			p.N_output_gate_instance()
		}
		p.SetState(1956)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(1952)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1953)
				p.N_output_gate_instance()
			}

			p.SetState(1958)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1959)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_rtranif0, VerilogParserK_rtranif1, VerilogParserK_tranif0, VerilogParserK_tranif1:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1961)
			p.Pass_en_switchtype()
		}
		p.SetState(1963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserSharp {
			{
				p.SetState(1962)
				p.Delay2()
			}

		}
		{
			p.SetState(1965)
			p.Pass_enable_switch_instance()
		}
		p.SetState(1970)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(1966)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(1967)
				p.Pass_enable_switch_instance()
			}

			p.SetState(1972)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1973)
			p.Match(VerilogParserSemicolon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICmos_switch_instanceContext is an interface to support dynamic dispatch.
type ICmos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switch_instanceContext differentiates from other interfaces.
	IsCmos_switch_instanceContext()
}

type Cmos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switch_instanceContext() *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cmos_switch_instance
	return p
}

func (*Cmos_switch_instanceContext) IsCmos_switch_instanceContext() {}

func NewCmos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cmos_switch_instance

	return p
}

func (s *Cmos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switch_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Cmos_switch_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Cmos_switch_instanceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Cmos_switch_instanceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Cmos_switch_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Cmos_switch_instanceContext) Ncontrol_terminal() INcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INcontrol_terminalContext)
}

func (s *Cmos_switch_instanceContext) Pcontrol_terminal() IPcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPcontrol_terminalContext)
}

func (s *Cmos_switch_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Cmos_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Cmos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCmos_switch_instance(s)
	}
}

func (s *Cmos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCmos_switch_instance(s)
	}
}

func (p *VerilogParser) Cmos_switch_instance() (localctx ICmos_switch_instanceContext) {
	localctx = NewCmos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, VerilogParserRULE_cmos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1978)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(1977)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(1980)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(1981)
		p.Output_terminal()
	}
	{
		p.SetState(1982)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(1983)
		p.Input_terminal()
	}
	{
		p.SetState(1984)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(1985)
		p.Ncontrol_terminal()
	}
	{
		p.SetState(1986)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(1987)
		p.Pcontrol_terminal()
	}
	{
		p.SetState(1988)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IEnable_gate_instanceContext is an interface to support dynamic dispatch.
type IEnable_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gate_instanceContext differentiates from other interfaces.
	IsEnable_gate_instanceContext()
}

type Enable_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gate_instanceContext() *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_enable_gate_instance
	return p
}

func (*Enable_gate_instanceContext) IsEnable_gate_instanceContext() {}

func NewEnable_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_enable_gate_instance

	return p
}

func (s *Enable_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gate_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Enable_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Enable_gate_instanceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Enable_gate_instanceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Enable_gate_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Enable_gate_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Enable_gate_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Enable_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Enable_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEnable_gate_instance(s)
	}
}

func (s *Enable_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEnable_gate_instance(s)
	}
}

func (p *VerilogParser) Enable_gate_instance() (localctx IEnable_gate_instanceContext) {
	localctx = NewEnable_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, VerilogParserRULE_enable_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1991)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(1990)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(1993)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(1994)
		p.Output_terminal()
	}
	{
		p.SetState(1995)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(1996)
		p.Input_terminal()
	}
	{
		p.SetState(1997)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(1998)
		p.Enable_terminal()
	}
	{
		p.SetState(1999)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IMos_switch_instanceContext is an interface to support dynamic dispatch.
type IMos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switch_instanceContext differentiates from other interfaces.
	IsMos_switch_instanceContext()
}

type Mos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switch_instanceContext() *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mos_switch_instance
	return p
}

func (*Mos_switch_instanceContext) IsMos_switch_instanceContext() {}

func NewMos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mos_switch_instance

	return p
}

func (s *Mos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switch_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Mos_switch_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Mos_switch_instanceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Mos_switch_instanceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Mos_switch_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Mos_switch_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Mos_switch_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Mos_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Mos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMos_switch_instance(s)
	}
}

func (s *Mos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMos_switch_instance(s)
	}
}

func (p *VerilogParser) Mos_switch_instance() (localctx IMos_switch_instanceContext) {
	localctx = NewMos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, VerilogParserRULE_mos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2002)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2001)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2004)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2005)
		p.Output_terminal()
	}
	{
		p.SetState(2006)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(2007)
		p.Input_terminal()
	}
	{
		p.SetState(2008)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(2009)
		p.Enable_terminal()
	}
	{
		p.SetState(2010)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IN_input_gate_instanceContext is an interface to support dynamic dispatch.
type IN_input_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gate_instanceContext differentiates from other interfaces.
	IsN_input_gate_instanceContext()
}

type N_input_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gate_instanceContext() *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_input_gate_instance
	return p
}

func (*N_input_gate_instanceContext) IsN_input_gate_instanceContext() {}

func NewN_input_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_input_gate_instance

	return p
}

func (s *N_input_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gate_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *N_input_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *N_input_gate_instanceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *N_input_gate_instanceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *N_input_gate_instanceContext) AllInput_terminal() []IInput_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem())
	var tst = make([]IInput_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInput_terminalContext)
		}
	}

	return tst
}

func (s *N_input_gate_instanceContext) Input_terminal(i int) IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *N_input_gate_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *N_input_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *N_input_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterN_input_gate_instance(s)
	}
}

func (s *N_input_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitN_input_gate_instance(s)
	}
}

func (p *VerilogParser) N_input_gate_instance() (localctx IN_input_gate_instanceContext) {
	localctx = NewN_input_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, VerilogParserRULE_n_input_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2013)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2012)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2015)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2016)
		p.Output_terminal()
	}
	{
		p.SetState(2017)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(2018)
		p.Input_terminal()
	}
	p.SetState(2023)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(2019)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(2020)
			p.Input_terminal()
		}

		p.SetState(2025)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2026)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IN_output_gate_instanceContext is an interface to support dynamic dispatch.
type IN_output_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gate_instanceContext differentiates from other interfaces.
	IsN_output_gate_instanceContext()
}

type N_output_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gate_instanceContext() *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_output_gate_instance
	return p
}

func (*N_output_gate_instanceContext) IsN_output_gate_instanceContext() {}

func NewN_output_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_output_gate_instance

	return p
}

func (s *N_output_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gate_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *N_output_gate_instanceContext) AllOutput_terminal() []IOutput_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem())
	var tst = make([]IOutput_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOutput_terminalContext)
		}
	}

	return tst
}

func (s *N_output_gate_instanceContext) Output_terminal(i int) IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *N_output_gate_instanceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *N_output_gate_instanceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *N_output_gate_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *N_output_gate_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *N_output_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *N_output_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterN_output_gate_instance(s)
	}
}

func (s *N_output_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitN_output_gate_instance(s)
	}
}

func (p *VerilogParser) N_output_gate_instance() (localctx IN_output_gate_instanceContext) {
	localctx = NewN_output_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, VerilogParserRULE_n_output_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2029)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2028)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2031)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2032)
		p.Output_terminal()
	}
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2033)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(2034)
				p.Output_terminal()
			}

		}
		p.SetState(2039)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())
	}
	{
		p.SetState(2040)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(2041)
		p.Input_terminal()
	}
	{
		p.SetState(2042)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IPass_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switch_instanceContext differentiates from other interfaces.
	IsPass_switch_instanceContext()
}

type Pass_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switch_instanceContext() *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_switch_instance
	return p
}

func (*Pass_switch_instanceContext) IsPass_switch_instanceContext() {}

func NewPass_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_switch_instance

	return p
}

func (s *Pass_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switch_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Pass_switch_instanceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_switch_instanceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_switch_instanceContext) Comma() antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, 0)
}

func (s *Pass_switch_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Pass_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Pass_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPass_switch_instance(s)
	}
}

func (s *Pass_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPass_switch_instance(s)
	}
}

func (p *VerilogParser) Pass_switch_instance() (localctx IPass_switch_instanceContext) {
	localctx = NewPass_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, VerilogParserRULE_pass_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2045)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2044)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2047)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2048)
		p.Inout_terminal()
	}
	{
		p.SetState(2049)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(2050)
		p.Inout_terminal()
	}
	{
		p.SetState(2051)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IPass_enable_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_enable_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_enable_switch_instanceContext differentiates from other interfaces.
	IsPass_enable_switch_instanceContext()
}

type Pass_enable_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_enable_switch_instanceContext() *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_enable_switch_instance
	return p
}

func (*Pass_enable_switch_instanceContext) IsPass_enable_switch_instanceContext() {}

func NewPass_enable_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_enable_switch_instance

	return p
}

func (s *Pass_enable_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_enable_switch_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Pass_enable_switch_instanceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_enable_switch_instanceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_enable_switch_instanceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Pass_enable_switch_instanceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Pass_enable_switch_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Pass_enable_switch_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Pass_enable_switch_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Pass_enable_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_enable_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_enable_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPass_enable_switch_instance(s)
	}
}

func (s *Pass_enable_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPass_enable_switch_instance(s)
	}
}

func (p *VerilogParser) Pass_enable_switch_instance() (localctx IPass_enable_switch_instanceContext) {
	localctx = NewPass_enable_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, VerilogParserRULE_pass_enable_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2054)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2053)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2056)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2057)
		p.Inout_terminal()
	}
	{
		p.SetState(2058)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(2059)
		p.Inout_terminal()
	}
	{
		p.SetState(2060)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(2061)
		p.Enable_terminal()
	}
	{
		p.SetState(2062)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IPull_gate_instanceContext is an interface to support dynamic dispatch.
type IPull_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPull_gate_instanceContext differentiates from other interfaces.
	IsPull_gate_instanceContext()
}

type Pull_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPull_gate_instanceContext() *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pull_gate_instance
	return p
}

func (*Pull_gate_instanceContext) IsPull_gate_instanceContext() {}

func NewPull_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pull_gate_instance

	return p
}

func (s *Pull_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pull_gate_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Pull_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Pull_gate_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Pull_gate_instanceContext) Name_of_gate_instance() IName_of_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_gate_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_gate_instanceContext)
}

func (s *Pull_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pull_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pull_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPull_gate_instance(s)
	}
}

func (s *Pull_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPull_gate_instance(s)
	}
}

func (p *VerilogParser) Pull_gate_instance() (localctx IPull_gate_instanceContext) {
	localctx = NewPull_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, VerilogParserRULE_pull_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2065)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2064)
			p.Name_of_gate_instance()
		}

	}
	{
		p.SetState(2067)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2068)
		p.Output_terminal()
	}
	{
		p.SetState(2069)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IName_of_gate_instanceContext is an interface to support dynamic dispatch.
type IName_of_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_of_gate_instanceContext differentiates from other interfaces.
	IsName_of_gate_instanceContext()
}

type Name_of_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_of_gate_instanceContext() *Name_of_gate_instanceContext {
	var p = new(Name_of_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_name_of_gate_instance
	return p
}

func (*Name_of_gate_instanceContext) IsName_of_gate_instanceContext() {}

func NewName_of_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_of_gate_instanceContext {
	var p = new(Name_of_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_name_of_gate_instance

	return p
}

func (s *Name_of_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_of_gate_instanceContext) Gate_instance_identifier() IGate_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instance_identifierContext)
}

func (s *Name_of_gate_instanceContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Name_of_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_of_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_of_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterName_of_gate_instance(s)
	}
}

func (s *Name_of_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitName_of_gate_instance(s)
	}
}

func (p *VerilogParser) Name_of_gate_instance() (localctx IName_of_gate_instanceContext) {
	localctx = NewName_of_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, VerilogParserRULE_name_of_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2071)
		p.Gate_instance_identifier()
	}
	p.SetState(2073)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_bracket {
		{
			p.SetState(2072)
			p.Range_()
		}

	}

	return localctx
}

// IPulldown_strengthContext is an interface to support dynamic dispatch.
type IPulldown_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulldown_strengthContext differentiates from other interfaces.
	IsPulldown_strengthContext()
}

type Pulldown_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulldown_strengthContext() *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pulldown_strength
	return p
}

func (*Pulldown_strengthContext) IsPulldown_strengthContext() {}

func NewPulldown_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pulldown_strength

	return p
}

func (s *Pulldown_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulldown_strengthContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Pulldown_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pulldown_strengthContext) Comma() antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, 0)
}

func (s *Pulldown_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pulldown_strengthContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Pulldown_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulldown_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulldown_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPulldown_strength(s)
	}
}

func (s *Pulldown_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPulldown_strength(s)
	}
}

func (p *VerilogParser) Pulldown_strength() (localctx IPulldown_strengthContext) {
	localctx = NewPulldown_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, VerilogParserRULE_pulldown_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2091)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2075)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2076)
			p.Strength0()
		}
		{
			p.SetState(2077)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(2078)
			p.Strength1()
		}
		{
			p.SetState(2079)
			p.Match(VerilogParserRight_parenthes)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2081)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2082)
			p.Strength1()
		}
		{
			p.SetState(2083)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(2084)
			p.Strength0()
		}
		{
			p.SetState(2085)
			p.Match(VerilogParserRight_parenthes)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2087)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2088)
			p.Strength0()
		}
		{
			p.SetState(2089)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IPullup_strengthContext is an interface to support dynamic dispatch.
type IPullup_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPullup_strengthContext differentiates from other interfaces.
	IsPullup_strengthContext()
}

type Pullup_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPullup_strengthContext() *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pullup_strength
	return p
}

func (*Pullup_strengthContext) IsPullup_strengthContext() {}

func NewPullup_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pullup_strength

	return p
}

func (s *Pullup_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pullup_strengthContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Pullup_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pullup_strengthContext) Comma() antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, 0)
}

func (s *Pullup_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pullup_strengthContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Pullup_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pullup_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pullup_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPullup_strength(s)
	}
}

func (s *Pullup_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPullup_strength(s)
	}
}

func (p *VerilogParser) Pullup_strength() (localctx IPullup_strengthContext) {
	localctx = NewPullup_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, VerilogParserRULE_pullup_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2109)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2093)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2094)
			p.Strength0()
		}
		{
			p.SetState(2095)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(2096)
			p.Strength1()
		}
		{
			p.SetState(2097)
			p.Match(VerilogParserRight_parenthes)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2099)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2100)
			p.Strength1()
		}
		{
			p.SetState(2101)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(2102)
			p.Strength0()
		}
		{
			p.SetState(2103)
			p.Match(VerilogParserRight_parenthes)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2105)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2106)
			p.Strength1()
		}
		{
			p.SetState(2107)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IEnable_terminalContext is an interface to support dynamic dispatch.
type IEnable_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_terminalContext differentiates from other interfaces.
	IsEnable_terminalContext()
}

type Enable_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_terminalContext() *Enable_terminalContext {
	var p = new(Enable_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_enable_terminal
	return p
}

func (*Enable_terminalContext) IsEnable_terminalContext() {}

func NewEnable_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_terminalContext {
	var p = new(Enable_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_enable_terminal

	return p
}

func (s *Enable_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Enable_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEnable_terminal(s)
	}
}

func (s *Enable_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEnable_terminal(s)
	}
}

func (p *VerilogParser) Enable_terminal() (localctx IEnable_terminalContext) {
	localctx = NewEnable_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, VerilogParserRULE_enable_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2111)
		p.Expression()
	}

	return localctx
}

// INcontrol_terminalContext is an interface to support dynamic dispatch.
type INcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNcontrol_terminalContext differentiates from other interfaces.
	IsNcontrol_terminalContext()
}

type Ncontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNcontrol_terminalContext() *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_ncontrol_terminal
	return p
}

func (*Ncontrol_terminalContext) IsNcontrol_terminalContext() {}

func NewNcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_ncontrol_terminal

	return p
}

func (s *Ncontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Ncontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ncontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ncontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ncontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNcontrol_terminal(s)
	}
}

func (s *Ncontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNcontrol_terminal(s)
	}
}

func (p *VerilogParser) Ncontrol_terminal() (localctx INcontrol_terminalContext) {
	localctx = NewNcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, VerilogParserRULE_ncontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2113)
		p.Expression()
	}

	return localctx
}

// IPcontrol_terminalContext is an interface to support dynamic dispatch.
type IPcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPcontrol_terminalContext differentiates from other interfaces.
	IsPcontrol_terminalContext()
}

type Pcontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPcontrol_terminalContext() *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pcontrol_terminal
	return p
}

func (*Pcontrol_terminalContext) IsPcontrol_terminalContext() {}

func NewPcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pcontrol_terminal

	return p
}

func (s *Pcontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Pcontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pcontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pcontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pcontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPcontrol_terminal(s)
	}
}

func (s *Pcontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPcontrol_terminal(s)
	}
}

func (p *VerilogParser) Pcontrol_terminal() (localctx IPcontrol_terminalContext) {
	localctx = NewPcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, VerilogParserRULE_pcontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2115)
		p.Expression()
	}

	return localctx
}

// IInput_terminalContext is an interface to support dynamic dispatch.
type IInput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_terminalContext differentiates from other interfaces.
	IsInput_terminalContext()
}

type Input_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_terminalContext() *Input_terminalContext {
	var p = new(Input_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_terminal
	return p
}

func (*Input_terminalContext) IsInput_terminalContext() {}

func NewInput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_terminalContext {
	var p = new(Input_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_terminal

	return p
}

func (s *Input_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Input_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInput_terminal(s)
	}
}

func (s *Input_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInput_terminal(s)
	}
}

func (p *VerilogParser) Input_terminal() (localctx IInput_terminalContext) {
	localctx = NewInput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, VerilogParserRULE_input_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2117)
		p.Expression()
	}

	return localctx
}

// IInout_terminalContext is an interface to support dynamic dispatch.
type IInout_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_terminalContext differentiates from other interfaces.
	IsInout_terminalContext()
}

type Inout_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_terminalContext() *Inout_terminalContext {
	var p = new(Inout_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inout_terminal
	return p
}

func (*Inout_terminalContext) IsInout_terminalContext() {}

func NewInout_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_terminalContext {
	var p = new(Inout_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inout_terminal

	return p
}

func (s *Inout_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_terminalContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Inout_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInout_terminal(s)
	}
}

func (s *Inout_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInout_terminal(s)
	}
}

func (p *VerilogParser) Inout_terminal() (localctx IInout_terminalContext) {
	localctx = NewInout_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, VerilogParserRULE_inout_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2119)
		p.Net_lvalue()
	}

	return localctx
}

// IOutput_terminalContext is an interface to support dynamic dispatch.
type IOutput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_terminalContext differentiates from other interfaces.
	IsOutput_terminalContext()
}

type Output_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_terminalContext() *Output_terminalContext {
	var p = new(Output_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_terminal
	return p
}

func (*Output_terminalContext) IsOutput_terminalContext() {}

func NewOutput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_terminalContext {
	var p = new(Output_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_terminal

	return p
}

func (s *Output_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_terminalContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Output_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_terminal(s)
	}
}

func (s *Output_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_terminal(s)
	}
}

func (p *VerilogParser) Output_terminal() (localctx IOutput_terminalContext) {
	localctx = NewOutput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, VerilogParserRULE_output_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2121)
		p.Net_lvalue()
	}

	return localctx
}

// ICmos_switchtypeContext is an interface to support dynamic dispatch.
type ICmos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switchtypeContext differentiates from other interfaces.
	IsCmos_switchtypeContext()
}

type Cmos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switchtypeContext() *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cmos_switchtype
	return p
}

func (*Cmos_switchtypeContext) IsCmos_switchtypeContext() {}

func NewCmos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cmos_switchtype

	return p
}

func (s *Cmos_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switchtypeContext) K_cmos() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_cmos, 0)
}

func (s *Cmos_switchtypeContext) K_rcmos() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_rcmos, 0)
}

func (s *Cmos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCmos_switchtype(s)
	}
}

func (s *Cmos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCmos_switchtype(s)
	}
}

func (p *VerilogParser) Cmos_switchtype() (localctx ICmos_switchtypeContext) {
	localctx = NewCmos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, VerilogParserRULE_cmos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2123)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserK_cmos || _la == VerilogParserK_rcmos) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEnable_gatetypeContext is an interface to support dynamic dispatch.
type IEnable_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gatetypeContext differentiates from other interfaces.
	IsEnable_gatetypeContext()
}

type Enable_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gatetypeContext() *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_enable_gatetype
	return p
}

func (*Enable_gatetypeContext) IsEnable_gatetypeContext() {}

func NewEnable_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_enable_gatetype

	return p
}

func (s *Enable_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gatetypeContext) K_bufif0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_bufif0, 0)
}

func (s *Enable_gatetypeContext) K_bufif1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_bufif1, 0)
}

func (s *Enable_gatetypeContext) K_notif0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_notif0, 0)
}

func (s *Enable_gatetypeContext) K_notif1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_notif1, 0)
}

func (s *Enable_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEnable_gatetype(s)
	}
}

func (s *Enable_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEnable_gatetype(s)
	}
}

func (p *VerilogParser) Enable_gatetype() (localctx IEnable_gatetypeContext) {
	localctx = NewEnable_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, VerilogParserRULE_enable_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2125)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserK_bufif0 || _la == VerilogParserK_bufif1 || _la == VerilogParserK_notif0 || _la == VerilogParserK_notif1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMos_switchtypeContext is an interface to support dynamic dispatch.
type IMos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switchtypeContext differentiates from other interfaces.
	IsMos_switchtypeContext()
}

type Mos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switchtypeContext() *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mos_switchtype
	return p
}

func (*Mos_switchtypeContext) IsMos_switchtypeContext() {}

func NewMos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mos_switchtype

	return p
}

func (s *Mos_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switchtypeContext) K_nmos() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_nmos, 0)
}

func (s *Mos_switchtypeContext) K_pmos() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_pmos, 0)
}

func (s *Mos_switchtypeContext) K_rnmos() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_rnmos, 0)
}

func (s *Mos_switchtypeContext) K_rpmos() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_rpmos, 0)
}

func (s *Mos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMos_switchtype(s)
	}
}

func (s *Mos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMos_switchtype(s)
	}
}

func (p *VerilogParser) Mos_switchtype() (localctx IMos_switchtypeContext) {
	localctx = NewMos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, VerilogParserRULE_mos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2127)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-67)&-(0x1f+1)) == 0 && ((1<<uint((_la-67)))&((1<<(VerilogParserK_nmos-67))|(1<<(VerilogParserK_pmos-67))|(1<<(VerilogParserK_rnmos-67))|(1<<(VerilogParserK_rpmos-67)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_input_gatetypeContext is an interface to support dynamic dispatch.
type IN_input_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gatetypeContext differentiates from other interfaces.
	IsN_input_gatetypeContext()
}

type N_input_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gatetypeContext() *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_input_gatetype
	return p
}

func (*N_input_gatetypeContext) IsN_input_gatetypeContext() {}

func NewN_input_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_input_gatetype

	return p
}

func (s *N_input_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gatetypeContext) K_and() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_and, 0)
}

func (s *N_input_gatetypeContext) K_nand() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_nand, 0)
}

func (s *N_input_gatetypeContext) K_or() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_or, 0)
}

func (s *N_input_gatetypeContext) K_nor() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_nor, 0)
}

func (s *N_input_gatetypeContext) K_xor() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_xor, 0)
}

func (s *N_input_gatetypeContext) K_xnor() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_xnor, 0)
}

func (s *N_input_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterN_input_gatetype(s)
	}
}

func (s *N_input_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitN_input_gatetype(s)
	}
}

func (p *VerilogParser) N_input_gatetype() (localctx IN_input_gatetypeContext) {
	localctx = NewN_input_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, VerilogParserRULE_n_input_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2129)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserK_and || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(VerilogParserK_nand-65))|(1<<(VerilogParserK_nor-65))|(1<<(VerilogParserK_or-65)))) != 0) || _la == VerilogParserK_xnor || _la == VerilogParserK_xor) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_output_gatetypeContext is an interface to support dynamic dispatch.
type IN_output_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gatetypeContext differentiates from other interfaces.
	IsN_output_gatetypeContext()
}

type N_output_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gatetypeContext() *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_n_output_gatetype
	return p
}

func (*N_output_gatetypeContext) IsN_output_gatetypeContext() {}

func NewN_output_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_n_output_gatetype

	return p
}

func (s *N_output_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gatetypeContext) K_buf() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_buf, 0)
}

func (s *N_output_gatetypeContext) K_not() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_not, 0)
}

func (s *N_output_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterN_output_gatetype(s)
	}
}

func (s *N_output_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitN_output_gatetype(s)
	}
}

func (p *VerilogParser) N_output_gatetype() (localctx IN_output_gatetypeContext) {
	localctx = NewN_output_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, VerilogParserRULE_n_output_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2131)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserK_buf || _la == VerilogParserK_not) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_en_switchtypeContext is an interface to support dynamic dispatch.
type IPass_en_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_en_switchtypeContext differentiates from other interfaces.
	IsPass_en_switchtypeContext()
}

type Pass_en_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_en_switchtypeContext() *Pass_en_switchtypeContext {
	var p = new(Pass_en_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_en_switchtype
	return p
}

func (*Pass_en_switchtypeContext) IsPass_en_switchtypeContext() {}

func NewPass_en_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_en_switchtypeContext {
	var p = new(Pass_en_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_en_switchtype

	return p
}

func (s *Pass_en_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_en_switchtypeContext) K_tranif0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_tranif0, 0)
}

func (s *Pass_en_switchtypeContext) K_tranif1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_tranif1, 0)
}

func (s *Pass_en_switchtypeContext) K_rtranif1() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_rtranif1, 0)
}

func (s *Pass_en_switchtypeContext) K_rtranif0() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_rtranif0, 0)
}

func (s *Pass_en_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_en_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_en_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPass_en_switchtype(s)
	}
}

func (s *Pass_en_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPass_en_switchtype(s)
	}
}

func (p *VerilogParser) Pass_en_switchtype() (localctx IPass_en_switchtypeContext) {
	localctx = NewPass_en_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, VerilogParserRULE_pass_en_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2133)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(VerilogParserK_rtranif0-94))|(1<<(VerilogParserK_rtranif1-94))|(1<<(VerilogParserK_tranif0-94))|(1<<(VerilogParserK_tranif1-94)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_switchtypeContext is an interface to support dynamic dispatch.
type IPass_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switchtypeContext differentiates from other interfaces.
	IsPass_switchtypeContext()
}

type Pass_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switchtypeContext() *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pass_switchtype
	return p
}

func (*Pass_switchtypeContext) IsPass_switchtypeContext() {}

func NewPass_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pass_switchtype

	return p
}

func (s *Pass_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switchtypeContext) K_tran() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_tran, 0)
}

func (s *Pass_switchtypeContext) K_rtran() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_rtran, 0)
}

func (s *Pass_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPass_switchtype(s)
	}
}

func (s *Pass_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPass_switchtype(s)
	}
}

func (p *VerilogParser) Pass_switchtype() (localctx IPass_switchtypeContext) {
	localctx = NewPass_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, VerilogParserRULE_pass_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2135)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserK_rtran || _la == VerilogParserK_tran) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IModule_instantiationContext is an interface to support dynamic dispatch.
type IModule_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instantiationContext differentiates from other interfaces.
	IsModule_instantiationContext()
}

type Module_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instantiationContext() *Module_instantiationContext {
	var p = new(Module_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_instantiation
	return p
}

func (*Module_instantiationContext) IsModule_instantiationContext() {}

func NewModule_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instantiationContext {
	var p = new(Module_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_instantiation

	return p
}

func (s *Module_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instantiationContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_instantiationContext) AllModule_instance() []IModule_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_instanceContext)(nil)).Elem())
	var tst = make([]IModule_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_instanceContext)
		}
	}

	return tst
}

func (s *Module_instantiationContext) Module_instance(i int) IModule_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_instanceContext)
}

func (s *Module_instantiationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Module_instantiationContext) Parameter_value_assignment() IParameter_value_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_value_assignmentContext)
}

func (s *Module_instantiationContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Module_instantiationContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Module_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_instantiation(s)
	}
}

func (s *Module_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_instantiation(s)
	}
}

func (p *VerilogParser) Module_instantiation() (localctx IModule_instantiationContext) {
	localctx = NewModule_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, VerilogParserRULE_module_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2137)
		p.Module_identifier()
	}
	p.SetState(2139)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserSharp {
		{
			p.SetState(2138)
			p.Parameter_value_assignment()
		}

	}
	{
		p.SetState(2141)
		p.Module_instance()
	}
	p.SetState(2146)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(2142)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(2143)
			p.Module_instance()
		}

		p.SetState(2148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2149)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IParameter_value_assignmentContext is an interface to support dynamic dispatch.
type IParameter_value_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_value_assignmentContext differentiates from other interfaces.
	IsParameter_value_assignmentContext()
}

type Parameter_value_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_value_assignmentContext() *Parameter_value_assignmentContext {
	var p = new(Parameter_value_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_value_assignment
	return p
}

func (*Parameter_value_assignmentContext) IsParameter_value_assignmentContext() {}

func NewParameter_value_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_value_assignmentContext {
	var p = new(Parameter_value_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_value_assignment

	return p
}

func (s *Parameter_value_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_value_assignmentContext) Sharp() antlr.TerminalNode {
	return s.GetToken(VerilogParserSharp, 0)
}

func (s *Parameter_value_assignmentContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Parameter_value_assignmentContext) List_of_parameter_assignments() IList_of_parameter_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_parameter_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_parameter_assignmentsContext)
}

func (s *Parameter_value_assignmentContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Parameter_value_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_value_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_value_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_value_assignment(s)
	}
}

func (s *Parameter_value_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_value_assignment(s)
	}
}

func (p *VerilogParser) Parameter_value_assignment() (localctx IParameter_value_assignmentContext) {
	localctx = NewParameter_value_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, VerilogParserRULE_parameter_value_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2151)
		p.Match(VerilogParserSharp)
	}
	{
		p.SetState(2152)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2153)
		p.List_of_parameter_assignments()
	}
	{
		p.SetState(2154)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IList_of_parameter_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_parameter_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_parameter_assignmentsContext differentiates from other interfaces.
	IsList_of_parameter_assignmentsContext()
}

type List_of_parameter_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_parameter_assignmentsContext() *List_of_parameter_assignmentsContext {
	var p = new(List_of_parameter_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_parameter_assignments
	return p
}

func (*List_of_parameter_assignmentsContext) IsList_of_parameter_assignmentsContext() {}

func NewList_of_parameter_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_parameter_assignmentsContext {
	var p = new(List_of_parameter_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_parameter_assignments

	return p
}

func (s *List_of_parameter_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_parameter_assignmentsContext) AllOrdered_parameter_assignment() []IOrdered_parameter_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrdered_parameter_assignmentContext)(nil)).Elem())
	var tst = make([]IOrdered_parameter_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrdered_parameter_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_parameter_assignmentsContext) Ordered_parameter_assignment(i int) IOrdered_parameter_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_parameter_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrdered_parameter_assignmentContext)
}

func (s *List_of_parameter_assignmentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_parameter_assignmentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_parameter_assignmentsContext) AllNamed_parameter_assignment() []INamed_parameter_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem())
	var tst = make([]INamed_parameter_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_parameter_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_parameter_assignmentsContext) Named_parameter_assignment(i int) INamed_parameter_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_parameter_assignmentContext)
}

func (s *List_of_parameter_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_parameter_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_parameter_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_parameter_assignments(s)
	}
}

func (s *List_of_parameter_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_parameter_assignments(s)
	}
}

func (p *VerilogParser) List_of_parameter_assignments() (localctx IList_of_parameter_assignmentsContext) {
	localctx = NewList_of_parameter_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, VerilogParserRULE_list_of_parameter_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2172)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_FUNC_q_initialize, VerilogParserK_FUNC_q_remove, VerilogParserK_FUNC_q_full, VerilogParserK_FUNC_q_exam, VerilogParserK_FUNC_q_add, VerilogParserK_FUNC_realtime, VerilogParserK_FUNC_stime, VerilogParserK_FUNC_time, VerilogParserK_FUNC_shortrealtobits, VerilogParserK_FUNC_bitstoshortreal, VerilogParserK_FUNC_realtobits, VerilogParserK_FUNC_bitstoreal, VerilogParserK_FUNC_unsigned, VerilogParserK_FUNC_signed, VerilogParserK_FUNC_rtoi, VerilogParserK_FUNC_itor, VerilogParserK_FUNC_cast, VerilogParserK_FUNC_random, VerilogParserK_FUNC_dist_exponential, VerilogParserK_FUNC_dist_chi_square, VerilogParserK_FUNC_dist_uniform, VerilogParserK_FUNC_dist_poisson, VerilogParserK_FUNC_dist_normal, VerilogParserK_FUNC_dist_erlang, VerilogParserK_FUNC_dist_t, VerilogParserK_FUNC_test_plusargs, VerilogParserK_FUNC_value_plusargs, VerilogParserPlus, VerilogParserMinus, VerilogParserExclamation_mark, VerilogParserLeft_parenthes, VerilogParserLeft_brace, VerilogParserAND, VerilogParserVertical_line, VerilogParserTilda, VerilogParserHat, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserString_const:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2156)
			p.Ordered_parameter_assignment()
		}
		p.SetState(2161)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(2157)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(2158)
				p.Ordered_parameter_assignment()
			}

			p.SetState(2163)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case VerilogParserDot:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2164)
			p.Named_parameter_assignment()
		}
		p.SetState(2169)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(2165)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(2166)
				p.Named_parameter_assignment()
			}

			p.SetState(2171)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOrdered_parameter_assignmentContext is an interface to support dynamic dispatch.
type IOrdered_parameter_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_parameter_assignmentContext differentiates from other interfaces.
	IsOrdered_parameter_assignmentContext()
}

type Ordered_parameter_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_parameter_assignmentContext() *Ordered_parameter_assignmentContext {
	var p = new(Ordered_parameter_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_ordered_parameter_assignment
	return p
}

func (*Ordered_parameter_assignmentContext) IsOrdered_parameter_assignmentContext() {}

func NewOrdered_parameter_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_parameter_assignmentContext {
	var p = new(Ordered_parameter_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_ordered_parameter_assignment

	return p
}

func (s *Ordered_parameter_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_parameter_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ordered_parameter_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_parameter_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_parameter_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOrdered_parameter_assignment(s)
	}
}

func (s *Ordered_parameter_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOrdered_parameter_assignment(s)
	}
}

func (p *VerilogParser) Ordered_parameter_assignment() (localctx IOrdered_parameter_assignmentContext) {
	localctx = NewOrdered_parameter_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, VerilogParserRULE_ordered_parameter_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2174)
		p.Expression()
	}

	return localctx
}

// INamed_parameter_assignmentContext is an interface to support dynamic dispatch.
type INamed_parameter_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_parameter_assignmentContext differentiates from other interfaces.
	IsNamed_parameter_assignmentContext()
}

type Named_parameter_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_parameter_assignmentContext() *Named_parameter_assignmentContext {
	var p = new(Named_parameter_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_named_parameter_assignment
	return p
}

func (*Named_parameter_assignmentContext) IsNamed_parameter_assignmentContext() {}

func NewNamed_parameter_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_parameter_assignmentContext {
	var p = new(Named_parameter_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_named_parameter_assignment

	return p
}

func (s *Named_parameter_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_parameter_assignmentContext) Dot() antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, 0)
}

func (s *Named_parameter_assignmentContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Named_parameter_assignmentContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Named_parameter_assignmentContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Named_parameter_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Named_parameter_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_parameter_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_parameter_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNamed_parameter_assignment(s)
	}
}

func (s *Named_parameter_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNamed_parameter_assignment(s)
	}
}

func (p *VerilogParser) Named_parameter_assignment() (localctx INamed_parameter_assignmentContext) {
	localctx = NewNamed_parameter_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, VerilogParserRULE_named_parameter_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2176)
		p.Match(VerilogParserDot)
	}
	{
		p.SetState(2177)
		p.Parameter_identifier()
	}
	{
		p.SetState(2178)
		p.Match(VerilogParserLeft_parenthes)
	}
	p.SetState(2180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
		{
			p.SetState(2179)
			p.Expression()
		}

	}
	{
		p.SetState(2182)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IModule_instanceContext is an interface to support dynamic dispatch.
type IModule_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instanceContext differentiates from other interfaces.
	IsModule_instanceContext()
}

type Module_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instanceContext() *Module_instanceContext {
	var p = new(Module_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_instance
	return p
}

func (*Module_instanceContext) IsModule_instanceContext() {}

func NewModule_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instanceContext {
	var p = new(Module_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_instance

	return p
}

func (s *Module_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Module_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Module_instanceContext) List_of_port_connections() IList_of_port_connectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_connectionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_connectionsContext)
}

func (s *Module_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Module_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_instance(s)
	}
}

func (s *Module_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_instance(s)
	}
}

func (p *VerilogParser) Module_instance() (localctx IModule_instanceContext) {
	localctx = NewModule_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, VerilogParserRULE_module_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2184)
		p.Name_of_instance()
	}
	{
		p.SetState(2185)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2186)
		p.List_of_port_connections()
	}
	{
		p.SetState(2187)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IName_of_instanceContext is an interface to support dynamic dispatch.
type IName_of_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_of_instanceContext differentiates from other interfaces.
	IsName_of_instanceContext()
}

type Name_of_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_of_instanceContext() *Name_of_instanceContext {
	var p = new(Name_of_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_name_of_instance
	return p
}

func (*Name_of_instanceContext) IsName_of_instanceContext() {}

func NewName_of_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_of_instanceContext {
	var p = new(Name_of_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_name_of_instance

	return p
}

func (s *Name_of_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_of_instanceContext) Module_instance_identifier() IModule_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instance_identifierContext)
}

func (s *Name_of_instanceContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Name_of_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_of_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_of_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterName_of_instance(s)
	}
}

func (s *Name_of_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitName_of_instance(s)
	}
}

func (p *VerilogParser) Name_of_instance() (localctx IName_of_instanceContext) {
	localctx = NewName_of_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, VerilogParserRULE_name_of_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2189)
		p.Module_instance_identifier()
	}
	p.SetState(2191)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_bracket {
		{
			p.SetState(2190)
			p.Range_()
		}

	}

	return localctx
}

// IList_of_port_connectionsContext is an interface to support dynamic dispatch.
type IList_of_port_connectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_connectionsContext differentiates from other interfaces.
	IsList_of_port_connectionsContext()
}

type List_of_port_connectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_connectionsContext() *List_of_port_connectionsContext {
	var p = new(List_of_port_connectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_port_connections
	return p
}

func (*List_of_port_connectionsContext) IsList_of_port_connectionsContext() {}

func NewList_of_port_connectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_connectionsContext {
	var p = new(List_of_port_connectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_port_connections

	return p
}

func (s *List_of_port_connectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_connectionsContext) AllOrdered_port_connection() []IOrdered_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrdered_port_connectionContext)(nil)).Elem())
	var tst = make([]IOrdered_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrdered_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_port_connectionsContext) Ordered_port_connection(i int) IOrdered_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrdered_port_connectionContext)
}

func (s *List_of_port_connectionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_port_connectionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_port_connectionsContext) AllNamed_port_connection() []INamed_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_port_connectionContext)(nil)).Elem())
	var tst = make([]INamed_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_port_connectionsContext) Named_port_connection(i int) INamed_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_port_connectionContext)
}

func (s *List_of_port_connectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_connectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_connectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_port_connections(s)
	}
}

func (s *List_of_port_connectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_port_connections(s)
	}
}

func (p *VerilogParser) List_of_port_connections() (localctx IList_of_port_connectionsContext) {
	localctx = NewList_of_port_connectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, VerilogParserRULE_list_of_port_connections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2209)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2193)
			p.Ordered_port_connection()
		}
		p.SetState(2198)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(2194)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(2195)
				p.Ordered_port_connection()
			}

			p.SetState(2200)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2201)
			p.Named_port_connection()
		}
		p.SetState(2206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(2202)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(2203)
				p.Named_port_connection()
			}

			p.SetState(2208)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IOrdered_port_connectionContext is an interface to support dynamic dispatch.
type IOrdered_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_port_connectionContext differentiates from other interfaces.
	IsOrdered_port_connectionContext()
}

type Ordered_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_port_connectionContext() *Ordered_port_connectionContext {
	var p = new(Ordered_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_ordered_port_connection
	return p
}

func (*Ordered_port_connectionContext) IsOrdered_port_connectionContext() {}

func NewOrdered_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_port_connectionContext {
	var p = new(Ordered_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_ordered_port_connection

	return p
}

func (s *Ordered_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Ordered_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Ordered_port_connectionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ordered_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOrdered_port_connection(s)
	}
}

func (s *Ordered_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOrdered_port_connection(s)
	}
}

func (p *VerilogParser) Ordered_port_connection() (localctx IOrdered_port_connectionContext) {
	localctx = NewOrdered_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, VerilogParserRULE_ordered_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2214)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2211)
				p.Attribute_instance()
			}

		}
		p.SetState(2216)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext())
	}
	p.SetState(2218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
		{
			p.SetState(2217)
			p.Expression()
		}

	}

	return localctx
}

// INamed_port_connectionContext is an interface to support dynamic dispatch.
type INamed_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_port_connectionContext differentiates from other interfaces.
	IsNamed_port_connectionContext()
}

type Named_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_port_connectionContext() *Named_port_connectionContext {
	var p = new(Named_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_named_port_connection
	return p
}

func (*Named_port_connectionContext) IsNamed_port_connectionContext() {}

func NewNamed_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_port_connectionContext {
	var p = new(Named_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_named_port_connection

	return p
}

func (s *Named_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_port_connectionContext) Dot() antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, 0)
}

func (s *Named_port_connectionContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Named_port_connectionContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Named_port_connectionContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Named_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Named_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Named_port_connectionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Named_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNamed_port_connection(s)
	}
}

func (s *Named_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNamed_port_connection(s)
	}
}

func (p *VerilogParser) Named_port_connection() (localctx INamed_port_connectionContext) {
	localctx = NewNamed_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, VerilogParserRULE_named_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserLeft_parenthes {
		{
			p.SetState(2220)
			p.Attribute_instance()
		}

		p.SetState(2225)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2226)
		p.Match(VerilogParserDot)
	}
	{
		p.SetState(2227)
		p.Port_identifier()
	}
	{
		p.SetState(2228)
		p.Match(VerilogParserLeft_parenthes)
	}
	p.SetState(2230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
		{
			p.SetState(2229)
			p.Expression()
		}

	}
	{
		p.SetState(2232)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IGenerated_instantiationContext is an interface to support dynamic dispatch.
type IGenerated_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerated_instantiationContext differentiates from other interfaces.
	IsGenerated_instantiationContext()
}

type Generated_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerated_instantiationContext() *Generated_instantiationContext {
	var p = new(Generated_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generated_instantiation
	return p
}

func (*Generated_instantiationContext) IsGenerated_instantiationContext() {}

func NewGenerated_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generated_instantiationContext {
	var p = new(Generated_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generated_instantiation

	return p
}

func (s *Generated_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Generated_instantiationContext) K_generate() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_generate, 0)
}

func (s *Generated_instantiationContext) K_endgenerate() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_endgenerate, 0)
}

func (s *Generated_instantiationContext) AllGenerate_item() []IGenerate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem())
	var tst = make([]IGenerate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_itemContext)
		}
	}

	return tst
}

func (s *Generated_instantiationContext) Generate_item(i int) IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generated_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generated_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generated_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerated_instantiation(s)
	}
}

func (s *Generated_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerated_instantiation(s)
	}
}

func (p *VerilogParser) Generated_instantiation() (localctx IGenerated_instantiationContext) {
	localctx = NewGenerated_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, VerilogParserRULE_generated_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2234)
		p.Match(VerilogParserK_generate)
	}
	p.SetState(2238)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserK_always)|(1<<VerilogParserK_and)|(1<<VerilogParserK_assign)|(1<<VerilogParserK_begin)|(1<<VerilogParserK_buf)|(1<<VerilogParserK_bufif0)|(1<<VerilogParserK_bufif1)|(1<<VerilogParserK_case)|(1<<VerilogParserK_cmos)|(1<<VerilogParserK_defparam))) != 0) || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(VerilogParserK_event-40))|(1<<(VerilogParserK_for-40))|(1<<(VerilogParserK_function-40))|(1<<(VerilogParserK_genvar-40))|(1<<(VerilogParserK_if-40))|(1<<(VerilogParserK_initial-40))|(1<<(VerilogParserK_integer-40))|(1<<(VerilogParserK_localparam-40))|(1<<(VerilogParserK_nand-40))|(1<<(VerilogParserK_nmos-40))|(1<<(VerilogParserK_nor-40))|(1<<(VerilogParserK_not-40))|(1<<(VerilogParserK_notif0-40)))) != 0) || (((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(VerilogParserK_notif1-72))|(1<<(VerilogParserK_or-72))|(1<<(VerilogParserK_pmos-72))|(1<<(VerilogParserK_pulldown-72))|(1<<(VerilogParserK_pullup-72))|(1<<(VerilogParserK_rcmos-72))|(1<<(VerilogParserK_real-72))|(1<<(VerilogParserK_realtime-72))|(1<<(VerilogParserK_reg-72))|(1<<(VerilogParserK_rnmos-72))|(1<<(VerilogParserK_rpmos-72))|(1<<(VerilogParserK_rtran-72))|(1<<(VerilogParserK_rtranif0-72))|(1<<(VerilogParserK_rtranif1-72)))) != 0) || (((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(VerilogParserK_supply0-104))|(1<<(VerilogParserK_supply1-104))|(1<<(VerilogParserK_task-104))|(1<<(VerilogParserK_time-104))|(1<<(VerilogParserK_tran-104))|(1<<(VerilogParserK_tranif0-104))|(1<<(VerilogParserK_tranif1-104))|(1<<(VerilogParserK_tri-104))|(1<<(VerilogParserK_tri0-104))|(1<<(VerilogParserK_tri1-104))|(1<<(VerilogParserK_triand-104))|(1<<(VerilogParserK_trior-104))|(1<<(VerilogParserK_trireg-104))|(1<<(VerilogParserK_wand-104))|(1<<(VerilogParserK_wire-104))|(1<<(VerilogParserK_wor-104))|(1<<(VerilogParserK_xnor-104))|(1<<(VerilogParserK_xor-104)))) != 0) || _la == VerilogParserLeft_parenthes || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2235)
			p.Generate_item()
		}

		p.SetState(2240)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2241)
		p.Match(VerilogParserK_endgenerate)
	}

	return localctx
}

// IGenerate_item_or_nullContext is an interface to support dynamic dispatch.
type IGenerate_item_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_item_or_nullContext differentiates from other interfaces.
	IsGenerate_item_or_nullContext()
}

type Generate_item_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_item_or_nullContext() *Generate_item_or_nullContext {
	var p = new(Generate_item_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_item_or_null
	return p
}

func (*Generate_item_or_nullContext) IsGenerate_item_or_nullContext() {}

func NewGenerate_item_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_item_or_nullContext {
	var p = new(Generate_item_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_item_or_null

	return p
}

func (s *Generate_item_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_item_or_nullContext) Generate_item() IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_item_or_nullContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Generate_item_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_item_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_item_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_item_or_null(s)
	}
}

func (s *Generate_item_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_item_or_null(s)
	}
}

func (p *VerilogParser) Generate_item_or_null() (localctx IGenerate_item_or_nullContext) {
	localctx = NewGenerate_item_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, VerilogParserRULE_generate_item_or_null)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2245)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_always, VerilogParserK_and, VerilogParserK_assign, VerilogParserK_begin, VerilogParserK_buf, VerilogParserK_bufif0, VerilogParserK_bufif1, VerilogParserK_case, VerilogParserK_cmos, VerilogParserK_defparam, VerilogParserK_event, VerilogParserK_for, VerilogParserK_function, VerilogParserK_genvar, VerilogParserK_if, VerilogParserK_initial, VerilogParserK_integer, VerilogParserK_localparam, VerilogParserK_nand, VerilogParserK_nmos, VerilogParserK_nor, VerilogParserK_not, VerilogParserK_notif0, VerilogParserK_notif1, VerilogParserK_or, VerilogParserK_pmos, VerilogParserK_pulldown, VerilogParserK_pullup, VerilogParserK_rcmos, VerilogParserK_real, VerilogParserK_realtime, VerilogParserK_reg, VerilogParserK_rnmos, VerilogParserK_rpmos, VerilogParserK_rtran, VerilogParserK_rtranif0, VerilogParserK_rtranif1, VerilogParserK_supply0, VerilogParserK_supply1, VerilogParserK_task, VerilogParserK_time, VerilogParserK_tran, VerilogParserK_tranif0, VerilogParserK_tranif1, VerilogParserK_tri, VerilogParserK_tri0, VerilogParserK_tri1, VerilogParserK_triand, VerilogParserK_trior, VerilogParserK_trireg, VerilogParserK_wand, VerilogParserK_wire, VerilogParserK_wor, VerilogParserK_xnor, VerilogParserK_xor, VerilogParserLeft_parenthes, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2243)
			p.Generate_item()
		}

	case VerilogParserSemicolon:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2244)
			p.Match(VerilogParserSemicolon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_itemContext is an interface to support dynamic dispatch.
type IGenerate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_itemContext differentiates from other interfaces.
	IsGenerate_itemContext()
}

type Generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_itemContext() *Generate_itemContext {
	var p = new(Generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_item
	return p
}

func (*Generate_itemContext) IsGenerate_itemContext() {}

func NewGenerate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_itemContext {
	var p = new(Generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_item

	return p
}

func (s *Generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_itemContext) Generate_conditional_statement() IGenerate_conditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_conditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_conditional_statementContext)
}

func (s *Generate_itemContext) Generate_case_statement() IGenerate_case_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_case_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_case_statementContext)
}

func (s *Generate_itemContext) Generate_loop_statement() IGenerate_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_loop_statementContext)
}

func (s *Generate_itemContext) Generate_block() IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *Generate_itemContext) Module_or_generate_item() IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_item(s)
	}
}

func (s *Generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_item(s)
	}
}

func (p *VerilogParser) Generate_item() (localctx IGenerate_itemContext) {
	localctx = NewGenerate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, VerilogParserRULE_generate_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2252)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_if:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2247)
			p.Generate_conditional_statement()
		}

	case VerilogParserK_case:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2248)
			p.Generate_case_statement()
		}

	case VerilogParserK_for:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2249)
			p.Generate_loop_statement()
		}

	case VerilogParserK_begin:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2250)
			p.Generate_block()
		}

	case VerilogParserK_always, VerilogParserK_and, VerilogParserK_assign, VerilogParserK_buf, VerilogParserK_bufif0, VerilogParserK_bufif1, VerilogParserK_cmos, VerilogParserK_defparam, VerilogParserK_event, VerilogParserK_function, VerilogParserK_genvar, VerilogParserK_initial, VerilogParserK_integer, VerilogParserK_localparam, VerilogParserK_nand, VerilogParserK_nmos, VerilogParserK_nor, VerilogParserK_not, VerilogParserK_notif0, VerilogParserK_notif1, VerilogParserK_or, VerilogParserK_pmos, VerilogParserK_pulldown, VerilogParserK_pullup, VerilogParserK_rcmos, VerilogParserK_real, VerilogParserK_realtime, VerilogParserK_reg, VerilogParserK_rnmos, VerilogParserK_rpmos, VerilogParserK_rtran, VerilogParserK_rtranif0, VerilogParserK_rtranif1, VerilogParserK_supply0, VerilogParserK_supply1, VerilogParserK_task, VerilogParserK_time, VerilogParserK_tran, VerilogParserK_tranif0, VerilogParserK_tranif1, VerilogParserK_tri, VerilogParserK_tri0, VerilogParserK_tri1, VerilogParserK_triand, VerilogParserK_trior, VerilogParserK_trireg, VerilogParserK_wand, VerilogParserK_wire, VerilogParserK_wor, VerilogParserK_xnor, VerilogParserK_xor, VerilogParserLeft_parenthes, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2251)
			p.Module_or_generate_item()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_conditional_statementContext is an interface to support dynamic dispatch.
type IGenerate_conditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_conditional_statementContext differentiates from other interfaces.
	IsGenerate_conditional_statementContext()
}

type Generate_conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_conditional_statementContext() *Generate_conditional_statementContext {
	var p = new(Generate_conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_conditional_statement
	return p
}

func (*Generate_conditional_statementContext) IsGenerate_conditional_statementContext() {}

func NewGenerate_conditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_conditional_statementContext {
	var p = new(Generate_conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_conditional_statement

	return p
}

func (s *Generate_conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_conditional_statementContext) K_if() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_if, 0)
}

func (s *Generate_conditional_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Generate_conditional_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Generate_conditional_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Generate_conditional_statementContext) AllGenerate_item_or_null() []IGenerate_item_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_item_or_nullContext)(nil)).Elem())
	var tst = make([]IGenerate_item_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_item_or_nullContext)
		}
	}

	return tst
}

func (s *Generate_conditional_statementContext) Generate_item_or_null(i int) IGenerate_item_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_item_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_item_or_nullContext)
}

func (s *Generate_conditional_statementContext) K_else() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_else, 0)
}

func (s *Generate_conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_conditional_statement(s)
	}
}

func (s *Generate_conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_conditional_statement(s)
	}
}

func (p *VerilogParser) Generate_conditional_statement() (localctx IGenerate_conditional_statementContext) {
	localctx = NewGenerate_conditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, VerilogParserRULE_generate_conditional_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2254)
		p.Match(VerilogParserK_if)
	}
	{
		p.SetState(2255)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2256)
		p.Constant_expression()
	}
	{
		p.SetState(2257)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(2258)
		p.Generate_item_or_null()
	}
	p.SetState(2261)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2259)
			p.Match(VerilogParserK_else)
		}
		{
			p.SetState(2260)
			p.Generate_item_or_null()
		}

	}

	return localctx
}

// IGenerate_case_statementContext is an interface to support dynamic dispatch.
type IGenerate_case_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_case_statementContext differentiates from other interfaces.
	IsGenerate_case_statementContext()
}

type Generate_case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_case_statementContext() *Generate_case_statementContext {
	var p = new(Generate_case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_case_statement
	return p
}

func (*Generate_case_statementContext) IsGenerate_case_statementContext() {}

func NewGenerate_case_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_case_statementContext {
	var p = new(Generate_case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_case_statement

	return p
}

func (s *Generate_case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_case_statementContext) K_case() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_case, 0)
}

func (s *Generate_case_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Generate_case_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Generate_case_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Generate_case_statementContext) AllGenvar_case_item() []IGenvar_case_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenvar_case_itemContext)(nil)).Elem())
	var tst = make([]IGenvar_case_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenvar_case_itemContext)
		}
	}

	return tst
}

func (s *Generate_case_statementContext) Genvar_case_item(i int) IGenvar_case_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_case_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenvar_case_itemContext)
}

func (s *Generate_case_statementContext) K_endcase() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_endcase, 0)
}

func (s *Generate_case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_case_statement(s)
	}
}

func (s *Generate_case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_case_statement(s)
	}
}

func (p *VerilogParser) Generate_case_statement() (localctx IGenerate_case_statementContext) {
	localctx = NewGenerate_case_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, VerilogParserRULE_generate_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2263)
		p.Match(VerilogParserK_case)
	}
	{
		p.SetState(2264)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2265)
		p.Constant_expression()
	}
	{
		p.SetState(2266)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(2267)
		p.Genvar_case_item()
	}
	p.SetState(2271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserK_default || (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
		{
			p.SetState(2268)
			p.Genvar_case_item()
		}

		p.SetState(2273)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2274)
		p.Match(VerilogParserK_endcase)
	}

	return localctx
}

// IGenvar_case_itemContext is an interface to support dynamic dispatch.
type IGenvar_case_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_case_itemContext differentiates from other interfaces.
	IsGenvar_case_itemContext()
}

type Genvar_case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_case_itemContext() *Genvar_case_itemContext {
	var p = new(Genvar_case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_case_item
	return p
}

func (*Genvar_case_itemContext) IsGenvar_case_itemContext() {}

func NewGenvar_case_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_case_itemContext {
	var p = new(Genvar_case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_case_item

	return p
}

func (s *Genvar_case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_case_itemContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Genvar_case_itemContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Genvar_case_itemContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Genvar_case_itemContext) Generate_item_or_null() IGenerate_item_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_item_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_item_or_nullContext)
}

func (s *Genvar_case_itemContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Genvar_case_itemContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Genvar_case_itemContext) K_default() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_default, 0)
}

func (s *Genvar_case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_case_item(s)
	}
}

func (s *Genvar_case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_case_item(s)
	}
}

func (p *VerilogParser) Genvar_case_item() (localctx IGenvar_case_itemContext) {
	localctx = NewGenvar_case_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, VerilogParserRULE_genvar_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2292)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_FUNC_q_initialize, VerilogParserK_FUNC_q_remove, VerilogParserK_FUNC_q_full, VerilogParserK_FUNC_q_exam, VerilogParserK_FUNC_q_add, VerilogParserK_FUNC_realtime, VerilogParserK_FUNC_stime, VerilogParserK_FUNC_time, VerilogParserK_FUNC_shortrealtobits, VerilogParserK_FUNC_bitstoshortreal, VerilogParserK_FUNC_realtobits, VerilogParserK_FUNC_bitstoreal, VerilogParserK_FUNC_unsigned, VerilogParserK_FUNC_signed, VerilogParserK_FUNC_rtoi, VerilogParserK_FUNC_itor, VerilogParserK_FUNC_cast, VerilogParserK_FUNC_random, VerilogParserK_FUNC_dist_exponential, VerilogParserK_FUNC_dist_chi_square, VerilogParserK_FUNC_dist_uniform, VerilogParserK_FUNC_dist_poisson, VerilogParserK_FUNC_dist_normal, VerilogParserK_FUNC_dist_erlang, VerilogParserK_FUNC_dist_t, VerilogParserK_FUNC_test_plusargs, VerilogParserK_FUNC_value_plusargs, VerilogParserPlus, VerilogParserMinus, VerilogParserExclamation_mark, VerilogParserLeft_parenthes, VerilogParserLeft_brace, VerilogParserAND, VerilogParserVertical_line, VerilogParserTilda, VerilogParserHat, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserString_const:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2276)
			p.Constant_expression()
		}
		p.SetState(2281)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(2277)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(2278)
				p.Constant_expression()
			}

			p.SetState(2283)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2284)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(2285)
			p.Generate_item_or_null()
		}

	case VerilogParserK_default:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2287)
			p.Match(VerilogParserK_default)
		}
		p.SetState(2289)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserColon {
			{
				p.SetState(2288)
				p.Match(VerilogParserColon)
			}

		}
		{
			p.SetState(2291)
			p.Generate_item_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_loop_statementContext is an interface to support dynamic dispatch.
type IGenerate_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_loop_statementContext differentiates from other interfaces.
	IsGenerate_loop_statementContext()
}

type Generate_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_loop_statementContext() *Generate_loop_statementContext {
	var p = new(Generate_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_loop_statement
	return p
}

func (*Generate_loop_statementContext) IsGenerate_loop_statementContext() {}

func NewGenerate_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_loop_statementContext {
	var p = new(Generate_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_loop_statement

	return p
}

func (s *Generate_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_loop_statementContext) K_for() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_for, 0)
}

func (s *Generate_loop_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Generate_loop_statementContext) AllGenvar_assignment() []IGenvar_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenvar_assignmentContext)(nil)).Elem())
	var tst = make([]IGenvar_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenvar_assignmentContext)
		}
	}

	return tst
}

func (s *Generate_loop_statementContext) Genvar_assignment(i int) IGenvar_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenvar_assignmentContext)
}

func (s *Generate_loop_statementContext) AllSemicolon() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserSemicolon)
}

func (s *Generate_loop_statementContext) Semicolon(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, i)
}

func (s *Generate_loop_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Generate_loop_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Generate_loop_statementContext) Generate_block() IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *Generate_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_loop_statement(s)
	}
}

func (s *Generate_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_loop_statement(s)
	}
}

func (p *VerilogParser) Generate_loop_statement() (localctx IGenerate_loop_statementContext) {
	localctx = NewGenerate_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, VerilogParserRULE_generate_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2294)
		p.Match(VerilogParserK_for)
	}
	{
		p.SetState(2295)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2296)
		p.Genvar_assignment()
	}
	{
		p.SetState(2297)
		p.Match(VerilogParserSemicolon)
	}
	{
		p.SetState(2298)
		p.Constant_expression()
	}
	{
		p.SetState(2299)
		p.Match(VerilogParserSemicolon)
	}
	{
		p.SetState(2300)
		p.Genvar_assignment()
	}
	{
		p.SetState(2301)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(2302)
		p.Generate_block()
	}

	return localctx
}

// IGenvar_assignmentContext is an interface to support dynamic dispatch.
type IGenvar_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_assignmentContext differentiates from other interfaces.
	IsGenvar_assignmentContext()
}

type Genvar_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_assignmentContext() *Genvar_assignmentContext {
	var p = new(Genvar_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_assignment
	return p
}

func (*Genvar_assignmentContext) IsGenvar_assignmentContext() {}

func NewGenvar_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_assignmentContext {
	var p = new(Genvar_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_assignment

	return p
}

func (s *Genvar_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_assignmentContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Genvar_assignmentContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Genvar_assignmentContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Genvar_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_assignment(s)
	}
}

func (s *Genvar_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_assignment(s)
	}
}

func (p *VerilogParser) Genvar_assignment() (localctx IGenvar_assignmentContext) {
	localctx = NewGenvar_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, VerilogParserRULE_genvar_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2304)
		p.Genvar_identifier()
	}
	{
		p.SetState(2305)
		p.Match(VerilogParserEq)
	}
	{
		p.SetState(2306)
		p.Constant_expression()
	}

	return localctx
}

// IGenerate_blockContext is an interface to support dynamic dispatch.
type IGenerate_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_blockContext differentiates from other interfaces.
	IsGenerate_blockContext()
}

type Generate_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_blockContext() *Generate_blockContext {
	var p = new(Generate_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_block
	return p
}

func (*Generate_blockContext) IsGenerate_blockContext() {}

func NewGenerate_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_blockContext {
	var p = new(Generate_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_block

	return p
}

func (s *Generate_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_blockContext) K_begin() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_begin, 0)
}

func (s *Generate_blockContext) K_end() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_end, 0)
}

func (s *Generate_blockContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Generate_blockContext) Generate_block_identifier() IGenerate_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_block_identifierContext)
}

func (s *Generate_blockContext) AllGenerate_item() []IGenerate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem())
	var tst = make([]IGenerate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_itemContext)
		}
	}

	return tst
}

func (s *Generate_blockContext) Generate_item(i int) IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_block(s)
	}
}

func (s *Generate_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_block(s)
	}
}

func (p *VerilogParser) Generate_block() (localctx IGenerate_blockContext) {
	localctx = NewGenerate_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, VerilogParserRULE_generate_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2308)
		p.Match(VerilogParserK_begin)
	}
	p.SetState(2311)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserColon {
		{
			p.SetState(2309)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(2310)
			p.Generate_block_identifier()
		}

	}
	p.SetState(2316)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserK_always)|(1<<VerilogParserK_and)|(1<<VerilogParserK_assign)|(1<<VerilogParserK_begin)|(1<<VerilogParserK_buf)|(1<<VerilogParserK_bufif0)|(1<<VerilogParserK_bufif1)|(1<<VerilogParserK_case)|(1<<VerilogParserK_cmos)|(1<<VerilogParserK_defparam))) != 0) || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(VerilogParserK_event-40))|(1<<(VerilogParserK_for-40))|(1<<(VerilogParserK_function-40))|(1<<(VerilogParserK_genvar-40))|(1<<(VerilogParserK_if-40))|(1<<(VerilogParserK_initial-40))|(1<<(VerilogParserK_integer-40))|(1<<(VerilogParserK_localparam-40))|(1<<(VerilogParserK_nand-40))|(1<<(VerilogParserK_nmos-40))|(1<<(VerilogParserK_nor-40))|(1<<(VerilogParserK_not-40))|(1<<(VerilogParserK_notif0-40)))) != 0) || (((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(VerilogParserK_notif1-72))|(1<<(VerilogParserK_or-72))|(1<<(VerilogParserK_pmos-72))|(1<<(VerilogParserK_pulldown-72))|(1<<(VerilogParserK_pullup-72))|(1<<(VerilogParserK_rcmos-72))|(1<<(VerilogParserK_real-72))|(1<<(VerilogParserK_realtime-72))|(1<<(VerilogParserK_reg-72))|(1<<(VerilogParserK_rnmos-72))|(1<<(VerilogParserK_rpmos-72))|(1<<(VerilogParserK_rtran-72))|(1<<(VerilogParserK_rtranif0-72))|(1<<(VerilogParserK_rtranif1-72)))) != 0) || (((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(VerilogParserK_supply0-104))|(1<<(VerilogParserK_supply1-104))|(1<<(VerilogParserK_task-104))|(1<<(VerilogParserK_time-104))|(1<<(VerilogParserK_tran-104))|(1<<(VerilogParserK_tranif0-104))|(1<<(VerilogParserK_tranif1-104))|(1<<(VerilogParserK_tri-104))|(1<<(VerilogParserK_tri0-104))|(1<<(VerilogParserK_tri1-104))|(1<<(VerilogParserK_triand-104))|(1<<(VerilogParserK_trior-104))|(1<<(VerilogParserK_trireg-104))|(1<<(VerilogParserK_wand-104))|(1<<(VerilogParserK_wire-104))|(1<<(VerilogParserK_wor-104))|(1<<(VerilogParserK_xnor-104))|(1<<(VerilogParserK_xor-104)))) != 0) || _la == VerilogParserLeft_parenthes || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2313)
			p.Generate_item()
		}

		p.SetState(2318)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2319)
		p.Match(VerilogParserK_end)
	}

	return localctx
}

// IContinuous_assignContext is an interface to support dynamic dispatch.
type IContinuous_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinuous_assignContext differentiates from other interfaces.
	IsContinuous_assignContext()
}

type Continuous_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinuous_assignContext() *Continuous_assignContext {
	var p = new(Continuous_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_continuous_assign
	return p
}

func (*Continuous_assignContext) IsContinuous_assignContext() {}

func NewContinuous_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continuous_assignContext {
	var p = new(Continuous_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_continuous_assign

	return p
}

func (s *Continuous_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Continuous_assignContext) K_assign() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_assign, 0)
}

func (s *Continuous_assignContext) List_of_net_assignments() IList_of_net_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_assignmentsContext)
}

func (s *Continuous_assignContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Continuous_assignContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Continuous_assignContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Continuous_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continuous_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continuous_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterContinuous_assign(s)
	}
}

func (s *Continuous_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitContinuous_assign(s)
	}
}

func (p *VerilogParser) Continuous_assign() (localctx IContinuous_assignContext) {
	localctx = NewContinuous_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, VerilogParserRULE_continuous_assign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2321)
		p.Match(VerilogParserK_assign)
	}
	p.SetState(2323)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_highz0 || _la == VerilogParserK_highz1 || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(VerilogParserK_pull0-79))|(1<<(VerilogParserK_pull1-79))|(1<<(VerilogParserK_strong0-79))|(1<<(VerilogParserK_strong1-79))|(1<<(VerilogParserK_supply0-79))|(1<<(VerilogParserK_supply1-79)))) != 0) || _la == VerilogParserK_weak0 || _la == VerilogParserK_weak1 {
		{
			p.SetState(2322)
			p.Drive_strength()
		}

	}
	p.SetState(2326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserSharp {
		{
			p.SetState(2325)
			p.Delay3()
		}

	}
	{
		p.SetState(2328)
		p.List_of_net_assignments()
	}
	{
		p.SetState(2329)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IList_of_net_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_net_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_assignmentsContext differentiates from other interfaces.
	IsList_of_net_assignmentsContext()
}

type List_of_net_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_assignmentsContext() *List_of_net_assignmentsContext {
	var p = new(List_of_net_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_net_assignments
	return p
}

func (*List_of_net_assignmentsContext) IsList_of_net_assignmentsContext() {}

func NewList_of_net_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_assignmentsContext {
	var p = new(List_of_net_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_net_assignments

	return p
}

func (s *List_of_net_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_assignmentsContext) AllNet_assignment() []INet_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem())
	var tst = make([]INet_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_net_assignmentsContext) Net_assignment(i int) INet_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_assignmentContext)
}

func (s *List_of_net_assignmentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_net_assignmentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_net_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_net_assignments(s)
	}
}

func (s *List_of_net_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_net_assignments(s)
	}
}

func (p *VerilogParser) List_of_net_assignments() (localctx IList_of_net_assignmentsContext) {
	localctx = NewList_of_net_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, VerilogParserRULE_list_of_net_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2331)
		p.Net_assignment()
	}
	p.SetState(2336)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(2332)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(2333)
			p.Net_assignment()
		}

		p.SetState(2338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INet_assignmentContext is an interface to support dynamic dispatch.
type INet_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_assignmentContext differentiates from other interfaces.
	IsNet_assignmentContext()
}

type Net_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_assignmentContext() *Net_assignmentContext {
	var p = new(Net_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_assignment
	return p
}

func (*Net_assignmentContext) IsNet_assignmentContext() {}

func NewNet_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_assignmentContext {
	var p = new(Net_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_assignment

	return p
}

func (s *Net_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_assignmentContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Net_assignmentContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Net_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_assignment(s)
	}
}

func (s *Net_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_assignment(s)
	}
}

func (p *VerilogParser) Net_assignment() (localctx INet_assignmentContext) {
	localctx = NewNet_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, VerilogParserRULE_net_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2339)
		p.Net_lvalue()
	}
	{
		p.SetState(2340)
		p.Match(VerilogParserEq)
	}
	{
		p.SetState(2341)
		p.Expression()
	}

	return localctx
}

// IInitial_constructContext is an interface to support dynamic dispatch.
type IInitial_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitial_constructContext differentiates from other interfaces.
	IsInitial_constructContext()
}

type Initial_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitial_constructContext() *Initial_constructContext {
	var p = new(Initial_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_initial_construct
	return p
}

func (*Initial_constructContext) IsInitial_constructContext() {}

func NewInitial_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initial_constructContext {
	var p = new(Initial_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_initial_construct

	return p
}

func (s *Initial_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Initial_constructContext) K_initial() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_initial, 0)
}

func (s *Initial_constructContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Initial_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initial_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initial_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInitial_construct(s)
	}
}

func (s *Initial_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInitial_construct(s)
	}
}

func (p *VerilogParser) Initial_construct() (localctx IInitial_constructContext) {
	localctx = NewInitial_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, VerilogParserRULE_initial_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2343)
		p.Match(VerilogParserK_initial)
	}
	{
		p.SetState(2344)
		p.Statement()
	}

	return localctx
}

// IAlways_constructContext is an interface to support dynamic dispatch.
type IAlways_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlways_constructContext differentiates from other interfaces.
	IsAlways_constructContext()
}

type Always_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlways_constructContext() *Always_constructContext {
	var p = new(Always_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_always_construct
	return p
}

func (*Always_constructContext) IsAlways_constructContext() {}

func NewAlways_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Always_constructContext {
	var p = new(Always_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_always_construct

	return p
}

func (s *Always_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Always_constructContext) K_always() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_always, 0)
}

func (s *Always_constructContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Always_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Always_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Always_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterAlways_construct(s)
	}
}

func (s *Always_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitAlways_construct(s)
	}
}

func (p *VerilogParser) Always_construct() (localctx IAlways_constructContext) {
	localctx = NewAlways_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, VerilogParserRULE_always_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2346)
		p.Match(VerilogParserK_always)
	}
	{
		p.SetState(2347)
		p.Statement()
	}

	return localctx
}

// IBlocking_assignmentContext is an interface to support dynamic dispatch.
type IBlocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlocking_assignmentContext differentiates from other interfaces.
	IsBlocking_assignmentContext()
}

type Blocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlocking_assignmentContext() *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_blocking_assignment
	return p
}

func (*Blocking_assignmentContext) IsBlocking_assignmentContext() {}

func NewBlocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_blocking_assignment

	return p
}

func (s *Blocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Blocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Blocking_assignmentContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Blocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Blocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Blocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Blocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Blocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlocking_assignment(s)
	}
}

func (s *Blocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlocking_assignment(s)
	}
}

func (p *VerilogParser) Blocking_assignment() (localctx IBlocking_assignmentContext) {
	localctx = NewBlocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, VerilogParserRULE_blocking_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2349)
		p.Variable_lvalue()
	}
	{
		p.SetState(2350)
		p.Match(VerilogParserEq)
	}
	p.SetState(2352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_repeat || _la == VerilogParserSharp || _la == VerilogParserAt {
		{
			p.SetState(2351)
			p.Delay_or_event_control()
		}

	}
	{
		p.SetState(2354)
		p.Expression()
	}

	return localctx
}

// INonblocking_assignmentContext is an interface to support dynamic dispatch.
type INonblocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonblocking_assignmentContext differentiates from other interfaces.
	IsNonblocking_assignmentContext()
}

type Nonblocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonblocking_assignmentContext() *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_nonblocking_assignment
	return p
}

func (*Nonblocking_assignmentContext) IsNonblocking_assignmentContext() {}

func NewNonblocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_nonblocking_assignment

	return p
}

func (s *Nonblocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonblocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Nonblocking_assignmentContext) Left_angle_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_angle_eq, 0)
}

func (s *Nonblocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Nonblocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Nonblocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonblocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonblocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNonblocking_assignment(s)
	}
}

func (s *Nonblocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNonblocking_assignment(s)
	}
}

func (p *VerilogParser) Nonblocking_assignment() (localctx INonblocking_assignmentContext) {
	localctx = NewNonblocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, VerilogParserRULE_nonblocking_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2356)
		p.Variable_lvalue()
	}
	{
		p.SetState(2357)
		p.Match(VerilogParserLeft_angle_eq)
	}
	p.SetState(2359)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_repeat || _la == VerilogParserSharp || _la == VerilogParserAt {
		{
			p.SetState(2358)
			p.Delay_or_event_control()
		}

	}
	{
		p.SetState(2361)
		p.Expression()
	}

	return localctx
}

// IProcedural_continuous_assignmentsContext is an interface to support dynamic dispatch.
type IProcedural_continuous_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_continuous_assignmentsContext differentiates from other interfaces.
	IsProcedural_continuous_assignmentsContext()
}

type Procedural_continuous_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_continuous_assignmentsContext() *Procedural_continuous_assignmentsContext {
	var p = new(Procedural_continuous_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_procedural_continuous_assignments
	return p
}

func (*Procedural_continuous_assignmentsContext) IsProcedural_continuous_assignmentsContext() {}

func NewProcedural_continuous_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_continuous_assignmentsContext {
	var p = new(Procedural_continuous_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_procedural_continuous_assignments

	return p
}

func (s *Procedural_continuous_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_continuous_assignmentsContext) K_assign() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_assign, 0)
}

func (s *Procedural_continuous_assignmentsContext) Variable_assignment() IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Procedural_continuous_assignmentsContext) K_deassign() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_deassign, 0)
}

func (s *Procedural_continuous_assignmentsContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Procedural_continuous_assignmentsContext) K_force() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_force, 0)
}

func (s *Procedural_continuous_assignmentsContext) Net_assignment() INet_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_assignmentContext)
}

func (s *Procedural_continuous_assignmentsContext) K_release() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_release, 0)
}

func (s *Procedural_continuous_assignmentsContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Procedural_continuous_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_continuous_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_continuous_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterProcedural_continuous_assignments(s)
	}
}

func (s *Procedural_continuous_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitProcedural_continuous_assignments(s)
	}
}

func (p *VerilogParser) Procedural_continuous_assignments() (localctx IProcedural_continuous_assignmentsContext) {
	localctx = NewProcedural_continuous_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, VerilogParserRULE_procedural_continuous_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2375)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2363)
			p.Match(VerilogParserK_assign)
		}
		{
			p.SetState(2364)
			p.Variable_assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2365)
			p.Match(VerilogParserK_deassign)
		}
		{
			p.SetState(2366)
			p.Variable_lvalue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2367)
			p.Match(VerilogParserK_force)
		}
		{
			p.SetState(2368)
			p.Variable_assignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2369)
			p.Match(VerilogParserK_force)
		}
		{
			p.SetState(2370)
			p.Net_assignment()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2371)
			p.Match(VerilogParserK_release)
		}
		{
			p.SetState(2372)
			p.Variable_lvalue()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2373)
			p.Match(VerilogParserK_release)
		}
		{
			p.SetState(2374)
			p.Net_lvalue()
		}

	}

	return localctx
}

// IFunction_blocking_assignmentContext is an interface to support dynamic dispatch.
type IFunction_blocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_blocking_assignmentContext differentiates from other interfaces.
	IsFunction_blocking_assignmentContext()
}

type Function_blocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_blocking_assignmentContext() *Function_blocking_assignmentContext {
	var p = new(Function_blocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_blocking_assignment
	return p
}

func (*Function_blocking_assignmentContext) IsFunction_blocking_assignmentContext() {}

func NewFunction_blocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_blocking_assignmentContext {
	var p = new(Function_blocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_blocking_assignment

	return p
}

func (s *Function_blocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_blocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Function_blocking_assignmentContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Function_blocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_blocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_blocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_blocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_blocking_assignment(s)
	}
}

func (s *Function_blocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_blocking_assignment(s)
	}
}

func (p *VerilogParser) Function_blocking_assignment() (localctx IFunction_blocking_assignmentContext) {
	localctx = NewFunction_blocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, VerilogParserRULE_function_blocking_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2377)
		p.Variable_lvalue()
	}
	{
		p.SetState(2378)
		p.Match(VerilogParserEq)
	}
	{
		p.SetState(2379)
		p.Expression()
	}

	return localctx
}

// IFunction_statement_or_nullContext is an interface to support dynamic dispatch.
type IFunction_statement_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_statement_or_nullContext differentiates from other interfaces.
	IsFunction_statement_or_nullContext()
}

type Function_statement_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_statement_or_nullContext() *Function_statement_or_nullContext {
	var p = new(Function_statement_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_statement_or_null
	return p
}

func (*Function_statement_or_nullContext) IsFunction_statement_or_nullContext() {}

func NewFunction_statement_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_statement_or_nullContext {
	var p = new(Function_statement_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_statement_or_null

	return p
}

func (s *Function_statement_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_statement_or_nullContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_statement_or_nullContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Function_statement_or_nullContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_statement_or_nullContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_statement_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_statement_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_statement_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_statement_or_null(s)
	}
}

func (s *Function_statement_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_statement_or_null(s)
	}
}

func (p *VerilogParser) Function_statement_or_null() (localctx IFunction_statement_or_nullContext) {
	localctx = NewFunction_statement_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, VerilogParserRULE_function_statement_or_null)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2389)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2381)
			p.Function_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2385)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2382)
				p.Attribute_instance()
			}

			p.SetState(2387)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2388)
			p.Match(VerilogParserSemicolon)
		}

	}

	return localctx
}

// IFunction_seq_blockContext is an interface to support dynamic dispatch.
type IFunction_seq_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_seq_blockContext differentiates from other interfaces.
	IsFunction_seq_blockContext()
}

type Function_seq_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_seq_blockContext() *Function_seq_blockContext {
	var p = new(Function_seq_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_seq_block
	return p
}

func (*Function_seq_blockContext) IsFunction_seq_blockContext() {}

func NewFunction_seq_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_seq_blockContext {
	var p = new(Function_seq_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_seq_block

	return p
}

func (s *Function_seq_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_seq_blockContext) K_begin() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_begin, 0)
}

func (s *Function_seq_blockContext) K_end() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_end, 0)
}

func (s *Function_seq_blockContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Function_seq_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Function_seq_blockContext) AllFunction_statement() []IFunction_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem())
	var tst = make([]IFunction_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_statementContext)
		}
	}

	return tst
}

func (s *Function_seq_blockContext) Function_statement(i int) IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_seq_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_seq_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_seq_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_seq_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_seq_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_seq_block(s)
	}
}

func (s *Function_seq_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_seq_block(s)
	}
}

func (p *VerilogParser) Function_seq_block() (localctx IFunction_seq_blockContext) {
	localctx = NewFunction_seq_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, VerilogParserRULE_function_seq_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2391)
		p.Match(VerilogParserK_begin)
	}
	p.SetState(2400)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserColon {
		{
			p.SetState(2392)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(2393)
			p.Block_identifier()
		}
		p.SetState(2397)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 247, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2394)
					p.Block_item_declaration()
				}

			}
			p.SetState(2399)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 247, p.GetParserRuleContext())
		}

	}
	p.SetState(2405)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserK_begin)|(1<<VerilogParserK_case)|(1<<VerilogParserK_casex)|(1<<VerilogParserK_casez)|(1<<VerilogParserK_disable))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserK_for-41))|(1<<(VerilogParserK_forever-41))|(1<<(VerilogParserK_if-41)))) != 0) || _la == VerilogParserK_repeat || (((_la-125)&-(0x1f+1)) == 0 && ((1<<uint((_la-125)))&((1<<(VerilogParserK_while-125))|(1<<(VerilogParserK_TASK_monitoroff-125))|(1<<(VerilogParserK_TASK_monitoron-125))|(1<<(VerilogParserK_TASK_monitorb-125))|(1<<(VerilogParserK_TASK_displayo-125))|(1<<(VerilogParserK_TASK_displayh-125))|(1<<(VerilogParserK_TASK_displayb-125))|(1<<(VerilogParserK_TASK_strobeo-125))|(1<<(VerilogParserK_TASK_strobeh-125))|(1<<(VerilogParserK_TASK_strobeb-125))|(1<<(VerilogParserK_TASK_monitor-125))|(1<<(VerilogParserK_TASK_display-125)))) != 0) || (((_la-157)&-(0x1f+1)) == 0 && ((1<<uint((_la-157)))&((1<<(VerilogParserK_TASK_writeo-157))|(1<<(VerilogParserK_TASK_writeh-157))|(1<<(VerilogParserK_TASK_strobe-157))|(1<<(VerilogParserK_TASK_write-157))|(1<<(VerilogParserK_TASK_fmonitoro-157))|(1<<(VerilogParserK_TASK_fmonitorh-157))|(1<<(VerilogParserK_TASK_fmonitorb-157))|(1<<(VerilogParserK_TASK_fdisplayo-157))|(1<<(VerilogParserK_TASK_fdisplayh-157))|(1<<(VerilogParserK_TASK_fdisplayb-157))|(1<<(VerilogParserK_TASK_fmonitor-157))|(1<<(VerilogParserK_TASK_fdisplay-157))|(1<<(VerilogParserK_TASK_fstrobeo-157))|(1<<(VerilogParserK_TASK_fstrobeh-157))|(1<<(VerilogParserK_TASK_fstrobeb-157))|(1<<(VerilogParserK_TASK_sformatf-157))|(1<<(VerilogParserK_TASK_swriteo-157))|(1<<(VerilogParserK_TASK_swriteh-157))|(1<<(VerilogParserK_TASK_swriteb-157))|(1<<(VerilogParserK_TASK_sformat-157))|(1<<(VerilogParserK_TASK_fwriteo-157))|(1<<(VerilogParserK_TASK_fwriteh-157))|(1<<(VerilogParserK_TASK_fwriteb-157))|(1<<(VerilogParserK_TASK_fstrobe-157))|(1<<(VerilogParserK_TASK_ungetc-157))|(1<<(VerilogParserK_TASK_swrite-157))|(1<<(VerilogParserK_TASK_sscanf-157))|(1<<(VerilogParserK_TASK_rewind-157))|(1<<(VerilogParserK_TASK_fwrite-157))|(1<<(VerilogParserK_TASK_fscanf-157))|(1<<(VerilogParserK_TASK_fflush-157)))) != 0) || (((_la-189)&-(0x1f+1)) == 0 && ((1<<uint((_la-189)))&((1<<(VerilogParserK_TASK_ferror-189))|(1<<(VerilogParserK_TASK_fclose-189))|(1<<(VerilogParserK_TASK_ftell-189))|(1<<(VerilogParserK_TASK_fseek-189))|(1<<(VerilogParserK_TASK_fopen-189))|(1<<(VerilogParserK_TASK_fread-189))|(1<<(VerilogParserK_TASK_fgets-189))|(1<<(VerilogParserK_TASK_fgetc-189))|(1<<(VerilogParserK_TASK_feof-189))|(1<<(VerilogParserK_TASK_printtimescale-189))|(1<<(VerilogParserK_TASK_timeformat-189))|(1<<(VerilogParserK_TASK_finish-189))|(1<<(VerilogParserK_TASK_stop-189))|(1<<(VerilogParserK_TASK_async_nand_plane-189))|(1<<(VerilogParserK_TASK_async_nand_array-189))|(1<<(VerilogParserK_TASK_async_nor_plane-189))|(1<<(VerilogParserK_TASK_async_nor_array-189))|(1<<(VerilogParserK_TASK_async_and_plane-189))|(1<<(VerilogParserK_TASK_async_and_array-189))|(1<<(VerilogParserK_TASK_sync_nand_plane-189))|(1<<(VerilogParserK_TASK_sync_nand_array-189))|(1<<(VerilogParserK_TASK_sync_nor_plane-189))|(1<<(VerilogParserK_TASK_sync_nor_array-189))|(1<<(VerilogParserK_TASK_sync_and_plane-189))|(1<<(VerilogParserK_TASK_sync_and_array-189))|(1<<(VerilogParserK_TASK_async_or_plane-189))|(1<<(VerilogParserK_TASK_async_or_array-189))|(1<<(VerilogParserK_TASK_sync_or_plane-189))|(1<<(VerilogParserK_TASK_sync_or_array-189)))) != 0) || _la == VerilogParserLeft_parenthes || _la == VerilogParserLeft_brace || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2402)
			p.Function_statement()
		}

		p.SetState(2407)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2408)
		p.Match(VerilogParserK_end)
	}

	return localctx
}

// IVariable_assignmentContext is an interface to support dynamic dispatch.
type IVariable_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_assignmentContext differentiates from other interfaces.
	IsVariable_assignmentContext()
}

type Variable_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_assignmentContext() *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_assignment
	return p
}

func (*Variable_assignmentContext) IsVariable_assignmentContext() {}

func NewVariable_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_assignment

	return p
}

func (s *Variable_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Variable_assignmentContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Variable_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_assignment(s)
	}
}

func (s *Variable_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_assignment(s)
	}
}

func (p *VerilogParser) Variable_assignment() (localctx IVariable_assignmentContext) {
	localctx = NewVariable_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, VerilogParserRULE_variable_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2410)
		p.Variable_lvalue()
	}
	{
		p.SetState(2411)
		p.Match(VerilogParserEq)
	}
	{
		p.SetState(2412)
		p.Expression()
	}

	return localctx
}

// IPar_blockContext is an interface to support dynamic dispatch.
type IPar_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPar_blockContext differentiates from other interfaces.
	IsPar_blockContext()
}

type Par_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPar_blockContext() *Par_blockContext {
	var p = new(Par_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_par_block
	return p
}

func (*Par_blockContext) IsPar_blockContext() {}

func NewPar_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Par_blockContext {
	var p = new(Par_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_par_block

	return p
}

func (s *Par_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Par_blockContext) K_fork() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_fork, 0)
}

func (s *Par_blockContext) K_join() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_join, 0)
}

func (s *Par_blockContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Par_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Par_blockContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Par_blockContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Par_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Par_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Par_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Par_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Par_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPar_block(s)
	}
}

func (s *Par_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPar_block(s)
	}
}

func (p *VerilogParser) Par_block() (localctx IPar_blockContext) {
	localctx = NewPar_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, VerilogParserRULE_par_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2414)
		p.Match(VerilogParserK_fork)
	}
	p.SetState(2423)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserColon {
		{
			p.SetState(2415)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(2416)
			p.Block_identifier()
		}
		p.SetState(2420)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 250, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2417)
					p.Block_item_declaration()
				}

			}
			p.SetState(2422)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 250, p.GetParserRuleContext())
		}

	}
	p.SetState(2428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserK_assign)|(1<<VerilogParserK_begin)|(1<<VerilogParserK_case)|(1<<VerilogParserK_casex)|(1<<VerilogParserK_casez)|(1<<VerilogParserK_deassign)|(1<<VerilogParserK_disable))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserK_for-41))|(1<<(VerilogParserK_force-41))|(1<<(VerilogParserK_forever-41))|(1<<(VerilogParserK_fork-41))|(1<<(VerilogParserK_if-41)))) != 0) || _la == VerilogParserK_release || _la == VerilogParserK_repeat || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(VerilogParserK_wait-121))|(1<<(VerilogParserK_while-121))|(1<<(VerilogParserK_TASK_monitoroff-121))|(1<<(VerilogParserK_TASK_monitoron-121))|(1<<(VerilogParserK_TASK_monitorb-121))|(1<<(VerilogParserK_TASK_displayo-121))|(1<<(VerilogParserK_TASK_displayh-121))|(1<<(VerilogParserK_TASK_displayb-121))|(1<<(VerilogParserK_TASK_strobeo-121)))) != 0) || (((_la-153)&-(0x1f+1)) == 0 && ((1<<uint((_la-153)))&((1<<(VerilogParserK_TASK_strobeh-153))|(1<<(VerilogParserK_TASK_strobeb-153))|(1<<(VerilogParserK_TASK_monitor-153))|(1<<(VerilogParserK_TASK_display-153))|(1<<(VerilogParserK_TASK_writeo-153))|(1<<(VerilogParserK_TASK_writeh-153))|(1<<(VerilogParserK_TASK_strobe-153))|(1<<(VerilogParserK_TASK_write-153))|(1<<(VerilogParserK_TASK_fmonitoro-153))|(1<<(VerilogParserK_TASK_fmonitorh-153))|(1<<(VerilogParserK_TASK_fmonitorb-153))|(1<<(VerilogParserK_TASK_fdisplayo-153))|(1<<(VerilogParserK_TASK_fdisplayh-153))|(1<<(VerilogParserK_TASK_fdisplayb-153))|(1<<(VerilogParserK_TASK_fmonitor-153))|(1<<(VerilogParserK_TASK_fdisplay-153))|(1<<(VerilogParserK_TASK_fstrobeo-153))|(1<<(VerilogParserK_TASK_fstrobeh-153))|(1<<(VerilogParserK_TASK_fstrobeb-153))|(1<<(VerilogParserK_TASK_sformatf-153))|(1<<(VerilogParserK_TASK_swriteo-153))|(1<<(VerilogParserK_TASK_swriteh-153))|(1<<(VerilogParserK_TASK_swriteb-153))|(1<<(VerilogParserK_TASK_sformat-153))|(1<<(VerilogParserK_TASK_fwriteo-153))|(1<<(VerilogParserK_TASK_fwriteh-153))|(1<<(VerilogParserK_TASK_fwriteb-153))|(1<<(VerilogParserK_TASK_fstrobe-153))|(1<<(VerilogParserK_TASK_ungetc-153))|(1<<(VerilogParserK_TASK_swrite-153))|(1<<(VerilogParserK_TASK_sscanf-153)))) != 0) || (((_la-185)&-(0x1f+1)) == 0 && ((1<<uint((_la-185)))&((1<<(VerilogParserK_TASK_rewind-185))|(1<<(VerilogParserK_TASK_fwrite-185))|(1<<(VerilogParserK_TASK_fscanf-185))|(1<<(VerilogParserK_TASK_fflush-185))|(1<<(VerilogParserK_TASK_ferror-185))|(1<<(VerilogParserK_TASK_fclose-185))|(1<<(VerilogParserK_TASK_ftell-185))|(1<<(VerilogParserK_TASK_fseek-185))|(1<<(VerilogParserK_TASK_fopen-185))|(1<<(VerilogParserK_TASK_fread-185))|(1<<(VerilogParserK_TASK_fgets-185))|(1<<(VerilogParserK_TASK_fgetc-185))|(1<<(VerilogParserK_TASK_feof-185))|(1<<(VerilogParserK_TASK_printtimescale-185))|(1<<(VerilogParserK_TASK_timeformat-185))|(1<<(VerilogParserK_TASK_finish-185))|(1<<(VerilogParserK_TASK_stop-185))|(1<<(VerilogParserK_TASK_async_nand_plane-185))|(1<<(VerilogParserK_TASK_async_nand_array-185))|(1<<(VerilogParserK_TASK_async_nor_plane-185))|(1<<(VerilogParserK_TASK_async_nor_array-185))|(1<<(VerilogParserK_TASK_async_and_plane-185))|(1<<(VerilogParserK_TASK_async_and_array-185))|(1<<(VerilogParserK_TASK_sync_nand_plane-185))|(1<<(VerilogParserK_TASK_sync_nand_array-185))|(1<<(VerilogParserK_TASK_sync_nor_plane-185))|(1<<(VerilogParserK_TASK_sync_nor_array-185))|(1<<(VerilogParserK_TASK_sync_and_plane-185))|(1<<(VerilogParserK_TASK_sync_and_array-185))|(1<<(VerilogParserK_TASK_async_or_plane-185))|(1<<(VerilogParserK_TASK_async_or_array-185))|(1<<(VerilogParserK_TASK_sync_or_plane-185)))) != 0) || _la == VerilogParserK_TASK_sync_or_array || (((_la-254)&-(0x1f+1)) == 0 && ((1<<uint((_la-254)))&((1<<(VerilogParserLeft_parenthes-254))|(1<<(VerilogParserLeft_brace-254))|(1<<(VerilogParserSharp-254))|(1<<(VerilogParserAt-254))|(1<<(VerilogParserRight_arrow-254)))) != 0) || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2425)
			p.Statement()
		}

		p.SetState(2430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2431)
		p.Match(VerilogParserK_join)
	}

	return localctx
}

// ISeq_blockContext is an interface to support dynamic dispatch.
type ISeq_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeq_blockContext differentiates from other interfaces.
	IsSeq_blockContext()
}

type Seq_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeq_blockContext() *Seq_blockContext {
	var p = new(Seq_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_seq_block
	return p
}

func (*Seq_blockContext) IsSeq_blockContext() {}

func NewSeq_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seq_blockContext {
	var p = new(Seq_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_seq_block

	return p
}

func (s *Seq_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Seq_blockContext) K_begin() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_begin, 0)
}

func (s *Seq_blockContext) K_end() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_end, 0)
}

func (s *Seq_blockContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Seq_blockContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Seq_blockContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Seq_blockContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Seq_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Seq_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Seq_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seq_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seq_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSeq_block(s)
	}
}

func (s *Seq_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSeq_block(s)
	}
}

func (p *VerilogParser) Seq_block() (localctx ISeq_blockContext) {
	localctx = NewSeq_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, VerilogParserRULE_seq_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2433)
		p.Match(VerilogParserK_begin)
	}
	p.SetState(2442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserColon {
		{
			p.SetState(2434)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(2435)
			p.Block_identifier()
		}
		p.SetState(2439)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2436)
					p.Block_item_declaration()
				}

			}
			p.SetState(2441)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 253, p.GetParserRuleContext())
		}

	}
	p.SetState(2447)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<VerilogParserK_assign)|(1<<VerilogParserK_begin)|(1<<VerilogParserK_case)|(1<<VerilogParserK_casex)|(1<<VerilogParserK_casez)|(1<<VerilogParserK_deassign)|(1<<VerilogParserK_disable))) != 0) || (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(VerilogParserK_for-41))|(1<<(VerilogParserK_force-41))|(1<<(VerilogParserK_forever-41))|(1<<(VerilogParserK_fork-41))|(1<<(VerilogParserK_if-41)))) != 0) || _la == VerilogParserK_release || _la == VerilogParserK_repeat || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(VerilogParserK_wait-121))|(1<<(VerilogParserK_while-121))|(1<<(VerilogParserK_TASK_monitoroff-121))|(1<<(VerilogParserK_TASK_monitoron-121))|(1<<(VerilogParserK_TASK_monitorb-121))|(1<<(VerilogParserK_TASK_displayo-121))|(1<<(VerilogParserK_TASK_displayh-121))|(1<<(VerilogParserK_TASK_displayb-121))|(1<<(VerilogParserK_TASK_strobeo-121)))) != 0) || (((_la-153)&-(0x1f+1)) == 0 && ((1<<uint((_la-153)))&((1<<(VerilogParserK_TASK_strobeh-153))|(1<<(VerilogParserK_TASK_strobeb-153))|(1<<(VerilogParserK_TASK_monitor-153))|(1<<(VerilogParserK_TASK_display-153))|(1<<(VerilogParserK_TASK_writeo-153))|(1<<(VerilogParserK_TASK_writeh-153))|(1<<(VerilogParserK_TASK_strobe-153))|(1<<(VerilogParserK_TASK_write-153))|(1<<(VerilogParserK_TASK_fmonitoro-153))|(1<<(VerilogParserK_TASK_fmonitorh-153))|(1<<(VerilogParserK_TASK_fmonitorb-153))|(1<<(VerilogParserK_TASK_fdisplayo-153))|(1<<(VerilogParserK_TASK_fdisplayh-153))|(1<<(VerilogParserK_TASK_fdisplayb-153))|(1<<(VerilogParserK_TASK_fmonitor-153))|(1<<(VerilogParserK_TASK_fdisplay-153))|(1<<(VerilogParserK_TASK_fstrobeo-153))|(1<<(VerilogParserK_TASK_fstrobeh-153))|(1<<(VerilogParserK_TASK_fstrobeb-153))|(1<<(VerilogParserK_TASK_sformatf-153))|(1<<(VerilogParserK_TASK_swriteo-153))|(1<<(VerilogParserK_TASK_swriteh-153))|(1<<(VerilogParserK_TASK_swriteb-153))|(1<<(VerilogParserK_TASK_sformat-153))|(1<<(VerilogParserK_TASK_fwriteo-153))|(1<<(VerilogParserK_TASK_fwriteh-153))|(1<<(VerilogParserK_TASK_fwriteb-153))|(1<<(VerilogParserK_TASK_fstrobe-153))|(1<<(VerilogParserK_TASK_ungetc-153))|(1<<(VerilogParserK_TASK_swrite-153))|(1<<(VerilogParserK_TASK_sscanf-153)))) != 0) || (((_la-185)&-(0x1f+1)) == 0 && ((1<<uint((_la-185)))&((1<<(VerilogParserK_TASK_rewind-185))|(1<<(VerilogParserK_TASK_fwrite-185))|(1<<(VerilogParserK_TASK_fscanf-185))|(1<<(VerilogParserK_TASK_fflush-185))|(1<<(VerilogParserK_TASK_ferror-185))|(1<<(VerilogParserK_TASK_fclose-185))|(1<<(VerilogParserK_TASK_ftell-185))|(1<<(VerilogParserK_TASK_fseek-185))|(1<<(VerilogParserK_TASK_fopen-185))|(1<<(VerilogParserK_TASK_fread-185))|(1<<(VerilogParserK_TASK_fgets-185))|(1<<(VerilogParserK_TASK_fgetc-185))|(1<<(VerilogParserK_TASK_feof-185))|(1<<(VerilogParserK_TASK_printtimescale-185))|(1<<(VerilogParserK_TASK_timeformat-185))|(1<<(VerilogParserK_TASK_finish-185))|(1<<(VerilogParserK_TASK_stop-185))|(1<<(VerilogParserK_TASK_async_nand_plane-185))|(1<<(VerilogParserK_TASK_async_nand_array-185))|(1<<(VerilogParserK_TASK_async_nor_plane-185))|(1<<(VerilogParserK_TASK_async_nor_array-185))|(1<<(VerilogParserK_TASK_async_and_plane-185))|(1<<(VerilogParserK_TASK_async_and_array-185))|(1<<(VerilogParserK_TASK_sync_nand_plane-185))|(1<<(VerilogParserK_TASK_sync_nand_array-185))|(1<<(VerilogParserK_TASK_sync_nor_plane-185))|(1<<(VerilogParserK_TASK_sync_nor_array-185))|(1<<(VerilogParserK_TASK_sync_and_plane-185))|(1<<(VerilogParserK_TASK_sync_and_array-185))|(1<<(VerilogParserK_TASK_async_or_plane-185))|(1<<(VerilogParserK_TASK_async_or_array-185))|(1<<(VerilogParserK_TASK_sync_or_plane-185)))) != 0) || _la == VerilogParserK_TASK_sync_or_array || (((_la-254)&-(0x1f+1)) == 0 && ((1<<uint((_la-254)))&((1<<(VerilogParserLeft_parenthes-254))|(1<<(VerilogParserLeft_brace-254))|(1<<(VerilogParserSharp-254))|(1<<(VerilogParserAt-254))|(1<<(VerilogParserRight_arrow-254)))) != 0) || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2444)
			p.Statement()
		}

		p.SetState(2449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2450)
		p.Match(VerilogParserK_end)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Blocking_assignment() IBlocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlocking_assignmentContext)
}

func (s *StatementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *StatementContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *StatementContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *StatementContext) Case_statement() ICase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_statementContext)
}

func (s *StatementContext) Conditional_statement() IConditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_statementContext)
}

func (s *StatementContext) Disable_statement() IDisable_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisable_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisable_statementContext)
}

func (s *StatementContext) Event_trigger() IEvent_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_triggerContext)
}

func (s *StatementContext) Loop_statement() ILoop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_statementContext)
}

func (s *StatementContext) Nonblocking_assignment() INonblocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonblocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonblocking_assignmentContext)
}

func (s *StatementContext) Par_block() IPar_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPar_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPar_blockContext)
}

func (s *StatementContext) Procedural_continuous_assignments() IProcedural_continuous_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_continuous_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_continuous_assignmentsContext)
}

func (s *StatementContext) Procedural_timing_control_statement() IProcedural_timing_control_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_timing_control_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_timing_control_statementContext)
}

func (s *StatementContext) Seq_block() ISeq_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_blockContext)
}

func (s *StatementContext) System_task_enable() ISystem_task_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_enableContext)
}

func (s *StatementContext) Task_enable() ITask_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_enableContext)
}

func (s *StatementContext) Wait_statement() IWait_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWait_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWait_statementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *VerilogParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, VerilogParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2556)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 270, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2455)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2452)
				p.Attribute_instance()
			}

			p.SetState(2457)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2458)
			p.Blocking_assignment()
		}
		{
			p.SetState(2459)
			p.Match(VerilogParserSemicolon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2461)
				p.Attribute_instance()
			}

			p.SetState(2466)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2467)
			p.Case_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2471)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2468)
				p.Attribute_instance()
			}

			p.SetState(2473)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2474)
			p.Conditional_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2478)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2475)
				p.Attribute_instance()
			}

			p.SetState(2480)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2481)
			p.Disable_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(2485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2482)
				p.Attribute_instance()
			}

			p.SetState(2487)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2488)
			p.Event_trigger()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(2492)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2489)
				p.Attribute_instance()
			}

			p.SetState(2494)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2495)
			p.Loop_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(2499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2496)
				p.Attribute_instance()
			}

			p.SetState(2501)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2502)
			p.Nonblocking_assignment()
		}
		{
			p.SetState(2503)
			p.Match(VerilogParserSemicolon)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(2508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2505)
				p.Attribute_instance()
			}

			p.SetState(2510)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2511)
			p.Par_block()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(2515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2512)
				p.Attribute_instance()
			}

			p.SetState(2517)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2518)
			p.Procedural_continuous_assignments()
		}
		{
			p.SetState(2519)
			p.Match(VerilogParserSemicolon)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(2524)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2521)
				p.Attribute_instance()
			}

			p.SetState(2526)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2527)
			p.Procedural_timing_control_statement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		p.SetState(2531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2528)
				p.Attribute_instance()
			}

			p.SetState(2533)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2534)
			p.Seq_block()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		p.SetState(2538)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2535)
				p.Attribute_instance()
			}

			p.SetState(2540)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2541)
			p.System_task_enable()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		p.SetState(2545)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2542)
				p.Attribute_instance()
			}

			p.SetState(2547)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2548)
			p.Task_enable()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		p.SetState(2552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2549)
				p.Attribute_instance()
			}

			p.SetState(2554)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2555)
			p.Wait_statement()
		}

	}

	return localctx
}

// IStatement_or_nullContext is an interface to support dynamic dispatch.
type IStatement_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_or_nullContext differentiates from other interfaces.
	IsStatement_or_nullContext()
}

type Statement_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_or_nullContext() *Statement_or_nullContext {
	var p = new(Statement_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_statement_or_null
	return p
}

func (*Statement_or_nullContext) IsStatement_or_nullContext() {}

func NewStatement_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_or_nullContext {
	var p = new(Statement_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_statement_or_null

	return p
}

func (s *Statement_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_or_nullContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Statement_or_nullContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Statement_or_nullContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Statement_or_nullContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Statement_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStatement_or_null(s)
	}
}

func (s *Statement_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStatement_or_null(s)
	}
}

func (p *VerilogParser) Statement_or_null() (localctx IStatement_or_nullContext) {
	localctx = NewStatement_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, VerilogParserRULE_statement_or_null)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2566)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 272, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2558)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2562)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2559)
				p.Attribute_instance()
			}

			p.SetState(2564)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2565)
			p.Match(VerilogParserSemicolon)
		}

	}

	return localctx
}

// IFunction_statementContext is an interface to support dynamic dispatch.
type IFunction_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_statementContext differentiates from other interfaces.
	IsFunction_statementContext()
}

type Function_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_statementContext() *Function_statementContext {
	var p = new(Function_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_statement
	return p
}

func (*Function_statementContext) IsFunction_statementContext() {}

func NewFunction_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_statementContext {
	var p = new(Function_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_statement

	return p
}

func (s *Function_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_statementContext) Function_blocking_assignment() IFunction_blocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_blocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_blocking_assignmentContext)
}

func (s *Function_statementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Function_statementContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_statementContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_statementContext) Function_case_statement() IFunction_case_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_case_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_case_statementContext)
}

func (s *Function_statementContext) Function_conditional_statement() IFunction_conditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_conditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_conditional_statementContext)
}

func (s *Function_statementContext) Function_loop_statement() IFunction_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_loop_statementContext)
}

func (s *Function_statementContext) Function_seq_block() IFunction_seq_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_seq_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_seq_blockContext)
}

func (s *Function_statementContext) Disable_statement() IDisable_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisable_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisable_statementContext)
}

func (s *Function_statementContext) System_task_enable() ISystem_task_enableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_enableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_enableContext)
}

func (s *Function_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_statement(s)
	}
}

func (s *Function_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_statement(s)
	}
}

func (p *VerilogParser) Function_statement() (localctx IFunction_statementContext) {
	localctx = NewFunction_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, VerilogParserRULE_function_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2619)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 280, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2568)
				p.Attribute_instance()
			}

			p.SetState(2573)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2574)
			p.Function_blocking_assignment()
		}
		{
			p.SetState(2575)
			p.Match(VerilogParserSemicolon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2577)
				p.Attribute_instance()
			}

			p.SetState(2582)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2583)
			p.Function_case_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2584)
				p.Attribute_instance()
			}

			p.SetState(2589)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2590)
			p.Function_conditional_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2591)
				p.Attribute_instance()
			}

			p.SetState(2596)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2597)
			p.Function_loop_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(2601)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2598)
				p.Attribute_instance()
			}

			p.SetState(2603)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2604)
			p.Function_seq_block()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(2608)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2605)
				p.Attribute_instance()
			}

			p.SetState(2610)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2611)
			p.Disable_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(2615)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_parenthes {
			{
				p.SetState(2612)
				p.Attribute_instance()
			}

			p.SetState(2617)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2618)
			p.System_task_enable()
		}

	}

	return localctx
}

// IDelay_or_event_controlContext is an interface to support dynamic dispatch.
type IDelay_or_event_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_or_event_controlContext differentiates from other interfaces.
	IsDelay_or_event_controlContext()
}

type Delay_or_event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_or_event_controlContext() *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay_or_event_control
	return p
}

func (*Delay_or_event_controlContext) IsDelay_or_event_controlContext() {}

func NewDelay_or_event_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay_or_event_control

	return p
}

func (s *Delay_or_event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_or_event_controlContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Delay_or_event_controlContext) Event_control() IEvent_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_controlContext)
}

func (s *Delay_or_event_controlContext) K_repeat() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_repeat, 0)
}

func (s *Delay_or_event_controlContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Delay_or_event_controlContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Delay_or_event_controlContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Delay_or_event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_or_event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_or_event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay_or_event_control(s)
	}
}

func (s *Delay_or_event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay_or_event_control(s)
	}
}

func (p *VerilogParser) Delay_or_event_control() (localctx IDelay_or_event_controlContext) {
	localctx = NewDelay_or_event_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, VerilogParserRULE_delay_or_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2629)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSharp:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2621)
			p.Delay_control()
		}

	case VerilogParserAt:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2622)
			p.Event_control()
		}

	case VerilogParserK_repeat:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2623)
			p.Match(VerilogParserK_repeat)
		}
		{
			p.SetState(2624)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2625)
			p.Expression()
		}
		{
			p.SetState(2626)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2627)
			p.Event_control()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDelay_controlContext is an interface to support dynamic dispatch.
type IDelay_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_controlContext differentiates from other interfaces.
	IsDelay_controlContext()
}

type Delay_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_controlContext() *Delay_controlContext {
	var p = new(Delay_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delay_control
	return p
}

func (*Delay_controlContext) IsDelay_controlContext() {}

func NewDelay_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_controlContext {
	var p = new(Delay_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delay_control

	return p
}

func (s *Delay_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_controlContext) Sharp() antlr.TerminalNode {
	return s.GetToken(VerilogParserSharp, 0)
}

func (s *Delay_controlContext) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay_controlContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Delay_controlContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay_controlContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Delay_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelay_control(s)
	}
}

func (s *Delay_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelay_control(s)
	}
}

func (p *VerilogParser) Delay_control() (localctx IDelay_controlContext) {
	localctx = NewDelay_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, VerilogParserRULE_delay_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2638)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 282, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2631)
			p.Match(VerilogParserSharp)
		}
		{
			p.SetState(2632)
			p.Delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2633)
			p.Match(VerilogParserSharp)
		}
		{
			p.SetState(2634)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2635)
			p.Mintypmax_expression()
		}
		{
			p.SetState(2636)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IDisable_statementContext is an interface to support dynamic dispatch.
type IDisable_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisable_statementContext differentiates from other interfaces.
	IsDisable_statementContext()
}

type Disable_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisable_statementContext() *Disable_statementContext {
	var p = new(Disable_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_disable_statement
	return p
}

func (*Disable_statementContext) IsDisable_statementContext() {}

func NewDisable_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Disable_statementContext {
	var p = new(Disable_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_disable_statement

	return p
}

func (s *Disable_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Disable_statementContext) K_disable() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_disable, 0)
}

func (s *Disable_statementContext) Hierarchical_task_identifier() IHierarchical_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_task_identifierContext)
}

func (s *Disable_statementContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Disable_statementContext) Hierarchical_block_identifier() IHierarchical_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_block_identifierContext)
}

func (s *Disable_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Disable_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Disable_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDisable_statement(s)
	}
}

func (s *Disable_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDisable_statement(s)
	}
}

func (p *VerilogParser) Disable_statement() (localctx IDisable_statementContext) {
	localctx = NewDisable_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, VerilogParserRULE_disable_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2648)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 283, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2640)
			p.Match(VerilogParserK_disable)
		}
		{
			p.SetState(2641)
			p.Hierarchical_task_identifier()
		}
		{
			p.SetState(2642)
			p.Match(VerilogParserSemicolon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2644)
			p.Match(VerilogParserK_disable)
		}
		{
			p.SetState(2645)
			p.Hierarchical_block_identifier()
		}
		{
			p.SetState(2646)
			p.Match(VerilogParserSemicolon)
		}

	}

	return localctx
}

// IEvent_controlContext is an interface to support dynamic dispatch.
type IEvent_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_controlContext differentiates from other interfaces.
	IsEvent_controlContext()
}

type Event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_controlContext() *Event_controlContext {
	var p = new(Event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_control
	return p
}

func (*Event_controlContext) IsEvent_controlContext() {}

func NewEvent_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_controlContext {
	var p = new(Event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_control

	return p
}

func (s *Event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_controlContext) At() antlr.TerminalNode {
	return s.GetToken(VerilogParserAt, 0)
}

func (s *Event_controlContext) Event_identifier() IEvent_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_identifierContext)
}

func (s *Event_controlContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Event_controlContext) Event_expression() IEvent_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_expressionContext)
}

func (s *Event_controlContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Event_controlContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(VerilogParserAsterisk, 0)
}

func (s *Event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_control(s)
	}
}

func (s *Event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_control(s)
	}
}

func (p *VerilogParser) Event_control() (localctx IEvent_controlContext) {
	localctx = NewEvent_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, VerilogParserRULE_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2663)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2650)
			p.Match(VerilogParserAt)
		}
		{
			p.SetState(2651)
			p.Event_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2652)
			p.Match(VerilogParserAt)
		}
		{
			p.SetState(2653)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2654)
			p.Event_expression()
		}
		{
			p.SetState(2655)
			p.Match(VerilogParserRight_parenthes)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2657)
			p.Match(VerilogParserAt)
		}
		{
			p.SetState(2658)
			p.Match(VerilogParserAsterisk)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2659)
			p.Match(VerilogParserAt)
		}
		{
			p.SetState(2660)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2661)
			p.Match(VerilogParserAsterisk)
		}
		{
			p.SetState(2662)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IEvent_triggerContext is an interface to support dynamic dispatch.
type IEvent_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_triggerContext differentiates from other interfaces.
	IsEvent_triggerContext()
}

type Event_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_triggerContext() *Event_triggerContext {
	var p = new(Event_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_trigger
	return p
}

func (*Event_triggerContext) IsEvent_triggerContext() {}

func NewEvent_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_triggerContext {
	var p = new(Event_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_trigger

	return p
}

func (s *Event_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_triggerContext) Right_arrow() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_arrow, 0)
}

func (s *Event_triggerContext) Hierarchical_event_identifier() IHierarchical_event_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_event_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_event_identifierContext)
}

func (s *Event_triggerContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Event_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_trigger(s)
	}
}

func (s *Event_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_trigger(s)
	}
}

func (p *VerilogParser) Event_trigger() (localctx IEvent_triggerContext) {
	localctx = NewEvent_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, VerilogParserRULE_event_trigger)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2665)
		p.Match(VerilogParserRight_arrow)
	}
	{
		p.SetState(2666)
		p.Hierarchical_event_identifier()
	}
	{
		p.SetState(2667)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IEvent_expressionContext is an interface to support dynamic dispatch.
type IEvent_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_expressionContext differentiates from other interfaces.
	IsEvent_expressionContext()
}

type Event_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_expressionContext() *Event_expressionContext {
	var p = new(Event_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_expression
	return p
}

func (*Event_expressionContext) IsEvent_expressionContext() {}

func NewEvent_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_expressionContext {
	var p = new(Event_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_expression

	return p
}

func (s *Event_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_expressionContext) AllEvent_primary() []IEvent_primaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvent_primaryContext)(nil)).Elem())
	var tst = make([]IEvent_primaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvent_primaryContext)
		}
	}

	return tst
}

func (s *Event_expressionContext) Event_primary(i int) IEvent_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_primaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvent_primaryContext)
}

func (s *Event_expressionContext) AllK_or() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserK_or)
}

func (s *Event_expressionContext) K_or(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserK_or, i)
}

func (s *Event_expressionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Event_expressionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Event_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_expression(s)
	}
}

func (s *Event_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_expression(s)
	}
}

func (p *VerilogParser) Event_expression() (localctx IEvent_expressionContext) {
	localctx = NewEvent_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, VerilogParserRULE_event_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2669)
		p.Event_primary()
	}
	p.SetState(2676)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserK_or || _la == VerilogParserComma {
		p.SetState(2674)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case VerilogParserK_or:
			{
				p.SetState(2670)
				p.Match(VerilogParserK_or)
			}
			{
				p.SetState(2671)
				p.Event_primary()
			}

		case VerilogParserComma:
			{
				p.SetState(2672)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(2673)
				p.Event_primary()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2678)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEvent_primaryContext is an interface to support dynamic dispatch.
type IEvent_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_primaryContext differentiates from other interfaces.
	IsEvent_primaryContext()
}

type Event_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_primaryContext() *Event_primaryContext {
	var p = new(Event_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_primary
	return p
}

func (*Event_primaryContext) IsEvent_primaryContext() {}

func NewEvent_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_primaryContext {
	var p = new(Event_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_primary

	return p
}

func (s *Event_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_primaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Event_primaryContext) K_posedge() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_posedge, 0)
}

func (s *Event_primaryContext) K_negedge() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_negedge, 0)
}

func (s *Event_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_primary(s)
	}
}

func (s *Event_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_primary(s)
	}
}

func (p *VerilogParser) Event_primary() (localctx IEvent_primaryContext) {
	localctx = NewEvent_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, VerilogParserRULE_event_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2684)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_FUNC_q_initialize, VerilogParserK_FUNC_q_remove, VerilogParserK_FUNC_q_full, VerilogParserK_FUNC_q_exam, VerilogParserK_FUNC_q_add, VerilogParserK_FUNC_realtime, VerilogParserK_FUNC_stime, VerilogParserK_FUNC_time, VerilogParserK_FUNC_shortrealtobits, VerilogParserK_FUNC_bitstoshortreal, VerilogParserK_FUNC_realtobits, VerilogParserK_FUNC_bitstoreal, VerilogParserK_FUNC_unsigned, VerilogParserK_FUNC_signed, VerilogParserK_FUNC_rtoi, VerilogParserK_FUNC_itor, VerilogParserK_FUNC_cast, VerilogParserK_FUNC_random, VerilogParserK_FUNC_dist_exponential, VerilogParserK_FUNC_dist_chi_square, VerilogParserK_FUNC_dist_uniform, VerilogParserK_FUNC_dist_poisson, VerilogParserK_FUNC_dist_normal, VerilogParserK_FUNC_dist_erlang, VerilogParserK_FUNC_dist_t, VerilogParserK_FUNC_test_plusargs, VerilogParserK_FUNC_value_plusargs, VerilogParserPlus, VerilogParserMinus, VerilogParserExclamation_mark, VerilogParserLeft_parenthes, VerilogParserLeft_brace, VerilogParserAND, VerilogParserVertical_line, VerilogParserTilda, VerilogParserHat, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserString_const:
		{
			p.SetState(2679)
			p.Expression()
		}

	case VerilogParserK_posedge:
		{
			p.SetState(2680)
			p.Match(VerilogParserK_posedge)
		}
		{
			p.SetState(2681)
			p.Expression()
		}

	case VerilogParserK_negedge:
		{
			p.SetState(2682)
			p.Match(VerilogParserK_negedge)
		}
		{
			p.SetState(2683)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedural_timing_control_statementContext is an interface to support dynamic dispatch.
type IProcedural_timing_control_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_timing_control_statementContext differentiates from other interfaces.
	IsProcedural_timing_control_statementContext()
}

type Procedural_timing_control_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_timing_control_statementContext() *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_procedural_timing_control_statement
	return p
}

func (*Procedural_timing_control_statementContext) IsProcedural_timing_control_statementContext() {}

func NewProcedural_timing_control_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_procedural_timing_control_statement

	return p
}

func (s *Procedural_timing_control_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_timing_control_statementContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Procedural_timing_control_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Procedural_timing_control_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_timing_control_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_timing_control_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterProcedural_timing_control_statement(s)
	}
}

func (s *Procedural_timing_control_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitProcedural_timing_control_statement(s)
	}
}

func (p *VerilogParser) Procedural_timing_control_statement() (localctx IProcedural_timing_control_statementContext) {
	localctx = NewProcedural_timing_control_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, VerilogParserRULE_procedural_timing_control_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2686)
		p.Delay_or_event_control()
	}
	{
		p.SetState(2687)
		p.Statement_or_null()
	}

	return localctx
}

// IWait_statementContext is an interface to support dynamic dispatch.
type IWait_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWait_statementContext differentiates from other interfaces.
	IsWait_statementContext()
}

type Wait_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWait_statementContext() *Wait_statementContext {
	var p = new(Wait_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_wait_statement
	return p
}

func (*Wait_statementContext) IsWait_statementContext() {}

func NewWait_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wait_statementContext {
	var p = new(Wait_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_wait_statement

	return p
}

func (s *Wait_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Wait_statementContext) K_wait() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_wait, 0)
}

func (s *Wait_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Wait_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Wait_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Wait_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Wait_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wait_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wait_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterWait_statement(s)
	}
}

func (s *Wait_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitWait_statement(s)
	}
}

func (p *VerilogParser) Wait_statement() (localctx IWait_statementContext) {
	localctx = NewWait_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, VerilogParserRULE_wait_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2689)
		p.Match(VerilogParserK_wait)
	}
	{
		p.SetState(2690)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2691)
		p.Expression()
	}
	{
		p.SetState(2692)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(2693)
		p.Statement_or_null()
	}

	return localctx
}

// IConditional_statementContext is an interface to support dynamic dispatch.
type IConditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_statementContext differentiates from other interfaces.
	IsConditional_statementContext()
}

type Conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_statementContext() *Conditional_statementContext {
	var p = new(Conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_conditional_statement
	return p
}

func (*Conditional_statementContext) IsConditional_statementContext() {}

func NewConditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_statementContext {
	var p = new(Conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_conditional_statement

	return p
}

func (s *Conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_statementContext) K_if() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_if, 0)
}

func (s *Conditional_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Conditional_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Conditional_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Conditional_statementContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *Conditional_statementContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Conditional_statementContext) K_else() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_else, 0)
}

func (s *Conditional_statementContext) If_else_if_statement() IIf_else_if_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_else_if_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_else_if_statementContext)
}

func (s *Conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConditional_statement(s)
	}
}

func (s *Conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConditional_statement(s)
	}
}

func (p *VerilogParser) Conditional_statement() (localctx IConditional_statementContext) {
	localctx = NewConditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, VerilogParserRULE_conditional_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2705)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 289, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2695)
			p.Match(VerilogParserK_if)
		}
		{
			p.SetState(2696)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2697)
			p.Expression()
		}
		{
			p.SetState(2698)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2699)
			p.Statement_or_null()
		}
		p.SetState(2702)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 288, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2700)
				p.Match(VerilogParserK_else)
			}
			{
				p.SetState(2701)
				p.Statement_or_null()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2704)
			p.If_else_if_statement()
		}

	}

	return localctx
}

// IIf_else_if_statementContext is an interface to support dynamic dispatch.
type IIf_else_if_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_else_if_statementContext differentiates from other interfaces.
	IsIf_else_if_statementContext()
}

type If_else_if_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_else_if_statementContext() *If_else_if_statementContext {
	var p = new(If_else_if_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_if_else_if_statement
	return p
}

func (*If_else_if_statementContext) IsIf_else_if_statementContext() {}

func NewIf_else_if_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_else_if_statementContext {
	var p = new(If_else_if_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_if_else_if_statement

	return p
}

func (s *If_else_if_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_else_if_statementContext) AllK_if() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserK_if)
}

func (s *If_else_if_statementContext) K_if(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserK_if, i)
}

func (s *If_else_if_statementContext) AllLeft_parenthes() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_parenthes)
}

func (s *If_else_if_statementContext) Left_parenthes(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, i)
}

func (s *If_else_if_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *If_else_if_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *If_else_if_statementContext) AllRight_parenthes() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_parenthes)
}

func (s *If_else_if_statementContext) Right_parenthes(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, i)
}

func (s *If_else_if_statementContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *If_else_if_statementContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *If_else_if_statementContext) AllK_else() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserK_else)
}

func (s *If_else_if_statementContext) K_else(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserK_else, i)
}

func (s *If_else_if_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_else_if_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_else_if_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterIf_else_if_statement(s)
	}
}

func (s *If_else_if_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitIf_else_if_statement(s)
	}
}

func (p *VerilogParser) If_else_if_statement() (localctx IIf_else_if_statementContext) {
	localctx = NewIf_else_if_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, VerilogParserRULE_if_else_if_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2707)
		p.Match(VerilogParserK_if)
	}
	{
		p.SetState(2708)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2709)
		p.Expression()
	}
	{
		p.SetState(2710)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(2711)
		p.Statement_or_null()
	}
	p.SetState(2721)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 290, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2712)
				p.Match(VerilogParserK_else)
			}
			{
				p.SetState(2713)
				p.Match(VerilogParserK_if)
			}
			{
				p.SetState(2714)
				p.Match(VerilogParserLeft_parenthes)
			}
			{
				p.SetState(2715)
				p.Expression()
			}
			{
				p.SetState(2716)
				p.Match(VerilogParserRight_parenthes)
			}
			{
				p.SetState(2717)
				p.Statement_or_null()
			}

		}
		p.SetState(2723)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 290, p.GetParserRuleContext())
	}
	p.SetState(2726)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 291, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2724)
			p.Match(VerilogParserK_else)
		}
		{
			p.SetState(2725)
			p.Statement_or_null()
		}

	}

	return localctx
}

// IFunction_conditional_statementContext is an interface to support dynamic dispatch.
type IFunction_conditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_conditional_statementContext differentiates from other interfaces.
	IsFunction_conditional_statementContext()
}

type Function_conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_conditional_statementContext() *Function_conditional_statementContext {
	var p = new(Function_conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_conditional_statement
	return p
}

func (*Function_conditional_statementContext) IsFunction_conditional_statementContext() {}

func NewFunction_conditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_conditional_statementContext {
	var p = new(Function_conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_conditional_statement

	return p
}

func (s *Function_conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_conditional_statementContext) K_if() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_if, 0)
}

func (s *Function_conditional_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Function_conditional_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_conditional_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Function_conditional_statementContext) AllFunction_statement_or_null() []IFunction_statement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem())
	var tst = make([]IFunction_statement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_statement_or_nullContext)
		}
	}

	return tst
}

func (s *Function_conditional_statementContext) Function_statement_or_null(i int) IFunction_statement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_statement_or_nullContext)
}

func (s *Function_conditional_statementContext) K_else() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_else, 0)
}

func (s *Function_conditional_statementContext) Function_if_else_if_statement() IFunction_if_else_if_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_if_else_if_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_if_else_if_statementContext)
}

func (s *Function_conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_conditional_statement(s)
	}
}

func (s *Function_conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_conditional_statement(s)
	}
}

func (p *VerilogParser) Function_conditional_statement() (localctx IFunction_conditional_statementContext) {
	localctx = NewFunction_conditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, VerilogParserRULE_function_conditional_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2738)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2728)
			p.Match(VerilogParserK_if)
		}
		{
			p.SetState(2729)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2730)
			p.Expression()
		}
		{
			p.SetState(2731)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2732)
			p.Function_statement_or_null()
		}
		p.SetState(2735)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2733)
				p.Match(VerilogParserK_else)
			}
			{
				p.SetState(2734)
				p.Function_statement_or_null()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2737)
			p.Function_if_else_if_statement()
		}

	}

	return localctx
}

// IFunction_if_else_if_statementContext is an interface to support dynamic dispatch.
type IFunction_if_else_if_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_if_else_if_statementContext differentiates from other interfaces.
	IsFunction_if_else_if_statementContext()
}

type Function_if_else_if_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_if_else_if_statementContext() *Function_if_else_if_statementContext {
	var p = new(Function_if_else_if_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_if_else_if_statement
	return p
}

func (*Function_if_else_if_statementContext) IsFunction_if_else_if_statementContext() {}

func NewFunction_if_else_if_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_if_else_if_statementContext {
	var p = new(Function_if_else_if_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_if_else_if_statement

	return p
}

func (s *Function_if_else_if_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_if_else_if_statementContext) AllK_if() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserK_if)
}

func (s *Function_if_else_if_statementContext) K_if(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserK_if, i)
}

func (s *Function_if_else_if_statementContext) AllLeft_parenthes() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_parenthes)
}

func (s *Function_if_else_if_statementContext) Left_parenthes(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, i)
}

func (s *Function_if_else_if_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Function_if_else_if_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_if_else_if_statementContext) AllRight_parenthes() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_parenthes)
}

func (s *Function_if_else_if_statementContext) Right_parenthes(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, i)
}

func (s *Function_if_else_if_statementContext) AllFunction_statement_or_null() []IFunction_statement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem())
	var tst = make([]IFunction_statement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_statement_or_nullContext)
		}
	}

	return tst
}

func (s *Function_if_else_if_statementContext) Function_statement_or_null(i int) IFunction_statement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_statement_or_nullContext)
}

func (s *Function_if_else_if_statementContext) AllK_else() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserK_else)
}

func (s *Function_if_else_if_statementContext) K_else(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserK_else, i)
}

func (s *Function_if_else_if_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_if_else_if_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_if_else_if_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_if_else_if_statement(s)
	}
}

func (s *Function_if_else_if_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_if_else_if_statement(s)
	}
}

func (p *VerilogParser) Function_if_else_if_statement() (localctx IFunction_if_else_if_statementContext) {
	localctx = NewFunction_if_else_if_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, VerilogParserRULE_function_if_else_if_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2740)
		p.Match(VerilogParserK_if)
	}
	{
		p.SetState(2741)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(2742)
		p.Expression()
	}
	{
		p.SetState(2743)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(2744)
		p.Function_statement_or_null()
	}
	p.SetState(2754)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 294, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2745)
				p.Match(VerilogParserK_else)
			}
			{
				p.SetState(2746)
				p.Match(VerilogParserK_if)
			}
			{
				p.SetState(2747)
				p.Match(VerilogParserLeft_parenthes)
			}
			{
				p.SetState(2748)
				p.Expression()
			}
			{
				p.SetState(2749)
				p.Match(VerilogParserRight_parenthes)
			}
			{
				p.SetState(2750)
				p.Function_statement_or_null()
			}

		}
		p.SetState(2756)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 294, p.GetParserRuleContext())
	}
	p.SetState(2759)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 295, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2757)
			p.Match(VerilogParserK_else)
		}
		{
			p.SetState(2758)
			p.Function_statement_or_null()
		}

	}

	return localctx
}

// ICase_statementContext is an interface to support dynamic dispatch.
type ICase_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statementContext differentiates from other interfaces.
	IsCase_statementContext()
}

type Case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statementContext() *Case_statementContext {
	var p = new(Case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_case_statement
	return p
}

func (*Case_statementContext) IsCase_statementContext() {}

func NewCase_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statementContext {
	var p = new(Case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_case_statement

	return p
}

func (s *Case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statementContext) K_case() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_case, 0)
}

func (s *Case_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Case_statementContext) AllCase_item() []ICase_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_itemContext)(nil)).Elem())
	var tst = make([]ICase_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_itemContext)
		}
	}

	return tst
}

func (s *Case_statementContext) Case_item(i int) ICase_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_itemContext)
}

func (s *Case_statementContext) K_endcase() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_endcase, 0)
}

func (s *Case_statementContext) K_casez() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_casez, 0)
}

func (s *Case_statementContext) K_casex() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_casex, 0)
}

func (s *Case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCase_statement(s)
	}
}

func (s *Case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCase_statement(s)
	}
}

func (p *VerilogParser) Case_statement() (localctx ICase_statementContext) {
	localctx = NewCase_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, VerilogParserRULE_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2800)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_case:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2761)
			p.Match(VerilogParserK_case)
		}
		{
			p.SetState(2762)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2763)
			p.Expression()
		}
		{
			p.SetState(2764)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2765)
			p.Case_item()
		}
		p.SetState(2769)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserK_default || (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
			{
				p.SetState(2766)
				p.Case_item()
			}

			p.SetState(2771)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2772)
			p.Match(VerilogParserK_endcase)
		}

	case VerilogParserK_casez:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2774)
			p.Match(VerilogParserK_casez)
		}
		{
			p.SetState(2775)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2776)
			p.Expression()
		}
		{
			p.SetState(2777)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2778)
			p.Case_item()
		}
		p.SetState(2782)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserK_default || (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
			{
				p.SetState(2779)
				p.Case_item()
			}

			p.SetState(2784)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2785)
			p.Match(VerilogParserK_endcase)
		}

	case VerilogParserK_casex:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2787)
			p.Match(VerilogParserK_casex)
		}
		{
			p.SetState(2788)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2789)
			p.Expression()
		}
		{
			p.SetState(2790)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2791)
			p.Case_item()
		}
		p.SetState(2795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserK_default || (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
			{
				p.SetState(2792)
				p.Case_item()
			}

			p.SetState(2797)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2798)
			p.Match(VerilogParserK_endcase)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICase_itemContext is an interface to support dynamic dispatch.
type ICase_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_itemContext differentiates from other interfaces.
	IsCase_itemContext()
}

type Case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_itemContext() *Case_itemContext {
	var p = new(Case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_case_item
	return p
}

func (*Case_itemContext) IsCase_itemContext() {}

func NewCase_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_itemContext {
	var p = new(Case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_case_item

	return p
}

func (s *Case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_itemContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Case_itemContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_itemContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Case_itemContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Case_itemContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Case_itemContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Case_itemContext) K_default() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_default, 0)
}

func (s *Case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCase_item(s)
	}
}

func (s *Case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCase_item(s)
	}
}

func (p *VerilogParser) Case_item() (localctx ICase_itemContext) {
	localctx = NewCase_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, VerilogParserRULE_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2818)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_FUNC_q_initialize, VerilogParserK_FUNC_q_remove, VerilogParserK_FUNC_q_full, VerilogParserK_FUNC_q_exam, VerilogParserK_FUNC_q_add, VerilogParserK_FUNC_realtime, VerilogParserK_FUNC_stime, VerilogParserK_FUNC_time, VerilogParserK_FUNC_shortrealtobits, VerilogParserK_FUNC_bitstoshortreal, VerilogParserK_FUNC_realtobits, VerilogParserK_FUNC_bitstoreal, VerilogParserK_FUNC_unsigned, VerilogParserK_FUNC_signed, VerilogParserK_FUNC_rtoi, VerilogParserK_FUNC_itor, VerilogParserK_FUNC_cast, VerilogParserK_FUNC_random, VerilogParserK_FUNC_dist_exponential, VerilogParserK_FUNC_dist_chi_square, VerilogParserK_FUNC_dist_uniform, VerilogParserK_FUNC_dist_poisson, VerilogParserK_FUNC_dist_normal, VerilogParserK_FUNC_dist_erlang, VerilogParserK_FUNC_dist_t, VerilogParserK_FUNC_test_plusargs, VerilogParserK_FUNC_value_plusargs, VerilogParserPlus, VerilogParserMinus, VerilogParserExclamation_mark, VerilogParserLeft_parenthes, VerilogParserLeft_brace, VerilogParserAND, VerilogParserVertical_line, VerilogParserTilda, VerilogParserHat, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserString_const:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2802)
			p.Expression()
		}
		p.SetState(2807)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(2803)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(2804)
				p.Expression()
			}

			p.SetState(2809)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2810)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(2811)
			p.Statement_or_null()
		}

	case VerilogParserK_default:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2813)
			p.Match(VerilogParserK_default)
		}
		p.SetState(2815)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserColon {
			{
				p.SetState(2814)
				p.Match(VerilogParserColon)
			}

		}
		{
			p.SetState(2817)
			p.Statement_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_case_statementContext is an interface to support dynamic dispatch.
type IFunction_case_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_case_statementContext differentiates from other interfaces.
	IsFunction_case_statementContext()
}

type Function_case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_case_statementContext() *Function_case_statementContext {
	var p = new(Function_case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_case_statement
	return p
}

func (*Function_case_statementContext) IsFunction_case_statementContext() {}

func NewFunction_case_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_case_statementContext {
	var p = new(Function_case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_case_statement

	return p
}

func (s *Function_case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_case_statementContext) K_case() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_case, 0)
}

func (s *Function_case_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Function_case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_case_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Function_case_statementContext) AllFunction_case_item() []IFunction_case_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_case_itemContext)(nil)).Elem())
	var tst = make([]IFunction_case_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_case_itemContext)
		}
	}

	return tst
}

func (s *Function_case_statementContext) Function_case_item(i int) IFunction_case_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_case_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_case_itemContext)
}

func (s *Function_case_statementContext) K_endcase() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_endcase, 0)
}

func (s *Function_case_statementContext) K_casez() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_casez, 0)
}

func (s *Function_case_statementContext) K_casex() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_casex, 0)
}

func (s *Function_case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_case_statement(s)
	}
}

func (s *Function_case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_case_statement(s)
	}
}

func (p *VerilogParser) Function_case_statement() (localctx IFunction_case_statementContext) {
	localctx = NewFunction_case_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, VerilogParserRULE_function_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2859)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_case:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2820)
			p.Match(VerilogParserK_case)
		}
		{
			p.SetState(2821)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2822)
			p.Expression()
		}
		{
			p.SetState(2823)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2824)
			p.Function_case_item()
		}
		p.SetState(2828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserK_default || (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
			{
				p.SetState(2825)
				p.Function_case_item()
			}

			p.SetState(2830)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2831)
			p.Match(VerilogParserK_endcase)
		}

	case VerilogParserK_casez:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2833)
			p.Match(VerilogParserK_casez)
		}
		{
			p.SetState(2834)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2835)
			p.Expression()
		}
		{
			p.SetState(2836)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2837)
			p.Function_case_item()
		}
		p.SetState(2841)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserK_default || (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
			{
				p.SetState(2838)
				p.Function_case_item()
			}

			p.SetState(2843)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2844)
			p.Match(VerilogParserK_endcase)
		}

	case VerilogParserK_casex:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2846)
			p.Match(VerilogParserK_casex)
		}
		{
			p.SetState(2847)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2848)
			p.Expression()
		}
		{
			p.SetState(2849)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2850)
			p.Function_case_item()
		}
		p.SetState(2854)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserK_default || (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
			{
				p.SetState(2851)
				p.Function_case_item()
			}

			p.SetState(2856)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2857)
			p.Match(VerilogParserK_endcase)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_case_itemContext is an interface to support dynamic dispatch.
type IFunction_case_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_case_itemContext differentiates from other interfaces.
	IsFunction_case_itemContext()
}

type Function_case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_case_itemContext() *Function_case_itemContext {
	var p = new(Function_case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_case_item
	return p
}

func (*Function_case_itemContext) IsFunction_case_itemContext() {}

func NewFunction_case_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_case_itemContext {
	var p = new(Function_case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_case_item

	return p
}

func (s *Function_case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_case_itemContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Function_case_itemContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_case_itemContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Function_case_itemContext) Function_statement_or_null() IFunction_statement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statement_or_nullContext)
}

func (s *Function_case_itemContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Function_case_itemContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Function_case_itemContext) K_default() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_default, 0)
}

func (s *Function_case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_case_item(s)
	}
}

func (s *Function_case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_case_item(s)
	}
}

func (p *VerilogParser) Function_case_item() (localctx IFunction_case_itemContext) {
	localctx = NewFunction_case_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, VerilogParserRULE_function_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2877)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_FUNC_q_initialize, VerilogParserK_FUNC_q_remove, VerilogParserK_FUNC_q_full, VerilogParserK_FUNC_q_exam, VerilogParserK_FUNC_q_add, VerilogParserK_FUNC_realtime, VerilogParserK_FUNC_stime, VerilogParserK_FUNC_time, VerilogParserK_FUNC_shortrealtobits, VerilogParserK_FUNC_bitstoshortreal, VerilogParserK_FUNC_realtobits, VerilogParserK_FUNC_bitstoreal, VerilogParserK_FUNC_unsigned, VerilogParserK_FUNC_signed, VerilogParserK_FUNC_rtoi, VerilogParserK_FUNC_itor, VerilogParserK_FUNC_cast, VerilogParserK_FUNC_random, VerilogParserK_FUNC_dist_exponential, VerilogParserK_FUNC_dist_chi_square, VerilogParserK_FUNC_dist_uniform, VerilogParserK_FUNC_dist_poisson, VerilogParserK_FUNC_dist_normal, VerilogParserK_FUNC_dist_erlang, VerilogParserK_FUNC_dist_t, VerilogParserK_FUNC_test_plusargs, VerilogParserK_FUNC_value_plusargs, VerilogParserPlus, VerilogParserMinus, VerilogParserExclamation_mark, VerilogParserLeft_parenthes, VerilogParserLeft_brace, VerilogParserAND, VerilogParserVertical_line, VerilogParserTilda, VerilogParserHat, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserEscaped_identifier, VerilogParserSimple_identifier, VerilogParserString_const:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2861)
			p.Expression()
		}
		p.SetState(2866)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(2862)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(2863)
				p.Expression()
			}

			p.SetState(2868)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2869)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(2870)
			p.Function_statement_or_null()
		}

	case VerilogParserK_default:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2872)
			p.Match(VerilogParserK_default)
		}
		p.SetState(2874)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserColon {
			{
				p.SetState(2873)
				p.Match(VerilogParserColon)
			}

		}
		{
			p.SetState(2876)
			p.Function_statement_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_loop_statementContext is an interface to support dynamic dispatch.
type IFunction_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_loop_statementContext differentiates from other interfaces.
	IsFunction_loop_statementContext()
}

type Function_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_loop_statementContext() *Function_loop_statementContext {
	var p = new(Function_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_loop_statement
	return p
}

func (*Function_loop_statementContext) IsFunction_loop_statementContext() {}

func NewFunction_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_loop_statementContext {
	var p = new(Function_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_loop_statement

	return p
}

func (s *Function_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_loop_statementContext) K_forever() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_forever, 0)
}

func (s *Function_loop_statementContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_loop_statementContext) K_repeat() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_repeat, 0)
}

func (s *Function_loop_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Function_loop_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_loop_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Function_loop_statementContext) K_while() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_while, 0)
}

func (s *Function_loop_statementContext) K_for() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_for, 0)
}

func (s *Function_loop_statementContext) AllVariable_assignment() []IVariable_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem())
	var tst = make([]IVariable_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_assignmentContext)
		}
	}

	return tst
}

func (s *Function_loop_statementContext) Variable_assignment(i int) IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Function_loop_statementContext) AllSemicolon() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserSemicolon)
}

func (s *Function_loop_statementContext) Semicolon(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, i)
}

func (s *Function_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_loop_statement(s)
	}
}

func (s *Function_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_loop_statement(s)
	}
}

func (p *VerilogParser) Function_loop_statement() (localctx IFunction_loop_statementContext) {
	localctx = NewFunction_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, VerilogParserRULE_function_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2903)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_forever:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2879)
			p.Match(VerilogParserK_forever)
		}
		{
			p.SetState(2880)
			p.Function_statement()
		}

	case VerilogParserK_repeat:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2881)
			p.Match(VerilogParserK_repeat)
		}
		{
			p.SetState(2882)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2883)
			p.Expression()
		}
		{
			p.SetState(2884)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2885)
			p.Function_statement()
		}

	case VerilogParserK_while:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2887)
			p.Match(VerilogParserK_while)
		}
		{
			p.SetState(2888)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2889)
			p.Expression()
		}
		{
			p.SetState(2890)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2891)
			p.Function_statement()
		}

	case VerilogParserK_for:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2893)
			p.Match(VerilogParserK_for)
		}
		{
			p.SetState(2894)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2895)
			p.Variable_assignment()
		}
		{
			p.SetState(2896)
			p.Match(VerilogParserSemicolon)
		}
		{
			p.SetState(2897)
			p.Expression()
		}
		{
			p.SetState(2898)
			p.Match(VerilogParserSemicolon)
		}
		{
			p.SetState(2899)
			p.Variable_assignment()
		}
		{
			p.SetState(2900)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2901)
			p.Function_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILoop_statementContext is an interface to support dynamic dispatch.
type ILoop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_statementContext differentiates from other interfaces.
	IsLoop_statementContext()
}

type Loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_statementContext() *Loop_statementContext {
	var p = new(Loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_loop_statement
	return p
}

func (*Loop_statementContext) IsLoop_statementContext() {}

func NewLoop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_statementContext {
	var p = new(Loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_loop_statement

	return p
}

func (s *Loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_statementContext) K_forever() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_forever, 0)
}

func (s *Loop_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Loop_statementContext) K_repeat() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_repeat, 0)
}

func (s *Loop_statementContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Loop_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Loop_statementContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Loop_statementContext) K_while() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_while, 0)
}

func (s *Loop_statementContext) K_for() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_for, 0)
}

func (s *Loop_statementContext) AllVariable_assignment() []IVariable_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem())
	var tst = make([]IVariable_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_assignmentContext)
		}
	}

	return tst
}

func (s *Loop_statementContext) Variable_assignment(i int) IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Loop_statementContext) AllSemicolon() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserSemicolon)
}

func (s *Loop_statementContext) Semicolon(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, i)
}

func (s *Loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLoop_statement(s)
	}
}

func (s *Loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLoop_statement(s)
	}
}

func (p *VerilogParser) Loop_statement() (localctx ILoop_statementContext) {
	localctx = NewLoop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, VerilogParserRULE_loop_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2929)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_forever:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2905)
			p.Match(VerilogParserK_forever)
		}
		{
			p.SetState(2906)
			p.Statement()
		}

	case VerilogParserK_repeat:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2907)
			p.Match(VerilogParserK_repeat)
		}
		{
			p.SetState(2908)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2909)
			p.Expression()
		}
		{
			p.SetState(2910)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2911)
			p.Statement()
		}

	case VerilogParserK_while:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2913)
			p.Match(VerilogParserK_while)
		}
		{
			p.SetState(2914)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2915)
			p.Expression()
		}
		{
			p.SetState(2916)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2917)
			p.Statement()
		}

	case VerilogParserK_for:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2919)
			p.Match(VerilogParserK_for)
		}
		{
			p.SetState(2920)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(2921)
			p.Variable_assignment()
		}
		{
			p.SetState(2922)
			p.Match(VerilogParserSemicolon)
		}
		{
			p.SetState(2923)
			p.Expression()
		}
		{
			p.SetState(2924)
			p.Match(VerilogParserSemicolon)
		}
		{
			p.SetState(2925)
			p.Variable_assignment()
		}
		{
			p.SetState(2926)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(2927)
			p.Statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISystem_task_enableContext is an interface to support dynamic dispatch.
type ISystem_task_enableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_task_enableContext differentiates from other interfaces.
	IsSystem_task_enableContext()
}

type System_task_enableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_task_enableContext() *System_task_enableContext {
	var p = new(System_task_enableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_task_enable
	return p
}

func (*System_task_enableContext) IsSystem_task_enableContext() {}

func NewSystem_task_enableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_task_enableContext {
	var p = new(System_task_enableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_task_enable

	return p
}

func (s *System_task_enableContext) GetParser() antlr.Parser { return s.parser }

func (s *System_task_enableContext) System_task_identifier() ISystem_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_task_identifierContext)
}

func (s *System_task_enableContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *System_task_enableContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *System_task_enableContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *System_task_enableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *System_task_enableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *System_task_enableContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *System_task_enableContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *System_task_enableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_task_enableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_task_enableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSystem_task_enable(s)
	}
}

func (s *System_task_enableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSystem_task_enable(s)
	}
}

func (p *VerilogParser) System_task_enable() (localctx ISystem_task_enableContext) {
	localctx = NewSystem_task_enableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, VerilogParserRULE_system_task_enable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2931)
		p.System_task_identifier()
	}
	p.SetState(2944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_parenthes {
		{
			p.SetState(2932)
			p.Match(VerilogParserLeft_parenthes)
		}
		p.SetState(2941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
			{
				p.SetState(2933)
				p.Expression()
			}
			p.SetState(2938)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == VerilogParserComma {
				{
					p.SetState(2934)
					p.Match(VerilogParserComma)
				}
				{
					p.SetState(2935)
					p.Expression()
				}

				p.SetState(2940)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2943)
			p.Match(VerilogParserRight_parenthes)
		}

	}
	{
		p.SetState(2946)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// ITask_enableContext is an interface to support dynamic dispatch.
type ITask_enableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_enableContext differentiates from other interfaces.
	IsTask_enableContext()
}

type Task_enableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_enableContext() *Task_enableContext {
	var p = new(Task_enableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_enable
	return p
}

func (*Task_enableContext) IsTask_enableContext() {}

func NewTask_enableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_enableContext {
	var p = new(Task_enableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_enable

	return p
}

func (s *Task_enableContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_enableContext) Hierarchical_task_identifier() IHierarchical_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_task_identifierContext)
}

func (s *Task_enableContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Task_enableContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Task_enableContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Task_enableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Task_enableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Task_enableContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Task_enableContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Task_enableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_enableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_enableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_enable(s)
	}
}

func (s *Task_enableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_enable(s)
	}
}

func (p *VerilogParser) Task_enable() (localctx ITask_enableContext) {
	localctx = NewTask_enableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, VerilogParserRULE_task_enable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2948)
		p.Hierarchical_task_identifier()
	}
	p.SetState(2961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserLeft_parenthes {
		{
			p.SetState(2949)
			p.Match(VerilogParserLeft_parenthes)
		}
		p.SetState(2958)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
			{
				p.SetState(2950)
				p.Expression()
			}
			p.SetState(2955)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == VerilogParserComma {
				{
					p.SetState(2951)
					p.Match(VerilogParserComma)
				}
				{
					p.SetState(2952)
					p.Expression()
				}

				p.SetState(2957)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2960)
			p.Match(VerilogParserRight_parenthes)
		}

	}
	{
		p.SetState(2963)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// ISpecify_blockContext is an interface to support dynamic dispatch.
type ISpecify_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_blockContext differentiates from other interfaces.
	IsSpecify_blockContext()
}

type Specify_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_blockContext() *Specify_blockContext {
	var p = new(Specify_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_block
	return p
}

func (*Specify_blockContext) IsSpecify_blockContext() {}

func NewSpecify_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_blockContext {
	var p = new(Specify_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_block

	return p
}

func (s *Specify_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_blockContext) K_specify() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_specify, 0)
}

func (s *Specify_blockContext) K_endspecify() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_endspecify, 0)
}

func (s *Specify_blockContext) AllSpecify_item() []ISpecify_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_itemContext)(nil)).Elem())
	var tst = make([]ISpecify_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_itemContext)
		}
	}

	return tst
}

func (s *Specify_blockContext) Specify_item(i int) ISpecify_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_itemContext)
}

func (s *Specify_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecify_block(s)
	}
}

func (s *Specify_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecify_block(s)
	}
}

func (p *VerilogParser) Specify_block() (localctx ISpecify_blockContext) {
	localctx = NewSpecify_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, VerilogParserRULE_specify_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2965)
		p.Match(VerilogParserK_specify)
	}
	p.SetState(2969)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(VerilogParserK_if-50))|(1<<(VerilogParserK_ifnone-50))|(1<<(VerilogParserK_noshowcancelled-50)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(VerilogParserK_pulsestyle_ondetect-83))|(1<<(VerilogParserK_pulsestyle_onevent-83))|(1<<(VerilogParserK_showcancelled-83))|(1<<(VerilogParserK_specparam-83)))) != 0) || (((_la-130)&-(0x1f+1)) == 0 && ((1<<uint((_la-130)))&((1<<(VerilogParserK_fullskew-130))|(1<<(VerilogParserK_hold-130))|(1<<(VerilogParserK_nochange-130))|(1<<(VerilogParserK_period-130))|(1<<(VerilogParserK_recovery-130))|(1<<(VerilogParserK_recrem-130))|(1<<(VerilogParserK_removal-130))|(1<<(VerilogParserK_setuphold-130))|(1<<(VerilogParserK_setup-130))|(1<<(VerilogParserK_skew-130))|(1<<(VerilogParserK_timeskew-130))|(1<<(VerilogParserK_width-130)))) != 0) || _la == VerilogParserLeft_parenthes || _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
		{
			p.SetState(2966)
			p.Specify_item()
		}

		p.SetState(2971)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2972)
		p.Match(VerilogParserK_endspecify)
	}

	return localctx
}

// ISpecify_itemContext is an interface to support dynamic dispatch.
type ISpecify_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_itemContext differentiates from other interfaces.
	IsSpecify_itemContext()
}

type Specify_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_itemContext() *Specify_itemContext {
	var p = new(Specify_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_item
	return p
}

func (*Specify_itemContext) IsSpecify_itemContext() {}

func NewSpecify_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_itemContext {
	var p = new(Specify_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_item

	return p
}

func (s *Specify_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_itemContext) Specparam_declaration() ISpecparam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_declarationContext)
}

func (s *Specify_itemContext) Pulsestyle_declaration() IPulsestyle_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulsestyle_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulsestyle_declarationContext)
}

func (s *Specify_itemContext) Showcancelled_declaration() IShowcancelled_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShowcancelled_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShowcancelled_declarationContext)
}

func (s *Specify_itemContext) Path_declaration() IPath_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_declarationContext)
}

func (s *Specify_itemContext) System_timing_check() ISystem_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_timing_checkContext)
}

func (s *Specify_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecify_item(s)
	}
}

func (s *Specify_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecify_item(s)
	}
}

func (p *VerilogParser) Specify_item() (localctx ISpecify_itemContext) {
	localctx = NewSpecify_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, VerilogParserRULE_specify_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2979)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_specparam:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2974)
			p.Specparam_declaration()
		}

	case VerilogParserK_pulsestyle_ondetect, VerilogParserK_pulsestyle_onevent:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2975)
			p.Pulsestyle_declaration()
		}

	case VerilogParserK_noshowcancelled, VerilogParserK_showcancelled:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2976)
			p.Showcancelled_declaration()
		}

	case VerilogParserK_if, VerilogParserK_ifnone, VerilogParserLeft_parenthes, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2977)
			p.Path_declaration()
		}

	case VerilogParserK_fullskew, VerilogParserK_hold, VerilogParserK_nochange, VerilogParserK_period, VerilogParserK_recovery, VerilogParserK_recrem, VerilogParserK_removal, VerilogParserK_setuphold, VerilogParserK_setup, VerilogParserK_skew, VerilogParserK_timeskew, VerilogParserK_width:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2978)
			p.System_timing_check()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPulsestyle_declarationContext is an interface to support dynamic dispatch.
type IPulsestyle_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulsestyle_declarationContext differentiates from other interfaces.
	IsPulsestyle_declarationContext()
}

type Pulsestyle_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulsestyle_declarationContext() *Pulsestyle_declarationContext {
	var p = new(Pulsestyle_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_pulsestyle_declaration
	return p
}

func (*Pulsestyle_declarationContext) IsPulsestyle_declarationContext() {}

func NewPulsestyle_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulsestyle_declarationContext {
	var p = new(Pulsestyle_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_pulsestyle_declaration

	return p
}

func (s *Pulsestyle_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulsestyle_declarationContext) K_pulsestyle_onevent() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_pulsestyle_onevent, 0)
}

func (s *Pulsestyle_declarationContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Pulsestyle_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Pulsestyle_declarationContext) K_pulsestyle_ondetect() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_pulsestyle_ondetect, 0)
}

func (s *Pulsestyle_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulsestyle_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulsestyle_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPulsestyle_declaration(s)
	}
}

func (s *Pulsestyle_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPulsestyle_declaration(s)
	}
}

func (p *VerilogParser) Pulsestyle_declaration() (localctx IPulsestyle_declarationContext) {
	localctx = NewPulsestyle_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, VerilogParserRULE_pulsestyle_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2989)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_pulsestyle_onevent:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2981)
			p.Match(VerilogParserK_pulsestyle_onevent)
		}
		{
			p.SetState(2982)
			p.List_of_path_outputs()
		}
		{
			p.SetState(2983)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_pulsestyle_ondetect:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2985)
			p.Match(VerilogParserK_pulsestyle_ondetect)
		}
		{
			p.SetState(2986)
			p.List_of_path_outputs()
		}
		{
			p.SetState(2987)
			p.Match(VerilogParserSemicolon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShowcancelled_declarationContext is an interface to support dynamic dispatch.
type IShowcancelled_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShowcancelled_declarationContext differentiates from other interfaces.
	IsShowcancelled_declarationContext()
}

type Showcancelled_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowcancelled_declarationContext() *Showcancelled_declarationContext {
	var p = new(Showcancelled_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_showcancelled_declaration
	return p
}

func (*Showcancelled_declarationContext) IsShowcancelled_declarationContext() {}

func NewShowcancelled_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Showcancelled_declarationContext {
	var p = new(Showcancelled_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_showcancelled_declaration

	return p
}

func (s *Showcancelled_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Showcancelled_declarationContext) K_showcancelled() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_showcancelled, 0)
}

func (s *Showcancelled_declarationContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Showcancelled_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Showcancelled_declarationContext) K_noshowcancelled() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_noshowcancelled, 0)
}

func (s *Showcancelled_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Showcancelled_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Showcancelled_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterShowcancelled_declaration(s)
	}
}

func (s *Showcancelled_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitShowcancelled_declaration(s)
	}
}

func (p *VerilogParser) Showcancelled_declaration() (localctx IShowcancelled_declarationContext) {
	localctx = NewShowcancelled_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, VerilogParserRULE_showcancelled_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2999)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_showcancelled:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2991)
			p.Match(VerilogParserK_showcancelled)
		}
		{
			p.SetState(2992)
			p.List_of_path_outputs()
		}
		{
			p.SetState(2993)
			p.Match(VerilogParserSemicolon)
		}

	case VerilogParserK_noshowcancelled:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2995)
			p.Match(VerilogParserK_noshowcancelled)
		}
		{
			p.SetState(2996)
			p.List_of_path_outputs()
		}
		{
			p.SetState(2997)
			p.Match(VerilogParserSemicolon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPath_declarationContext is an interface to support dynamic dispatch.
type IPath_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_declarationContext differentiates from other interfaces.
	IsPath_declarationContext()
}

type Path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_declarationContext() *Path_declarationContext {
	var p = new(Path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_path_declaration
	return p
}

func (*Path_declarationContext) IsPath_declarationContext() {}

func NewPath_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_declarationContext {
	var p = new(Path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_path_declaration

	return p
}

func (s *Path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_declarationContext) Simple_path_declaration() ISimple_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_path_declarationContext)
}

func (s *Path_declarationContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Path_declarationContext) Edge_sensitive_path_declaration() IEdge_sensitive_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_sensitive_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_sensitive_path_declarationContext)
}

func (s *Path_declarationContext) State_dependent_path_declaration() IState_dependent_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_dependent_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_dependent_path_declarationContext)
}

func (s *Path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPath_declaration(s)
	}
}

func (s *Path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPath_declaration(s)
	}
}

func (p *VerilogParser) Path_declaration() (localctx IPath_declarationContext) {
	localctx = NewPath_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, VerilogParserRULE_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3010)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 322, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3001)
			p.Simple_path_declaration()
		}
		{
			p.SetState(3002)
			p.Match(VerilogParserSemicolon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3004)
			p.Edge_sensitive_path_declaration()
		}
		{
			p.SetState(3005)
			p.Match(VerilogParserSemicolon)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3007)
			p.State_dependent_path_declaration()
		}
		{
			p.SetState(3008)
			p.Match(VerilogParserSemicolon)
		}

	}

	return localctx
}

// ISimple_path_declarationContext is an interface to support dynamic dispatch.
type ISimple_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_path_declarationContext differentiates from other interfaces.
	IsSimple_path_declarationContext()
}

type Simple_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_path_declarationContext() *Simple_path_declarationContext {
	var p = new(Simple_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_simple_path_declaration
	return p
}

func (*Simple_path_declarationContext) IsSimple_path_declarationContext() {}

func NewSimple_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_path_declarationContext {
	var p = new(Simple_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_simple_path_declaration

	return p
}

func (s *Simple_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_path_declarationContext) Parallel_path_description() IParallel_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParallel_path_descriptionContext)
}

func (s *Simple_path_declarationContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Simple_path_declarationContext) Path_delay_value() IPath_delay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_valueContext)
}

func (s *Simple_path_declarationContext) Full_path_description() IFull_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_path_descriptionContext)
}

func (s *Simple_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSimple_path_declaration(s)
	}
}

func (s *Simple_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSimple_path_declaration(s)
	}
}

func (p *VerilogParser) Simple_path_declaration() (localctx ISimple_path_declarationContext) {
	localctx = NewSimple_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, VerilogParserRULE_simple_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3020)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3012)
			p.Parallel_path_description()
		}
		{
			p.SetState(3013)
			p.Match(VerilogParserEq)
		}
		{
			p.SetState(3014)
			p.Path_delay_value()
		}

	case VerilogParserLeft_parenthes:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3016)
			p.Full_path_description()
		}
		{
			p.SetState(3017)
			p.Match(VerilogParserEq)
		}
		{
			p.SetState(3018)
			p.Path_delay_value()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParallel_path_descriptionContext is an interface to support dynamic dispatch.
type IParallel_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_path_descriptionContext differentiates from other interfaces.
	IsParallel_path_descriptionContext()
}

type Parallel_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_path_descriptionContext() *Parallel_path_descriptionContext {
	var p = new(Parallel_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parallel_path_description
	return p
}

func (*Parallel_path_descriptionContext) IsParallel_path_descriptionContext() {}

func NewParallel_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_path_descriptionContext {
	var p = new(Parallel_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parallel_path_description

	return p
}

func (s *Parallel_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_path_descriptionContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Parallel_path_descriptionContext) Right_angle_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_angle_eq, 0)
}

func (s *Parallel_path_descriptionContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Parallel_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Parallel_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParallel_path_description(s)
	}
}

func (s *Parallel_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParallel_path_description(s)
	}
}

func (p *VerilogParser) Parallel_path_description() (localctx IParallel_path_descriptionContext) {
	localctx = NewParallel_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, VerilogParserRULE_parallel_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3022)
		p.Specify_input_terminal_descriptor()
	}
	p.SetState(3024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserPlus || _la == VerilogParserMinus {
		{
			p.SetState(3023)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3026)
		p.Match(VerilogParserRight_angle_eq)
	}
	{
		p.SetState(3027)
		p.Specify_output_terminal_descriptor()
	}

	return localctx
}

// IFull_path_descriptionContext is an interface to support dynamic dispatch.
type IFull_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFull_path_descriptionContext differentiates from other interfaces.
	IsFull_path_descriptionContext()
}

type Full_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_path_descriptionContext() *Full_path_descriptionContext {
	var p = new(Full_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_full_path_description
	return p
}

func (*Full_path_descriptionContext) IsFull_path_descriptionContext() {}

func NewFull_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_path_descriptionContext {
	var p = new(Full_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_full_path_description

	return p
}

func (s *Full_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_path_descriptionContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Full_path_descriptionContext) List_of_path_inputs() IList_of_path_inputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_inputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_inputsContext)
}

func (s *Full_path_descriptionContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(VerilogParserAsterisk, 0)
}

func (s *Full_path_descriptionContext) Right_angle_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_angle_bracket, 0)
}

func (s *Full_path_descriptionContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Full_path_descriptionContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Full_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Full_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Full_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFull_path_description(s)
	}
}

func (s *Full_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFull_path_description(s)
	}
}

func (p *VerilogParser) Full_path_description() (localctx IFull_path_descriptionContext) {
	localctx = NewFull_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, VerilogParserRULE_full_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3029)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3030)
		p.List_of_path_inputs()
	}
	p.SetState(3032)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserPlus || _la == VerilogParserMinus {
		{
			p.SetState(3031)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3034)
		p.Match(VerilogParserAsterisk)
	}
	{
		p.SetState(3035)
		p.Match(VerilogParserRight_angle_bracket)
	}
	{
		p.SetState(3036)
		p.List_of_path_outputs()
	}
	{
		p.SetState(3037)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IList_of_path_inputsContext is an interface to support dynamic dispatch.
type IList_of_path_inputsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_inputsContext differentiates from other interfaces.
	IsList_of_path_inputsContext()
}

type List_of_path_inputsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_inputsContext() *List_of_path_inputsContext {
	var p = new(List_of_path_inputsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_path_inputs
	return p
}

func (*List_of_path_inputsContext) IsList_of_path_inputsContext() {}

func NewList_of_path_inputsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_inputsContext {
	var p = new(List_of_path_inputsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_path_inputs

	return p
}

func (s *List_of_path_inputsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_inputsContext) AllSpecify_input_terminal_descriptor() []ISpecify_input_terminal_descriptorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem())
	var tst = make([]ISpecify_input_terminal_descriptorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_input_terminal_descriptorContext)
		}
	}

	return tst
}

func (s *List_of_path_inputsContext) Specify_input_terminal_descriptor(i int) ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *List_of_path_inputsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_path_inputsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_path_inputsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_inputsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_inputsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_path_inputs(s)
	}
}

func (s *List_of_path_inputsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_path_inputs(s)
	}
}

func (p *VerilogParser) List_of_path_inputs() (localctx IList_of_path_inputsContext) {
	localctx = NewList_of_path_inputsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, VerilogParserRULE_list_of_path_inputs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3039)
		p.Specify_input_terminal_descriptor()
	}
	p.SetState(3044)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(3040)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3041)
			p.Specify_input_terminal_descriptor()
		}

		p.SetState(3046)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_path_outputsContext is an interface to support dynamic dispatch.
type IList_of_path_outputsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_outputsContext differentiates from other interfaces.
	IsList_of_path_outputsContext()
}

type List_of_path_outputsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_outputsContext() *List_of_path_outputsContext {
	var p = new(List_of_path_outputsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_path_outputs
	return p
}

func (*List_of_path_outputsContext) IsList_of_path_outputsContext() {}

func NewList_of_path_outputsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_outputsContext {
	var p = new(List_of_path_outputsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_path_outputs

	return p
}

func (s *List_of_path_outputsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_outputsContext) AllSpecify_output_terminal_descriptor() []ISpecify_output_terminal_descriptorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem())
	var tst = make([]ISpecify_output_terminal_descriptorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_output_terminal_descriptorContext)
		}
	}

	return tst
}

func (s *List_of_path_outputsContext) Specify_output_terminal_descriptor(i int) ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *List_of_path_outputsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_path_outputsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_path_outputsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_outputsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_outputsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_path_outputs(s)
	}
}

func (s *List_of_path_outputsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_path_outputs(s)
	}
}

func (p *VerilogParser) List_of_path_outputs() (localctx IList_of_path_outputsContext) {
	localctx = NewList_of_path_outputsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, VerilogParserRULE_list_of_path_outputs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3047)
		p.Specify_output_terminal_descriptor()
	}
	p.SetState(3052)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(3048)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3049)
			p.Specify_output_terminal_descriptor()
		}

		p.SetState(3054)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISpecify_input_terminal_descriptorContext is an interface to support dynamic dispatch.
type ISpecify_input_terminal_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_input_terminal_descriptorContext differentiates from other interfaces.
	IsSpecify_input_terminal_descriptorContext()
}

type Specify_input_terminal_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_input_terminal_descriptorContext() *Specify_input_terminal_descriptorContext {
	var p = new(Specify_input_terminal_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_input_terminal_descriptor
	return p
}

func (*Specify_input_terminal_descriptorContext) IsSpecify_input_terminal_descriptorContext() {}

func NewSpecify_input_terminal_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_input_terminal_descriptorContext {
	var p = new(Specify_input_terminal_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_input_terminal_descriptor

	return p
}

func (s *Specify_input_terminal_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_input_terminal_descriptorContext) Input_identifier() IInput_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_identifierContext)
}

func (s *Specify_input_terminal_descriptorContext) Left_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, 0)
}

func (s *Specify_input_terminal_descriptorContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Specify_input_terminal_descriptorContext) Right_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, 0)
}

func (s *Specify_input_terminal_descriptorContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Specify_input_terminal_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_input_terminal_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_input_terminal_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecify_input_terminal_descriptor(s)
	}
}

func (s *Specify_input_terminal_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecify_input_terminal_descriptor(s)
	}
}

func (p *VerilogParser) Specify_input_terminal_descriptor() (localctx ISpecify_input_terminal_descriptorContext) {
	localctx = NewSpecify_input_terminal_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, VerilogParserRULE_specify_input_terminal_descriptor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3066)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 328, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3055)
			p.Input_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3056)
			p.Input_identifier()
		}
		{
			p.SetState(3057)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3058)
			p.Constant_expression()
		}
		{
			p.SetState(3059)
			p.Match(VerilogParserRight_bracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3061)
			p.Input_identifier()
		}
		{
			p.SetState(3062)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3063)
			p.Range_expression()
		}
		{
			p.SetState(3064)
			p.Match(VerilogParserRight_bracket)
		}

	}

	return localctx
}

// ISpecify_output_terminal_descriptorContext is an interface to support dynamic dispatch.
type ISpecify_output_terminal_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_output_terminal_descriptorContext differentiates from other interfaces.
	IsSpecify_output_terminal_descriptorContext()
}

type Specify_output_terminal_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_output_terminal_descriptorContext() *Specify_output_terminal_descriptorContext {
	var p = new(Specify_output_terminal_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_output_terminal_descriptor
	return p
}

func (*Specify_output_terminal_descriptorContext) IsSpecify_output_terminal_descriptorContext() {}

func NewSpecify_output_terminal_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_output_terminal_descriptorContext {
	var p = new(Specify_output_terminal_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_output_terminal_descriptor

	return p
}

func (s *Specify_output_terminal_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_output_terminal_descriptorContext) Output_identifier() IOutput_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_identifierContext)
}

func (s *Specify_output_terminal_descriptorContext) Left_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, 0)
}

func (s *Specify_output_terminal_descriptorContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Specify_output_terminal_descriptorContext) Right_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, 0)
}

func (s *Specify_output_terminal_descriptorContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Specify_output_terminal_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_output_terminal_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_output_terminal_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecify_output_terminal_descriptor(s)
	}
}

func (s *Specify_output_terminal_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecify_output_terminal_descriptor(s)
	}
}

func (p *VerilogParser) Specify_output_terminal_descriptor() (localctx ISpecify_output_terminal_descriptorContext) {
	localctx = NewSpecify_output_terminal_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, VerilogParserRULE_specify_output_terminal_descriptor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3079)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 329, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3068)
			p.Output_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3069)
			p.Output_identifier()
		}
		{
			p.SetState(3070)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3071)
			p.Constant_expression()
		}
		{
			p.SetState(3072)
			p.Match(VerilogParserRight_bracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3074)
			p.Output_identifier()
		}
		{
			p.SetState(3075)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3076)
			p.Range_expression()
		}
		{
			p.SetState(3077)
			p.Match(VerilogParserRight_bracket)
		}

	}

	return localctx
}

// IInput_identifierContext is an interface to support dynamic dispatch.
type IInput_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_identifierContext differentiates from other interfaces.
	IsInput_identifierContext()
}

type Input_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_identifierContext() *Input_identifierContext {
	var p = new(Input_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_identifier
	return p
}

func (*Input_identifierContext) IsInput_identifierContext() {}

func NewInput_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_identifierContext {
	var p = new(Input_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_identifier

	return p
}

func (s *Input_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_identifierContext) Input_port_identifier() IInput_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_port_identifierContext)
}

func (s *Input_identifierContext) Inout_port_identifier() IInout_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_port_identifierContext)
}

func (s *Input_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInput_identifier(s)
	}
}

func (s *Input_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInput_identifier(s)
	}
}

func (p *VerilogParser) Input_identifier() (localctx IInput_identifierContext) {
	localctx = NewInput_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, VerilogParserRULE_input_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3083)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3081)
			p.Input_port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3082)
			p.Inout_port_identifier()
		}

	}

	return localctx
}

// IOutput_identifierContext is an interface to support dynamic dispatch.
type IOutput_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_identifierContext differentiates from other interfaces.
	IsOutput_identifierContext()
}

type Output_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_identifierContext() *Output_identifierContext {
	var p = new(Output_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_identifier
	return p
}

func (*Output_identifierContext) IsOutput_identifierContext() {}

func NewOutput_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_identifierContext {
	var p = new(Output_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_identifier

	return p
}

func (s *Output_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_identifierContext) Output_port_identifier() IOutput_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_port_identifierContext)
}

func (s *Output_identifierContext) Inout_port_identifier() IInout_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_port_identifierContext)
}

func (s *Output_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_identifier(s)
	}
}

func (s *Output_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_identifier(s)
	}
}

func (p *VerilogParser) Output_identifier() (localctx IOutput_identifierContext) {
	localctx = NewOutput_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, VerilogParserRULE_output_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3087)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 331, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3085)
			p.Output_port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3086)
			p.Inout_port_identifier()
		}

	}

	return localctx
}

// IPath_delay_valueContext is an interface to support dynamic dispatch.
type IPath_delay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_delay_valueContext differentiates from other interfaces.
	IsPath_delay_valueContext()
}

type Path_delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_delay_valueContext() *Path_delay_valueContext {
	var p = new(Path_delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_path_delay_value
	return p
}

func (*Path_delay_valueContext) IsPath_delay_valueContext() {}

func NewPath_delay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_delay_valueContext {
	var p = new(Path_delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_path_delay_value

	return p
}

func (s *Path_delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_delay_valueContext) List_of_path_delay_expressions() IList_of_path_delay_expressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_delay_expressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_delay_expressionsContext)
}

func (s *Path_delay_valueContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Path_delay_valueContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Path_delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPath_delay_value(s)
	}
}

func (s *Path_delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPath_delay_value(s)
	}
}

func (p *VerilogParser) Path_delay_value() (localctx IPath_delay_valueContext) {
	localctx = NewPath_delay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, VerilogParserRULE_path_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3094)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3089)
			p.List_of_path_delay_expressions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3090)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(3091)
			p.List_of_path_delay_expressions()
		}
		{
			p.SetState(3092)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IList_of_path_delay_expressionsContext is an interface to support dynamic dispatch.
type IList_of_path_delay_expressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_delay_expressionsContext differentiates from other interfaces.
	IsList_of_path_delay_expressionsContext()
}

type List_of_path_delay_expressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_delay_expressionsContext() *List_of_path_delay_expressionsContext {
	var p = new(List_of_path_delay_expressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_list_of_path_delay_expressions
	return p
}

func (*List_of_path_delay_expressionsContext) IsList_of_path_delay_expressionsContext() {}

func NewList_of_path_delay_expressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_delay_expressionsContext {
	var p = new(List_of_path_delay_expressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_list_of_path_delay_expressions

	return p
}

func (s *List_of_path_delay_expressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_delay_expressionsContext) T_path_delay_expression() IT_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Trise_path_delay_expression() ITrise_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrise_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrise_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *List_of_path_delay_expressionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *List_of_path_delay_expressionsContext) Tfall_path_delay_expression() ITfall_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfall_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITfall_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz_path_delay_expression() ITz_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T01_path_delay_expression() IT01_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT01_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT01_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T10_path_delay_expression() IT10_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT10_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT10_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T0z_path_delay_expression() IT0z_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT0z_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT0z_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz1_path_delay_expression() ITz1_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz1_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz1_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T1z_path_delay_expression() IT1z_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT1z_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT1z_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz0_path_delay_expression() ITz0_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz0_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz0_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T0x_path_delay_expression() IT0x_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT0x_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT0x_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tx1_path_delay_expression() ITx1_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITx1_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITx1_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T1x_path_delay_expression() IT1x_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT1x_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT1x_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tx0_path_delay_expression() ITx0_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITx0_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITx0_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Txz_path_delay_expression() ITxz_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITxz_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITxz_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tzx_path_delay_expression() ITzx_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITzx_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITzx_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_delay_expressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_delay_expressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterList_of_path_delay_expressions(s)
	}
}

func (s *List_of_path_delay_expressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitList_of_path_delay_expressions(s)
	}
}

func (p *VerilogParser) List_of_path_delay_expressions() (localctx IList_of_path_delay_expressionsContext) {
	localctx = NewList_of_path_delay_expressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, VerilogParserRULE_list_of_path_delay_expressions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3143)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 333, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3096)
			p.T_path_delay_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3097)
			p.Trise_path_delay_expression()
		}
		{
			p.SetState(3098)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3099)
			p.Tfall_path_delay_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3101)
			p.Trise_path_delay_expression()
		}
		{
			p.SetState(3102)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3103)
			p.Tfall_path_delay_expression()
		}
		{
			p.SetState(3104)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3105)
			p.Tz_path_delay_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3107)
			p.T01_path_delay_expression()
		}
		{
			p.SetState(3108)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3109)
			p.T10_path_delay_expression()
		}
		{
			p.SetState(3110)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3111)
			p.T0z_path_delay_expression()
		}
		{
			p.SetState(3112)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3113)
			p.Tz1_path_delay_expression()
		}
		{
			p.SetState(3114)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3115)
			p.T1z_path_delay_expression()
		}
		{
			p.SetState(3116)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3117)
			p.Tz0_path_delay_expression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3119)
			p.T01_path_delay_expression()
		}
		{
			p.SetState(3120)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3121)
			p.T10_path_delay_expression()
		}
		{
			p.SetState(3122)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3123)
			p.T0z_path_delay_expression()
		}
		{
			p.SetState(3124)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3125)
			p.Tz1_path_delay_expression()
		}
		{
			p.SetState(3126)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3127)
			p.T1z_path_delay_expression()
		}
		{
			p.SetState(3128)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3129)
			p.Tz0_path_delay_expression()
		}
		{
			p.SetState(3130)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3131)
			p.T0x_path_delay_expression()
		}
		{
			p.SetState(3132)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3133)
			p.Tx1_path_delay_expression()
		}
		{
			p.SetState(3134)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3135)
			p.T1x_path_delay_expression()
		}
		{
			p.SetState(3136)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3137)
			p.Tx0_path_delay_expression()
		}
		{
			p.SetState(3138)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3139)
			p.Txz_path_delay_expression()
		}
		{
			p.SetState(3140)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3141)
			p.Tzx_path_delay_expression()
		}

	}

	return localctx
}

// IT_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT_path_delay_expressionContext differentiates from other interfaces.
	IsT_path_delay_expressionContext()
}

type T_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT_path_delay_expressionContext() *T_path_delay_expressionContext {
	var p = new(T_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t_path_delay_expression
	return p
}

func (*T_path_delay_expressionContext) IsT_path_delay_expressionContext() {}

func NewT_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T_path_delay_expressionContext {
	var p = new(T_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t_path_delay_expression

	return p
}

func (s *T_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT_path_delay_expression(s)
	}
}

func (s *T_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT_path_delay_expression(s)
	}
}

func (p *VerilogParser) T_path_delay_expression() (localctx IT_path_delay_expressionContext) {
	localctx = NewT_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, VerilogParserRULE_t_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3145)
		p.Path_delay_expression()
	}

	return localctx
}

// ITrise_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITrise_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrise_path_delay_expressionContext differentiates from other interfaces.
	IsTrise_path_delay_expressionContext()
}

type Trise_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrise_path_delay_expressionContext() *Trise_path_delay_expressionContext {
	var p = new(Trise_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_trise_path_delay_expression
	return p
}

func (*Trise_path_delay_expressionContext) IsTrise_path_delay_expressionContext() {}

func NewTrise_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trise_path_delay_expressionContext {
	var p = new(Trise_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_trise_path_delay_expression

	return p
}

func (s *Trise_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Trise_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Trise_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trise_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trise_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTrise_path_delay_expression(s)
	}
}

func (s *Trise_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTrise_path_delay_expression(s)
	}
}

func (p *VerilogParser) Trise_path_delay_expression() (localctx ITrise_path_delay_expressionContext) {
	localctx = NewTrise_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, VerilogParserRULE_trise_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3147)
		p.Path_delay_expression()
	}

	return localctx
}

// ITfall_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITfall_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfall_path_delay_expressionContext differentiates from other interfaces.
	IsTfall_path_delay_expressionContext()
}

type Tfall_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfall_path_delay_expressionContext() *Tfall_path_delay_expressionContext {
	var p = new(Tfall_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tfall_path_delay_expression
	return p
}

func (*Tfall_path_delay_expressionContext) IsTfall_path_delay_expressionContext() {}

func NewTfall_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tfall_path_delay_expressionContext {
	var p = new(Tfall_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tfall_path_delay_expression

	return p
}

func (s *Tfall_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tfall_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tfall_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tfall_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tfall_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTfall_path_delay_expression(s)
	}
}

func (s *Tfall_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTfall_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tfall_path_delay_expression() (localctx ITfall_path_delay_expressionContext) {
	localctx = NewTfall_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, VerilogParserRULE_tfall_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3149)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz_path_delay_expressionContext differentiates from other interfaces.
	IsTz_path_delay_expressionContext()
}

type Tz_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz_path_delay_expressionContext() *Tz_path_delay_expressionContext {
	var p = new(Tz_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tz_path_delay_expression
	return p
}

func (*Tz_path_delay_expressionContext) IsTz_path_delay_expressionContext() {}

func NewTz_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz_path_delay_expressionContext {
	var p = new(Tz_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tz_path_delay_expression

	return p
}

func (s *Tz_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTz_path_delay_expression(s)
	}
}

func (s *Tz_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTz_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tz_path_delay_expression() (localctx ITz_path_delay_expressionContext) {
	localctx = NewTz_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, VerilogParserRULE_tz_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3151)
		p.Path_delay_expression()
	}

	return localctx
}

// IT01_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT01_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT01_path_delay_expressionContext differentiates from other interfaces.
	IsT01_path_delay_expressionContext()
}

type T01_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT01_path_delay_expressionContext() *T01_path_delay_expressionContext {
	var p = new(T01_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t01_path_delay_expression
	return p
}

func (*T01_path_delay_expressionContext) IsT01_path_delay_expressionContext() {}

func NewT01_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T01_path_delay_expressionContext {
	var p = new(T01_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t01_path_delay_expression

	return p
}

func (s *T01_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T01_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T01_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T01_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T01_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT01_path_delay_expression(s)
	}
}

func (s *T01_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT01_path_delay_expression(s)
	}
}

func (p *VerilogParser) T01_path_delay_expression() (localctx IT01_path_delay_expressionContext) {
	localctx = NewT01_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, VerilogParserRULE_t01_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3153)
		p.Path_delay_expression()
	}

	return localctx
}

// IT10_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT10_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT10_path_delay_expressionContext differentiates from other interfaces.
	IsT10_path_delay_expressionContext()
}

type T10_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT10_path_delay_expressionContext() *T10_path_delay_expressionContext {
	var p = new(T10_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t10_path_delay_expression
	return p
}

func (*T10_path_delay_expressionContext) IsT10_path_delay_expressionContext() {}

func NewT10_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T10_path_delay_expressionContext {
	var p = new(T10_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t10_path_delay_expression

	return p
}

func (s *T10_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T10_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T10_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T10_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T10_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT10_path_delay_expression(s)
	}
}

func (s *T10_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT10_path_delay_expression(s)
	}
}

func (p *VerilogParser) T10_path_delay_expression() (localctx IT10_path_delay_expressionContext) {
	localctx = NewT10_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, VerilogParserRULE_t10_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3155)
		p.Path_delay_expression()
	}

	return localctx
}

// IT0z_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT0z_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT0z_path_delay_expressionContext differentiates from other interfaces.
	IsT0z_path_delay_expressionContext()
}

type T0z_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT0z_path_delay_expressionContext() *T0z_path_delay_expressionContext {
	var p = new(T0z_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t0z_path_delay_expression
	return p
}

func (*T0z_path_delay_expressionContext) IsT0z_path_delay_expressionContext() {}

func NewT0z_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T0z_path_delay_expressionContext {
	var p = new(T0z_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t0z_path_delay_expression

	return p
}

func (s *T0z_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T0z_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T0z_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T0z_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T0z_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT0z_path_delay_expression(s)
	}
}

func (s *T0z_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT0z_path_delay_expression(s)
	}
}

func (p *VerilogParser) T0z_path_delay_expression() (localctx IT0z_path_delay_expressionContext) {
	localctx = NewT0z_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, VerilogParserRULE_t0z_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3157)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz1_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz1_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz1_path_delay_expressionContext differentiates from other interfaces.
	IsTz1_path_delay_expressionContext()
}

type Tz1_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz1_path_delay_expressionContext() *Tz1_path_delay_expressionContext {
	var p = new(Tz1_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tz1_path_delay_expression
	return p
}

func (*Tz1_path_delay_expressionContext) IsTz1_path_delay_expressionContext() {}

func NewTz1_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz1_path_delay_expressionContext {
	var p = new(Tz1_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tz1_path_delay_expression

	return p
}

func (s *Tz1_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz1_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz1_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz1_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz1_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTz1_path_delay_expression(s)
	}
}

func (s *Tz1_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTz1_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tz1_path_delay_expression() (localctx ITz1_path_delay_expressionContext) {
	localctx = NewTz1_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, VerilogParserRULE_tz1_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3159)
		p.Path_delay_expression()
	}

	return localctx
}

// IT1z_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT1z_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT1z_path_delay_expressionContext differentiates from other interfaces.
	IsT1z_path_delay_expressionContext()
}

type T1z_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT1z_path_delay_expressionContext() *T1z_path_delay_expressionContext {
	var p = new(T1z_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t1z_path_delay_expression
	return p
}

func (*T1z_path_delay_expressionContext) IsT1z_path_delay_expressionContext() {}

func NewT1z_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T1z_path_delay_expressionContext {
	var p = new(T1z_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t1z_path_delay_expression

	return p
}

func (s *T1z_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T1z_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T1z_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T1z_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T1z_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT1z_path_delay_expression(s)
	}
}

func (s *T1z_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT1z_path_delay_expression(s)
	}
}

func (p *VerilogParser) T1z_path_delay_expression() (localctx IT1z_path_delay_expressionContext) {
	localctx = NewT1z_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, VerilogParserRULE_t1z_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3161)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz0_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz0_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz0_path_delay_expressionContext differentiates from other interfaces.
	IsTz0_path_delay_expressionContext()
}

type Tz0_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz0_path_delay_expressionContext() *Tz0_path_delay_expressionContext {
	var p = new(Tz0_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tz0_path_delay_expression
	return p
}

func (*Tz0_path_delay_expressionContext) IsTz0_path_delay_expressionContext() {}

func NewTz0_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz0_path_delay_expressionContext {
	var p = new(Tz0_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tz0_path_delay_expression

	return p
}

func (s *Tz0_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz0_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz0_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz0_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz0_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTz0_path_delay_expression(s)
	}
}

func (s *Tz0_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTz0_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tz0_path_delay_expression() (localctx ITz0_path_delay_expressionContext) {
	localctx = NewTz0_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, VerilogParserRULE_tz0_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3163)
		p.Path_delay_expression()
	}

	return localctx
}

// IT0x_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT0x_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT0x_path_delay_expressionContext differentiates from other interfaces.
	IsT0x_path_delay_expressionContext()
}

type T0x_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT0x_path_delay_expressionContext() *T0x_path_delay_expressionContext {
	var p = new(T0x_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t0x_path_delay_expression
	return p
}

func (*T0x_path_delay_expressionContext) IsT0x_path_delay_expressionContext() {}

func NewT0x_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T0x_path_delay_expressionContext {
	var p = new(T0x_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t0x_path_delay_expression

	return p
}

func (s *T0x_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T0x_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T0x_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T0x_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T0x_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT0x_path_delay_expression(s)
	}
}

func (s *T0x_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT0x_path_delay_expression(s)
	}
}

func (p *VerilogParser) T0x_path_delay_expression() (localctx IT0x_path_delay_expressionContext) {
	localctx = NewT0x_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, VerilogParserRULE_t0x_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3165)
		p.Path_delay_expression()
	}

	return localctx
}

// ITx1_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITx1_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTx1_path_delay_expressionContext differentiates from other interfaces.
	IsTx1_path_delay_expressionContext()
}

type Tx1_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTx1_path_delay_expressionContext() *Tx1_path_delay_expressionContext {
	var p = new(Tx1_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tx1_path_delay_expression
	return p
}

func (*Tx1_path_delay_expressionContext) IsTx1_path_delay_expressionContext() {}

func NewTx1_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tx1_path_delay_expressionContext {
	var p = new(Tx1_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tx1_path_delay_expression

	return p
}

func (s *Tx1_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tx1_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tx1_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tx1_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tx1_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTx1_path_delay_expression(s)
	}
}

func (s *Tx1_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTx1_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tx1_path_delay_expression() (localctx ITx1_path_delay_expressionContext) {
	localctx = NewTx1_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, VerilogParserRULE_tx1_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3167)
		p.Path_delay_expression()
	}

	return localctx
}

// IT1x_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT1x_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT1x_path_delay_expressionContext differentiates from other interfaces.
	IsT1x_path_delay_expressionContext()
}

type T1x_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT1x_path_delay_expressionContext() *T1x_path_delay_expressionContext {
	var p = new(T1x_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_t1x_path_delay_expression
	return p
}

func (*T1x_path_delay_expressionContext) IsT1x_path_delay_expressionContext() {}

func NewT1x_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T1x_path_delay_expressionContext {
	var p = new(T1x_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_t1x_path_delay_expression

	return p
}

func (s *T1x_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T1x_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T1x_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T1x_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T1x_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterT1x_path_delay_expression(s)
	}
}

func (s *T1x_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitT1x_path_delay_expression(s)
	}
}

func (p *VerilogParser) T1x_path_delay_expression() (localctx IT1x_path_delay_expressionContext) {
	localctx = NewT1x_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, VerilogParserRULE_t1x_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3169)
		p.Path_delay_expression()
	}

	return localctx
}

// ITx0_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITx0_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTx0_path_delay_expressionContext differentiates from other interfaces.
	IsTx0_path_delay_expressionContext()
}

type Tx0_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTx0_path_delay_expressionContext() *Tx0_path_delay_expressionContext {
	var p = new(Tx0_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tx0_path_delay_expression
	return p
}

func (*Tx0_path_delay_expressionContext) IsTx0_path_delay_expressionContext() {}

func NewTx0_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tx0_path_delay_expressionContext {
	var p = new(Tx0_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tx0_path_delay_expression

	return p
}

func (s *Tx0_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tx0_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tx0_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tx0_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tx0_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTx0_path_delay_expression(s)
	}
}

func (s *Tx0_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTx0_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tx0_path_delay_expression() (localctx ITx0_path_delay_expressionContext) {
	localctx = NewTx0_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, VerilogParserRULE_tx0_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3171)
		p.Path_delay_expression()
	}

	return localctx
}

// ITxz_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITxz_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTxz_path_delay_expressionContext differentiates from other interfaces.
	IsTxz_path_delay_expressionContext()
}

type Txz_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTxz_path_delay_expressionContext() *Txz_path_delay_expressionContext {
	var p = new(Txz_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_txz_path_delay_expression
	return p
}

func (*Txz_path_delay_expressionContext) IsTxz_path_delay_expressionContext() {}

func NewTxz_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Txz_path_delay_expressionContext {
	var p = new(Txz_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_txz_path_delay_expression

	return p
}

func (s *Txz_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Txz_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Txz_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Txz_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Txz_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTxz_path_delay_expression(s)
	}
}

func (s *Txz_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTxz_path_delay_expression(s)
	}
}

func (p *VerilogParser) Txz_path_delay_expression() (localctx ITxz_path_delay_expressionContext) {
	localctx = NewTxz_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, VerilogParserRULE_txz_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3173)
		p.Path_delay_expression()
	}

	return localctx
}

// ITzx_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITzx_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTzx_path_delay_expressionContext differentiates from other interfaces.
	IsTzx_path_delay_expressionContext()
}

type Tzx_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTzx_path_delay_expressionContext() *Tzx_path_delay_expressionContext {
	var p = new(Tzx_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_tzx_path_delay_expression
	return p
}

func (*Tzx_path_delay_expressionContext) IsTzx_path_delay_expressionContext() {}

func NewTzx_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tzx_path_delay_expressionContext {
	var p = new(Tzx_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_tzx_path_delay_expression

	return p
}

func (s *Tzx_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tzx_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tzx_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tzx_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tzx_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTzx_path_delay_expression(s)
	}
}

func (s *Tzx_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTzx_path_delay_expression(s)
	}
}

func (p *VerilogParser) Tzx_path_delay_expression() (localctx ITzx_path_delay_expressionContext) {
	localctx = NewTzx_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, VerilogParserRULE_tzx_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3175)
		p.Path_delay_expression()
	}

	return localctx
}

// IPath_delay_expressionContext is an interface to support dynamic dispatch.
type IPath_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_delay_expressionContext differentiates from other interfaces.
	IsPath_delay_expressionContext()
}

type Path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_delay_expressionContext() *Path_delay_expressionContext {
	var p = new(Path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_path_delay_expression
	return p
}

func (*Path_delay_expressionContext) IsPath_delay_expressionContext() {}

func NewPath_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_delay_expressionContext {
	var p = new(Path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_path_delay_expression

	return p
}

func (s *Path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_delay_expressionContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPath_delay_expression(s)
	}
}

func (s *Path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPath_delay_expression(s)
	}
}

func (p *VerilogParser) Path_delay_expression() (localctx IPath_delay_expressionContext) {
	localctx = NewPath_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, VerilogParserRULE_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3177)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IEdge_sensitive_path_declarationContext is an interface to support dynamic dispatch.
type IEdge_sensitive_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEdge_sensitive_path_declarationContext differentiates from other interfaces.
	IsEdge_sensitive_path_declarationContext()
}

type Edge_sensitive_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdge_sensitive_path_declarationContext() *Edge_sensitive_path_declarationContext {
	var p = new(Edge_sensitive_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_edge_sensitive_path_declaration
	return p
}

func (*Edge_sensitive_path_declarationContext) IsEdge_sensitive_path_declarationContext() {}

func NewEdge_sensitive_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Edge_sensitive_path_declarationContext {
	var p = new(Edge_sensitive_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_edge_sensitive_path_declaration

	return p
}

func (s *Edge_sensitive_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Edge_sensitive_path_declarationContext) Parallel_edge_sensitive_path_description() IParallel_edge_sensitive_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_edge_sensitive_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParallel_edge_sensitive_path_descriptionContext)
}

func (s *Edge_sensitive_path_declarationContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Edge_sensitive_path_declarationContext) Path_delay_value() IPath_delay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_valueContext)
}

func (s *Edge_sensitive_path_declarationContext) Full_edge_sensitive_path_description() IFull_edge_sensitive_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_edge_sensitive_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_edge_sensitive_path_descriptionContext)
}

func (s *Edge_sensitive_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Edge_sensitive_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Edge_sensitive_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEdge_sensitive_path_declaration(s)
	}
}

func (s *Edge_sensitive_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEdge_sensitive_path_declaration(s)
	}
}

func (p *VerilogParser) Edge_sensitive_path_declaration() (localctx IEdge_sensitive_path_declarationContext) {
	localctx = NewEdge_sensitive_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, VerilogParserRULE_edge_sensitive_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3187)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 334, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3179)
			p.Parallel_edge_sensitive_path_description()
		}
		{
			p.SetState(3180)
			p.Match(VerilogParserEq)
		}
		{
			p.SetState(3181)
			p.Path_delay_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3183)
			p.Full_edge_sensitive_path_description()
		}
		{
			p.SetState(3184)
			p.Match(VerilogParserEq)
		}
		{
			p.SetState(3185)
			p.Path_delay_value()
		}

	}

	return localctx
}

// IParallel_edge_sensitive_path_descriptionContext is an interface to support dynamic dispatch.
type IParallel_edge_sensitive_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_edge_sensitive_path_descriptionContext differentiates from other interfaces.
	IsParallel_edge_sensitive_path_descriptionContext()
}

type Parallel_edge_sensitive_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_edge_sensitive_path_descriptionContext() *Parallel_edge_sensitive_path_descriptionContext {
	var p = new(Parallel_edge_sensitive_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parallel_edge_sensitive_path_description
	return p
}

func (*Parallel_edge_sensitive_path_descriptionContext) IsParallel_edge_sensitive_path_descriptionContext() {
}

func NewParallel_edge_sensitive_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_edge_sensitive_path_descriptionContext {
	var p = new(Parallel_edge_sensitive_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parallel_edge_sensitive_path_description

	return p
}

func (s *Parallel_edge_sensitive_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_edge_sensitive_path_descriptionContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Right_angle_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_angle_eq, 0)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Data_source_expression() IData_source_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_source_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_source_expressionContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_edge_sensitive_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParallel_edge_sensitive_path_description(s)
	}
}

func (s *Parallel_edge_sensitive_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParallel_edge_sensitive_path_description(s)
	}
}

func (p *VerilogParser) Parallel_edge_sensitive_path_description() (localctx IParallel_edge_sensitive_path_descriptionContext) {
	localctx = NewParallel_edge_sensitive_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, VerilogParserRULE_parallel_edge_sensitive_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3189)
		p.Match(VerilogParserLeft_parenthes)
	}
	p.SetState(3191)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_negedge || _la == VerilogParserK_posedge {
		{
			p.SetState(3190)
			p.Edge_identifier()
		}

	}
	{
		p.SetState(3193)
		p.Specify_input_terminal_descriptor()
	}
	{
		p.SetState(3194)
		p.Match(VerilogParserRight_angle_eq)
	}
	{
		p.SetState(3195)
		p.Specify_output_terminal_descriptor()
	}
	p.SetState(3197)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserPlus || _la == VerilogParserMinus {
		{
			p.SetState(3196)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3199)
		p.Match(VerilogParserColon)
	}
	{
		p.SetState(3200)
		p.Data_source_expression()
	}
	{
		p.SetState(3201)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IFull_edge_sensitive_path_descriptionContext is an interface to support dynamic dispatch.
type IFull_edge_sensitive_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFull_edge_sensitive_path_descriptionContext differentiates from other interfaces.
	IsFull_edge_sensitive_path_descriptionContext()
}

type Full_edge_sensitive_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_edge_sensitive_path_descriptionContext() *Full_edge_sensitive_path_descriptionContext {
	var p = new(Full_edge_sensitive_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_full_edge_sensitive_path_description
	return p
}

func (*Full_edge_sensitive_path_descriptionContext) IsFull_edge_sensitive_path_descriptionContext() {}

func NewFull_edge_sensitive_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_edge_sensitive_path_descriptionContext {
	var p = new(Full_edge_sensitive_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_full_edge_sensitive_path_description

	return p
}

func (s *Full_edge_sensitive_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_edge_sensitive_path_descriptionContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Full_edge_sensitive_path_descriptionContext) List_of_path_inputs() IList_of_path_inputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_inputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_inputsContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) Right_asterisk_arrow() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_asterisk_arrow, 0)
}

func (s *Full_edge_sensitive_path_descriptionContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Full_edge_sensitive_path_descriptionContext) Data_source_expression() IData_source_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_source_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_source_expressionContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Full_edge_sensitive_path_descriptionContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_edge_sensitive_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Full_edge_sensitive_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFull_edge_sensitive_path_description(s)
	}
}

func (s *Full_edge_sensitive_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFull_edge_sensitive_path_description(s)
	}
}

func (p *VerilogParser) Full_edge_sensitive_path_description() (localctx IFull_edge_sensitive_path_descriptionContext) {
	localctx = NewFull_edge_sensitive_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, VerilogParserRULE_full_edge_sensitive_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3203)
		p.Match(VerilogParserLeft_parenthes)
	}
	p.SetState(3205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_negedge || _la == VerilogParserK_posedge {
		{
			p.SetState(3204)
			p.Edge_identifier()
		}

	}
	{
		p.SetState(3207)
		p.List_of_path_inputs()
	}
	{
		p.SetState(3208)
		p.Match(VerilogParserRight_asterisk_arrow)
	}
	{
		p.SetState(3209)
		p.List_of_path_outputs()
	}
	p.SetState(3211)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserPlus || _la == VerilogParserMinus {
		{
			p.SetState(3210)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(3213)
		p.Match(VerilogParserColon)
	}
	{
		p.SetState(3214)
		p.Data_source_expression()
	}
	{
		p.SetState(3215)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IData_source_expressionContext is an interface to support dynamic dispatch.
type IData_source_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_source_expressionContext differentiates from other interfaces.
	IsData_source_expressionContext()
}

type Data_source_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_source_expressionContext() *Data_source_expressionContext {
	var p = new(Data_source_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_data_source_expression
	return p
}

func (*Data_source_expressionContext) IsData_source_expressionContext() {}

func NewData_source_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_source_expressionContext {
	var p = new(Data_source_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_data_source_expression

	return p
}

func (s *Data_source_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_source_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Data_source_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_source_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_source_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterData_source_expression(s)
	}
}

func (s *Data_source_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitData_source_expression(s)
	}
}

func (p *VerilogParser) Data_source_expression() (localctx IData_source_expressionContext) {
	localctx = NewData_source_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, VerilogParserRULE_data_source_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3217)
		p.Expression()
	}

	return localctx
}

// IEdge_identifierContext is an interface to support dynamic dispatch.
type IEdge_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEdge_identifierContext differentiates from other interfaces.
	IsEdge_identifierContext()
}

type Edge_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdge_identifierContext() *Edge_identifierContext {
	var p = new(Edge_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_edge_identifier
	return p
}

func (*Edge_identifierContext) IsEdge_identifierContext() {}

func NewEdge_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Edge_identifierContext {
	var p = new(Edge_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_edge_identifier

	return p
}

func (s *Edge_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Edge_identifierContext) K_posedge() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_posedge, 0)
}

func (s *Edge_identifierContext) K_negedge() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_negedge, 0)
}

func (s *Edge_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Edge_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Edge_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEdge_identifier(s)
	}
}

func (s *Edge_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEdge_identifier(s)
	}
}

func (p *VerilogParser) Edge_identifier() (localctx IEdge_identifierContext) {
	localctx = NewEdge_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, VerilogParserRULE_edge_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3219)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserK_negedge || _la == VerilogParserK_posedge) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IState_dependent_path_declarationContext is an interface to support dynamic dispatch.
type IState_dependent_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsState_dependent_path_declarationContext differentiates from other interfaces.
	IsState_dependent_path_declarationContext()
}

type State_dependent_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyState_dependent_path_declarationContext() *State_dependent_path_declarationContext {
	var p = new(State_dependent_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_state_dependent_path_declaration
	return p
}

func (*State_dependent_path_declarationContext) IsState_dependent_path_declarationContext() {}

func NewState_dependent_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *State_dependent_path_declarationContext {
	var p = new(State_dependent_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_state_dependent_path_declaration

	return p
}

func (s *State_dependent_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *State_dependent_path_declarationContext) K_if() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_if, 0)
}

func (s *State_dependent_path_declarationContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *State_dependent_path_declarationContext) Module_path_expression() IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *State_dependent_path_declarationContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *State_dependent_path_declarationContext) Simple_path_declaration() ISimple_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_path_declarationContext)
}

func (s *State_dependent_path_declarationContext) Edge_sensitive_path_declaration() IEdge_sensitive_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_sensitive_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_sensitive_path_declarationContext)
}

func (s *State_dependent_path_declarationContext) K_ifnone() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_ifnone, 0)
}

func (s *State_dependent_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *State_dependent_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *State_dependent_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterState_dependent_path_declaration(s)
	}
}

func (s *State_dependent_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitState_dependent_path_declaration(s)
	}
}

func (p *VerilogParser) State_dependent_path_declaration() (localctx IState_dependent_path_declarationContext) {
	localctx = NewState_dependent_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, VerilogParserRULE_state_dependent_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3235)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 339, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3221)
			p.Match(VerilogParserK_if)
		}
		{
			p.SetState(3222)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(3223)
			p.Module_path_expression()
		}
		{
			p.SetState(3224)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(3225)
			p.Simple_path_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3227)
			p.Match(VerilogParserK_if)
		}
		{
			p.SetState(3228)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(3229)
			p.Module_path_expression()
		}
		{
			p.SetState(3230)
			p.Match(VerilogParserRight_parenthes)
		}
		{
			p.SetState(3231)
			p.Edge_sensitive_path_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3233)
			p.Match(VerilogParserK_ifnone)
		}
		{
			p.SetState(3234)
			p.Simple_path_declaration()
		}

	}

	return localctx
}

// IPolarity_operatorContext is an interface to support dynamic dispatch.
type IPolarity_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPolarity_operatorContext differentiates from other interfaces.
	IsPolarity_operatorContext()
}

type Polarity_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPolarity_operatorContext() *Polarity_operatorContext {
	var p = new(Polarity_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_polarity_operator
	return p
}

func (*Polarity_operatorContext) IsPolarity_operatorContext() {}

func NewPolarity_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Polarity_operatorContext {
	var p = new(Polarity_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_polarity_operator

	return p
}

func (s *Polarity_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Polarity_operatorContext) Plus() antlr.TerminalNode {
	return s.GetToken(VerilogParserPlus, 0)
}

func (s *Polarity_operatorContext) Minus() antlr.TerminalNode {
	return s.GetToken(VerilogParserMinus, 0)
}

func (s *Polarity_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Polarity_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Polarity_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPolarity_operator(s)
	}
}

func (s *Polarity_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPolarity_operator(s)
	}
}

func (p *VerilogParser) Polarity_operator() (localctx IPolarity_operatorContext) {
	localctx = NewPolarity_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, VerilogParserRULE_polarity_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3237)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserPlus || _la == VerilogParserMinus) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISystem_timing_checkContext is an interface to support dynamic dispatch.
type ISystem_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_timing_checkContext differentiates from other interfaces.
	IsSystem_timing_checkContext()
}

type System_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_timing_checkContext() *System_timing_checkContext {
	var p = new(System_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_timing_check
	return p
}

func (*System_timing_checkContext) IsSystem_timing_checkContext() {}

func NewSystem_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_timing_checkContext {
	var p = new(System_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_timing_check

	return p
}

func (s *System_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *System_timing_checkContext) Setup_timing_check() ISetup_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetup_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetup_timing_checkContext)
}

func (s *System_timing_checkContext) Hold_timing_check() IHold_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHold_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHold_timing_checkContext)
}

func (s *System_timing_checkContext) Setuphold_timing_check() ISetuphold_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetuphold_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetuphold_timing_checkContext)
}

func (s *System_timing_checkContext) Recovery_timing_check() IRecovery_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecovery_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecovery_timing_checkContext)
}

func (s *System_timing_checkContext) Removal_timing_check() IRemoval_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemoval_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRemoval_timing_checkContext)
}

func (s *System_timing_checkContext) Recrem_timing_check() IRecrem_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecrem_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecrem_timing_checkContext)
}

func (s *System_timing_checkContext) Skew_timing_check() ISkew_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISkew_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISkew_timing_checkContext)
}

func (s *System_timing_checkContext) Timeskew_timing_check() ITimeskew_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeskew_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeskew_timing_checkContext)
}

func (s *System_timing_checkContext) Fullskew_timing_check() IFullskew_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullskew_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFullskew_timing_checkContext)
}

func (s *System_timing_checkContext) Period_timing_check() IPeriod_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPeriod_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPeriod_timing_checkContext)
}

func (s *System_timing_checkContext) Width_timing_check() IWidth_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWidth_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWidth_timing_checkContext)
}

func (s *System_timing_checkContext) Nochange_timing_check() INochange_timing_checkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INochange_timing_checkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INochange_timing_checkContext)
}

func (s *System_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSystem_timing_check(s)
	}
}

func (s *System_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSystem_timing_check(s)
	}
}

func (p *VerilogParser) System_timing_check() (localctx ISystem_timing_checkContext) {
	localctx = NewSystem_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, VerilogParserRULE_system_timing_check)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3251)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_setup:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3239)
			p.Setup_timing_check()
		}

	case VerilogParserK_hold:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3240)
			p.Hold_timing_check()
		}

	case VerilogParserK_setuphold:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3241)
			p.Setuphold_timing_check()
		}

	case VerilogParserK_recovery:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3242)
			p.Recovery_timing_check()
		}

	case VerilogParserK_removal:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3243)
			p.Removal_timing_check()
		}

	case VerilogParserK_recrem:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3244)
			p.Recrem_timing_check()
		}

	case VerilogParserK_skew:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3245)
			p.Skew_timing_check()
		}

	case VerilogParserK_timeskew:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3246)
			p.Timeskew_timing_check()
		}

	case VerilogParserK_fullskew:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3247)
			p.Fullskew_timing_check()
		}

	case VerilogParserK_period:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3248)
			p.Period_timing_check()
		}

	case VerilogParserK_width:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3249)
			p.Width_timing_check()
		}

	case VerilogParserK_nochange:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3250)
			p.Nochange_timing_check()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISetup_timing_checkContext is an interface to support dynamic dispatch.
type ISetup_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetup_timing_checkContext differentiates from other interfaces.
	IsSetup_timing_checkContext()
}

type Setup_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetup_timing_checkContext() *Setup_timing_checkContext {
	var p = new(Setup_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_setup_timing_check
	return p
}

func (*Setup_timing_checkContext) IsSetup_timing_checkContext() {}

func NewSetup_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Setup_timing_checkContext {
	var p = new(Setup_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_setup_timing_check

	return p
}

func (s *Setup_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Setup_timing_checkContext) K_setup() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_setup, 0)
}

func (s *Setup_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Setup_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Setup_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Setup_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Setup_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Setup_timing_checkContext) Timing_check_limit() ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Setup_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Setup_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Setup_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Setup_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Setup_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Setup_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSetup_timing_check(s)
	}
}

func (s *Setup_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSetup_timing_check(s)
	}
}

func (p *VerilogParser) Setup_timing_check() (localctx ISetup_timing_checkContext) {
	localctx = NewSetup_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, VerilogParserRULE_setup_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3253)
		p.Match(VerilogParserK_setup)
	}
	{
		p.SetState(3254)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3255)
		p.Data_event()
	}
	{
		p.SetState(3256)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3257)
		p.Reference_event()
	}
	{
		p.SetState(3258)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3259)
		p.Timing_check_limit()
	}
	p.SetState(3264)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3260)
			p.Match(VerilogParserComma)
		}
		p.SetState(3262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3261)
				p.Notify_reg()
			}

		}

	}
	{
		p.SetState(3266)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3267)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IHold_timing_checkContext is an interface to support dynamic dispatch.
type IHold_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHold_timing_checkContext differentiates from other interfaces.
	IsHold_timing_checkContext()
}

type Hold_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHold_timing_checkContext() *Hold_timing_checkContext {
	var p = new(Hold_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hold_timing_check
	return p
}

func (*Hold_timing_checkContext) IsHold_timing_checkContext() {}

func NewHold_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hold_timing_checkContext {
	var p = new(Hold_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hold_timing_check

	return p
}

func (s *Hold_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Hold_timing_checkContext) K_hold() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_hold, 0)
}

func (s *Hold_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Hold_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Hold_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Hold_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Hold_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Hold_timing_checkContext) Timing_check_limit() ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Hold_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Hold_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Hold_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Hold_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hold_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hold_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHold_timing_check(s)
	}
}

func (s *Hold_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHold_timing_check(s)
	}
}

func (p *VerilogParser) Hold_timing_check() (localctx IHold_timing_checkContext) {
	localctx = NewHold_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, VerilogParserRULE_hold_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3269)
		p.Match(VerilogParserK_hold)
	}
	{
		p.SetState(3270)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3271)
		p.Reference_event()
	}
	{
		p.SetState(3272)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3273)
		p.Data_event()
	}
	{
		p.SetState(3274)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3275)
		p.Timing_check_limit()
	}
	p.SetState(3280)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3276)
			p.Match(VerilogParserComma)
		}
		p.SetState(3278)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3277)
				p.Notify_reg()
			}

		}

	}
	{
		p.SetState(3282)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3283)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// ISetuphold_timing_checkContext is an interface to support dynamic dispatch.
type ISetuphold_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetuphold_timing_checkContext differentiates from other interfaces.
	IsSetuphold_timing_checkContext()
}

type Setuphold_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetuphold_timing_checkContext() *Setuphold_timing_checkContext {
	var p = new(Setuphold_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_setuphold_timing_check
	return p
}

func (*Setuphold_timing_checkContext) IsSetuphold_timing_checkContext() {}

func NewSetuphold_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Setuphold_timing_checkContext {
	var p = new(Setuphold_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_setuphold_timing_check

	return p
}

func (s *Setuphold_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Setuphold_timing_checkContext) K_setuphold() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_setuphold, 0)
}

func (s *Setuphold_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Setuphold_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Setuphold_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Setuphold_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Setuphold_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Setuphold_timing_checkContext) AllTiming_check_limit() []ITiming_check_limitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem())
	var tst = make([]ITiming_check_limitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITiming_check_limitContext)
		}
	}

	return tst
}

func (s *Setuphold_timing_checkContext) Timing_check_limit(i int) ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Setuphold_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Setuphold_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Setuphold_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Setuphold_timing_checkContext) Stamptime_condition() IStamptime_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStamptime_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStamptime_conditionContext)
}

func (s *Setuphold_timing_checkContext) Checktime_condition() IChecktime_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecktime_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecktime_conditionContext)
}

func (s *Setuphold_timing_checkContext) Delayed_reference() IDelayed_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayed_referenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayed_referenceContext)
}

func (s *Setuphold_timing_checkContext) Delayed_data() IDelayed_dataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayed_dataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayed_dataContext)
}

func (s *Setuphold_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Setuphold_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Setuphold_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSetuphold_timing_check(s)
	}
}

func (s *Setuphold_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSetuphold_timing_check(s)
	}
}

func (p *VerilogParser) Setuphold_timing_check() (localctx ISetuphold_timing_checkContext) {
	localctx = NewSetuphold_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, VerilogParserRULE_setuphold_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3285)
		p.Match(VerilogParserK_setuphold)
	}
	{
		p.SetState(3286)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3287)
		p.Reference_event()
	}
	{
		p.SetState(3288)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3289)
		p.Data_event()
	}
	{
		p.SetState(3290)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3291)
		p.Timing_check_limit()
	}
	{
		p.SetState(3292)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3293)
		p.Timing_check_limit()
	}
	p.SetState(3322)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3294)
			p.Match(VerilogParserComma)
		}
		p.SetState(3296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3295)
				p.Notify_reg()
			}

		}
		p.SetState(3320)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserComma {
			{
				p.SetState(3298)
				p.Match(VerilogParserComma)
			}
			p.SetState(3300)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
				{
					p.SetState(3299)
					p.Stamptime_condition()
				}

			}
			p.SetState(3318)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserComma {
				{
					p.SetState(3302)
					p.Match(VerilogParserComma)
				}
				p.SetState(3304)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
					{
						p.SetState(3303)
						p.Checktime_condition()
					}

				}
				p.SetState(3316)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == VerilogParserComma {
					{
						p.SetState(3306)
						p.Match(VerilogParserComma)
					}
					p.SetState(3308)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
						{
							p.SetState(3307)
							p.Delayed_reference()
						}

					}
					p.SetState(3314)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == VerilogParserComma {
						{
							p.SetState(3310)
							p.Match(VerilogParserComma)
						}
						p.SetState(3312)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)

						if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
							{
								p.SetState(3311)
								p.Delayed_data()
							}

						}

					}

				}

			}

		}

	}
	{
		p.SetState(3324)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3325)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IRecovery_timing_checkContext is an interface to support dynamic dispatch.
type IRecovery_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecovery_timing_checkContext differentiates from other interfaces.
	IsRecovery_timing_checkContext()
}

type Recovery_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecovery_timing_checkContext() *Recovery_timing_checkContext {
	var p = new(Recovery_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_recovery_timing_check
	return p
}

func (*Recovery_timing_checkContext) IsRecovery_timing_checkContext() {}

func NewRecovery_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Recovery_timing_checkContext {
	var p = new(Recovery_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_recovery_timing_check

	return p
}

func (s *Recovery_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Recovery_timing_checkContext) K_recovery() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_recovery, 0)
}

func (s *Recovery_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Recovery_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Recovery_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Recovery_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Recovery_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Recovery_timing_checkContext) Timing_check_limit() ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Recovery_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Recovery_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Recovery_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Recovery_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Recovery_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Recovery_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRecovery_timing_check(s)
	}
}

func (s *Recovery_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRecovery_timing_check(s)
	}
}

func (p *VerilogParser) Recovery_timing_check() (localctx IRecovery_timing_checkContext) {
	localctx = NewRecovery_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, VerilogParserRULE_recovery_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3327)
		p.Match(VerilogParserK_recovery)
	}
	{
		p.SetState(3328)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3329)
		p.Reference_event()
	}
	{
		p.SetState(3330)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3331)
		p.Data_event()
	}
	{
		p.SetState(3332)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3333)
		p.Timing_check_limit()
	}
	p.SetState(3338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3334)
			p.Match(VerilogParserComma)
		}
		p.SetState(3336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3335)
				p.Notify_reg()
			}

		}

	}
	{
		p.SetState(3340)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3341)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IRemoval_timing_checkContext is an interface to support dynamic dispatch.
type IRemoval_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemoval_timing_checkContext differentiates from other interfaces.
	IsRemoval_timing_checkContext()
}

type Removal_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoval_timing_checkContext() *Removal_timing_checkContext {
	var p = new(Removal_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_removal_timing_check
	return p
}

func (*Removal_timing_checkContext) IsRemoval_timing_checkContext() {}

func NewRemoval_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Removal_timing_checkContext {
	var p = new(Removal_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_removal_timing_check

	return p
}

func (s *Removal_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Removal_timing_checkContext) K_removal() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_removal, 0)
}

func (s *Removal_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Removal_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Removal_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Removal_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Removal_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Removal_timing_checkContext) Timing_check_limit() ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Removal_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Removal_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Removal_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Removal_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Removal_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Removal_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRemoval_timing_check(s)
	}
}

func (s *Removal_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRemoval_timing_check(s)
	}
}

func (p *VerilogParser) Removal_timing_check() (localctx IRemoval_timing_checkContext) {
	localctx = NewRemoval_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, VerilogParserRULE_removal_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3343)
		p.Match(VerilogParserK_removal)
	}
	{
		p.SetState(3344)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3345)
		p.Reference_event()
	}
	{
		p.SetState(3346)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3347)
		p.Data_event()
	}
	{
		p.SetState(3348)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3349)
		p.Timing_check_limit()
	}
	p.SetState(3354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3350)
			p.Match(VerilogParserComma)
		}
		p.SetState(3352)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3351)
				p.Notify_reg()
			}

		}

	}
	{
		p.SetState(3356)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3357)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IRecrem_timing_checkContext is an interface to support dynamic dispatch.
type IRecrem_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecrem_timing_checkContext differentiates from other interfaces.
	IsRecrem_timing_checkContext()
}

type Recrem_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecrem_timing_checkContext() *Recrem_timing_checkContext {
	var p = new(Recrem_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_recrem_timing_check
	return p
}

func (*Recrem_timing_checkContext) IsRecrem_timing_checkContext() {}

func NewRecrem_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Recrem_timing_checkContext {
	var p = new(Recrem_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_recrem_timing_check

	return p
}

func (s *Recrem_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Recrem_timing_checkContext) K_recrem() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_recrem, 0)
}

func (s *Recrem_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Recrem_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Recrem_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Recrem_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Recrem_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Recrem_timing_checkContext) AllTiming_check_limit() []ITiming_check_limitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem())
	var tst = make([]ITiming_check_limitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITiming_check_limitContext)
		}
	}

	return tst
}

func (s *Recrem_timing_checkContext) Timing_check_limit(i int) ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Recrem_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Recrem_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Recrem_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Recrem_timing_checkContext) Stamptime_condition() IStamptime_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStamptime_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStamptime_conditionContext)
}

func (s *Recrem_timing_checkContext) Checktime_condition() IChecktime_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecktime_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecktime_conditionContext)
}

func (s *Recrem_timing_checkContext) Delayed_reference() IDelayed_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayed_referenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayed_referenceContext)
}

func (s *Recrem_timing_checkContext) Delayed_data() IDelayed_dataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelayed_dataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelayed_dataContext)
}

func (s *Recrem_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Recrem_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Recrem_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRecrem_timing_check(s)
	}
}

func (s *Recrem_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRecrem_timing_check(s)
	}
}

func (p *VerilogParser) Recrem_timing_check() (localctx IRecrem_timing_checkContext) {
	localctx = NewRecrem_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, VerilogParserRULE_recrem_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3359)
		p.Match(VerilogParserK_recrem)
	}
	{
		p.SetState(3360)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3361)
		p.Reference_event()
	}
	{
		p.SetState(3362)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3363)
		p.Data_event()
	}
	{
		p.SetState(3364)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3365)
		p.Timing_check_limit()
	}
	{
		p.SetState(3366)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3367)
		p.Timing_check_limit()
	}
	p.SetState(3396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3368)
			p.Match(VerilogParserComma)
		}
		p.SetState(3370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3369)
				p.Notify_reg()
			}

		}
		p.SetState(3394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserComma {
			{
				p.SetState(3372)
				p.Match(VerilogParserComma)
			}
			p.SetState(3374)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
				{
					p.SetState(3373)
					p.Stamptime_condition()
				}

			}
			p.SetState(3392)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserComma {
				{
					p.SetState(3376)
					p.Match(VerilogParserComma)
				}
				p.SetState(3378)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
					{
						p.SetState(3377)
						p.Checktime_condition()
					}

				}
				p.SetState(3390)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == VerilogParserComma {
					{
						p.SetState(3380)
						p.Match(VerilogParserComma)
					}
					p.SetState(3382)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
						{
							p.SetState(3381)
							p.Delayed_reference()
						}

					}
					p.SetState(3388)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == VerilogParserComma {
						{
							p.SetState(3384)
							p.Match(VerilogParserComma)
						}
						p.SetState(3386)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)

						if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
							{
								p.SetState(3385)
								p.Delayed_data()
							}

						}

					}

				}

			}

		}

	}
	{
		p.SetState(3398)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3399)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// ISkew_timing_checkContext is an interface to support dynamic dispatch.
type ISkew_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSkew_timing_checkContext differentiates from other interfaces.
	IsSkew_timing_checkContext()
}

type Skew_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkew_timing_checkContext() *Skew_timing_checkContext {
	var p = new(Skew_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_skew_timing_check
	return p
}

func (*Skew_timing_checkContext) IsSkew_timing_checkContext() {}

func NewSkew_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Skew_timing_checkContext {
	var p = new(Skew_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_skew_timing_check

	return p
}

func (s *Skew_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Skew_timing_checkContext) K_skew() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_skew, 0)
}

func (s *Skew_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Skew_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Skew_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Skew_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Skew_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Skew_timing_checkContext) Timing_check_limit() ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Skew_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Skew_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Skew_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Skew_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Skew_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Skew_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSkew_timing_check(s)
	}
}

func (s *Skew_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSkew_timing_check(s)
	}
}

func (p *VerilogParser) Skew_timing_check() (localctx ISkew_timing_checkContext) {
	localctx = NewSkew_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, VerilogParserRULE_skew_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3401)
		p.Match(VerilogParserK_skew)
	}
	{
		p.SetState(3402)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3403)
		p.Reference_event()
	}
	{
		p.SetState(3404)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3405)
		p.Data_event()
	}
	{
		p.SetState(3406)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3407)
		p.Timing_check_limit()
	}
	p.SetState(3412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3408)
			p.Match(VerilogParserComma)
		}
		p.SetState(3410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3409)
				p.Notify_reg()
			}

		}

	}
	{
		p.SetState(3414)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3415)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// ITimeskew_timing_checkContext is an interface to support dynamic dispatch.
type ITimeskew_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeskew_timing_checkContext differentiates from other interfaces.
	IsTimeskew_timing_checkContext()
}

type Timeskew_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeskew_timing_checkContext() *Timeskew_timing_checkContext {
	var p = new(Timeskew_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_timeskew_timing_check
	return p
}

func (*Timeskew_timing_checkContext) IsTimeskew_timing_checkContext() {}

func NewTimeskew_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timeskew_timing_checkContext {
	var p = new(Timeskew_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_timeskew_timing_check

	return p
}

func (s *Timeskew_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Timeskew_timing_checkContext) K_timeskew() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_timeskew, 0)
}

func (s *Timeskew_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Timeskew_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Timeskew_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Timeskew_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Timeskew_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Timeskew_timing_checkContext) Timing_check_limit() ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Timeskew_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Timeskew_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Timeskew_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Timeskew_timing_checkContext) Event_based_flag() IEvent_based_flagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_based_flagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_based_flagContext)
}

func (s *Timeskew_timing_checkContext) Remain_active_flag() IRemain_active_flagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemain_active_flagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRemain_active_flagContext)
}

func (s *Timeskew_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timeskew_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timeskew_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTimeskew_timing_check(s)
	}
}

func (s *Timeskew_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTimeskew_timing_check(s)
	}
}

func (p *VerilogParser) Timeskew_timing_check() (localctx ITimeskew_timing_checkContext) {
	localctx = NewTimeskew_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, VerilogParserRULE_timeskew_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3417)
		p.Match(VerilogParserK_timeskew)
	}
	{
		p.SetState(3418)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3419)
		p.Reference_event()
	}
	{
		p.SetState(3420)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3421)
		p.Data_event()
	}
	{
		p.SetState(3422)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3423)
		p.Timing_check_limit()
	}
	p.SetState(3440)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3424)
			p.Match(VerilogParserComma)
		}
		p.SetState(3426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3425)
				p.Notify_reg()
			}

		}
		p.SetState(3438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserComma {
			{
				p.SetState(3428)
				p.Match(VerilogParserComma)
			}
			p.SetState(3430)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
				{
					p.SetState(3429)
					p.Event_based_flag()
				}

			}
			p.SetState(3436)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserComma {
				{
					p.SetState(3432)
					p.Match(VerilogParserComma)
				}
				p.SetState(3434)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
					{
						p.SetState(3433)
						p.Remain_active_flag()
					}

				}

			}

		}

	}
	{
		p.SetState(3442)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3443)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IFullskew_timing_checkContext is an interface to support dynamic dispatch.
type IFullskew_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullskew_timing_checkContext differentiates from other interfaces.
	IsFullskew_timing_checkContext()
}

type Fullskew_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullskew_timing_checkContext() *Fullskew_timing_checkContext {
	var p = new(Fullskew_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_fullskew_timing_check
	return p
}

func (*Fullskew_timing_checkContext) IsFullskew_timing_checkContext() {}

func NewFullskew_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullskew_timing_checkContext {
	var p = new(Fullskew_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_fullskew_timing_check

	return p
}

func (s *Fullskew_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullskew_timing_checkContext) K_fullskew() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_fullskew, 0)
}

func (s *Fullskew_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Fullskew_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Fullskew_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Fullskew_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Fullskew_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Fullskew_timing_checkContext) AllTiming_check_limit() []ITiming_check_limitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem())
	var tst = make([]ITiming_check_limitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITiming_check_limitContext)
		}
	}

	return tst
}

func (s *Fullskew_timing_checkContext) Timing_check_limit(i int) ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Fullskew_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Fullskew_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Fullskew_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Fullskew_timing_checkContext) Event_based_flag() IEvent_based_flagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_based_flagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_based_flagContext)
}

func (s *Fullskew_timing_checkContext) Remain_active_flag() IRemain_active_flagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemain_active_flagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRemain_active_flagContext)
}

func (s *Fullskew_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullskew_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fullskew_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFullskew_timing_check(s)
	}
}

func (s *Fullskew_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFullskew_timing_check(s)
	}
}

func (p *VerilogParser) Fullskew_timing_check() (localctx IFullskew_timing_checkContext) {
	localctx = NewFullskew_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, VerilogParserRULE_fullskew_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3445)
		p.Match(VerilogParserK_fullskew)
	}
	{
		p.SetState(3446)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3447)
		p.Reference_event()
	}
	{
		p.SetState(3448)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3449)
		p.Data_event()
	}
	{
		p.SetState(3450)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3451)
		p.Timing_check_limit()
	}
	{
		p.SetState(3452)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3453)
		p.Timing_check_limit()
	}
	p.SetState(3470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3454)
			p.Match(VerilogParserComma)
		}
		p.SetState(3456)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3455)
				p.Notify_reg()
			}

		}
		p.SetState(3468)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserComma {
			{
				p.SetState(3458)
				p.Match(VerilogParserComma)
			}
			p.SetState(3460)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
				{
					p.SetState(3459)
					p.Event_based_flag()
				}

			}
			p.SetState(3466)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == VerilogParserComma {
				{
					p.SetState(3462)
					p.Match(VerilogParserComma)
				}
				p.SetState(3464)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
					{
						p.SetState(3463)
						p.Remain_active_flag()
					}

				}

			}

		}

	}
	{
		p.SetState(3472)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3473)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IPeriod_timing_checkContext is an interface to support dynamic dispatch.
type IPeriod_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPeriod_timing_checkContext differentiates from other interfaces.
	IsPeriod_timing_checkContext()
}

type Period_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeriod_timing_checkContext() *Period_timing_checkContext {
	var p = new(Period_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_period_timing_check
	return p
}

func (*Period_timing_checkContext) IsPeriod_timing_checkContext() {}

func NewPeriod_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Period_timing_checkContext {
	var p = new(Period_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_period_timing_check

	return p
}

func (s *Period_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Period_timing_checkContext) K_period() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_period, 0)
}

func (s *Period_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Period_timing_checkContext) Controlled_reference_event() IControlled_reference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlled_reference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlled_reference_eventContext)
}

func (s *Period_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Period_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Period_timing_checkContext) Timing_check_limit() ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Period_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Period_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Period_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Period_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Period_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Period_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPeriod_timing_check(s)
	}
}

func (s *Period_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPeriod_timing_check(s)
	}
}

func (p *VerilogParser) Period_timing_check() (localctx IPeriod_timing_checkContext) {
	localctx = NewPeriod_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, VerilogParserRULE_period_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3475)
		p.Match(VerilogParserK_period)
	}
	{
		p.SetState(3476)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3477)
		p.Controlled_reference_event()
	}
	{
		p.SetState(3478)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3479)
		p.Timing_check_limit()
	}
	p.SetState(3484)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3480)
			p.Match(VerilogParserComma)
		}
		p.SetState(3482)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3481)
				p.Notify_reg()
			}

		}

	}
	{
		p.SetState(3486)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3487)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IWidth_timing_checkContext is an interface to support dynamic dispatch.
type IWidth_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWidth_timing_checkContext differentiates from other interfaces.
	IsWidth_timing_checkContext()
}

type Width_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWidth_timing_checkContext() *Width_timing_checkContext {
	var p = new(Width_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_width_timing_check
	return p
}

func (*Width_timing_checkContext) IsWidth_timing_checkContext() {}

func NewWidth_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Width_timing_checkContext {
	var p = new(Width_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_width_timing_check

	return p
}

func (s *Width_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Width_timing_checkContext) K_width() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_width, 0)
}

func (s *Width_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Width_timing_checkContext) Controlled_reference_event() IControlled_reference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlled_reference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlled_reference_eventContext)
}

func (s *Width_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Width_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Width_timing_checkContext) Timing_check_limit() ITiming_check_limitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_limitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_limitContext)
}

func (s *Width_timing_checkContext) Threshold() IThresholdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThresholdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThresholdContext)
}

func (s *Width_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Width_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Width_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Width_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Width_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Width_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterWidth_timing_check(s)
	}
}

func (s *Width_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitWidth_timing_check(s)
	}
}

func (p *VerilogParser) Width_timing_check() (localctx IWidth_timing_checkContext) {
	localctx = NewWidth_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, VerilogParserRULE_width_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3489)
		p.Match(VerilogParserK_width)
	}
	{
		p.SetState(3490)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3491)
		p.Controlled_reference_event()
	}
	{
		p.SetState(3492)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3493)
		p.Timing_check_limit()
	}
	{
		p.SetState(3494)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3495)
		p.Threshold()
	}
	p.SetState(3500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3496)
			p.Match(VerilogParserComma)
		}
		p.SetState(3498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3497)
				p.Notify_reg()
			}

		}

	}
	{
		p.SetState(3502)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3503)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// INochange_timing_checkContext is an interface to support dynamic dispatch.
type INochange_timing_checkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNochange_timing_checkContext differentiates from other interfaces.
	IsNochange_timing_checkContext()
}

type Nochange_timing_checkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNochange_timing_checkContext() *Nochange_timing_checkContext {
	var p = new(Nochange_timing_checkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_nochange_timing_check
	return p
}

func (*Nochange_timing_checkContext) IsNochange_timing_checkContext() {}

func NewNochange_timing_checkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nochange_timing_checkContext {
	var p = new(Nochange_timing_checkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_nochange_timing_check

	return p
}

func (s *Nochange_timing_checkContext) GetParser() antlr.Parser { return s.parser }

func (s *Nochange_timing_checkContext) K_nochange() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_nochange, 0)
}

func (s *Nochange_timing_checkContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Nochange_timing_checkContext) Reference_event() IReference_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReference_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReference_eventContext)
}

func (s *Nochange_timing_checkContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Nochange_timing_checkContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Nochange_timing_checkContext) Data_event() IData_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_eventContext)
}

func (s *Nochange_timing_checkContext) Start_edge_offset() IStart_edge_offsetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStart_edge_offsetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStart_edge_offsetContext)
}

func (s *Nochange_timing_checkContext) End_edge_offset() IEnd_edge_offsetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnd_edge_offsetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnd_edge_offsetContext)
}

func (s *Nochange_timing_checkContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Nochange_timing_checkContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(VerilogParserSemicolon, 0)
}

func (s *Nochange_timing_checkContext) Notify_reg() INotify_regContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotify_regContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotify_regContext)
}

func (s *Nochange_timing_checkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nochange_timing_checkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nochange_timing_checkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNochange_timing_check(s)
	}
}

func (s *Nochange_timing_checkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNochange_timing_check(s)
	}
}

func (p *VerilogParser) Nochange_timing_check() (localctx INochange_timing_checkContext) {
	localctx = NewNochange_timing_checkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, VerilogParserRULE_nochange_timing_check)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3505)
		p.Match(VerilogParserK_nochange)
	}
	{
		p.SetState(3506)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(3507)
		p.Reference_event()
	}
	{
		p.SetState(3508)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3509)
		p.Data_event()
	}
	{
		p.SetState(3510)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3511)
		p.Start_edge_offset()
	}
	{
		p.SetState(3512)
		p.Match(VerilogParserComma)
	}
	{
		p.SetState(3513)
		p.End_edge_offset()
	}
	p.SetState(3518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3514)
			p.Match(VerilogParserComma)
		}
		p.SetState(3516)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier {
			{
				p.SetState(3515)
				p.Notify_reg()
			}

		}

	}
	{
		p.SetState(3520)
		p.Match(VerilogParserRight_parenthes)
	}
	{
		p.SetState(3521)
		p.Match(VerilogParserSemicolon)
	}

	return localctx
}

// IChecktime_conditionContext is an interface to support dynamic dispatch.
type IChecktime_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecktime_conditionContext differentiates from other interfaces.
	IsChecktime_conditionContext()
}

type Checktime_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecktime_conditionContext() *Checktime_conditionContext {
	var p = new(Checktime_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_checktime_condition
	return p
}

func (*Checktime_conditionContext) IsChecktime_conditionContext() {}

func NewChecktime_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checktime_conditionContext {
	var p = new(Checktime_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_checktime_condition

	return p
}

func (s *Checktime_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Checktime_conditionContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Checktime_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checktime_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checktime_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterChecktime_condition(s)
	}
}

func (s *Checktime_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitChecktime_condition(s)
	}
}

func (p *VerilogParser) Checktime_condition() (localctx IChecktime_conditionContext) {
	localctx = NewChecktime_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, VerilogParserRULE_checktime_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3523)
		p.Mintypmax_expression()
	}

	return localctx
}

// IControlled_reference_eventContext is an interface to support dynamic dispatch.
type IControlled_reference_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsControlled_reference_eventContext differentiates from other interfaces.
	IsControlled_reference_eventContext()
}

type Controlled_reference_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControlled_reference_eventContext() *Controlled_reference_eventContext {
	var p = new(Controlled_reference_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_controlled_reference_event
	return p
}

func (*Controlled_reference_eventContext) IsControlled_reference_eventContext() {}

func NewControlled_reference_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Controlled_reference_eventContext {
	var p = new(Controlled_reference_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_controlled_reference_event

	return p
}

func (s *Controlled_reference_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Controlled_reference_eventContext) Controlled_timing_check_event() IControlled_timing_check_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IControlled_timing_check_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IControlled_timing_check_eventContext)
}

func (s *Controlled_reference_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Controlled_reference_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Controlled_reference_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterControlled_reference_event(s)
	}
}

func (s *Controlled_reference_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitControlled_reference_event(s)
	}
}

func (p *VerilogParser) Controlled_reference_event() (localctx IControlled_reference_eventContext) {
	localctx = NewControlled_reference_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, VerilogParserRULE_controlled_reference_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3525)
		p.Controlled_timing_check_event()
	}

	return localctx
}

// IData_eventContext is an interface to support dynamic dispatch.
type IData_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_eventContext differentiates from other interfaces.
	IsData_eventContext()
}

type Data_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_eventContext() *Data_eventContext {
	var p = new(Data_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_data_event
	return p
}

func (*Data_eventContext) IsData_eventContext() {}

func NewData_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_eventContext {
	var p = new(Data_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_data_event

	return p
}

func (s *Data_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_eventContext) Timing_check_event() ITiming_check_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_eventContext)
}

func (s *Data_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterData_event(s)
	}
}

func (s *Data_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitData_event(s)
	}
}

func (p *VerilogParser) Data_event() (localctx IData_eventContext) {
	localctx = NewData_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, VerilogParserRULE_data_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3527)
		p.Timing_check_event()
	}

	return localctx
}

// IDelayed_dataContext is an interface to support dynamic dispatch.
type IDelayed_dataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelayed_dataContext differentiates from other interfaces.
	IsDelayed_dataContext()
}

type Delayed_dataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelayed_dataContext() *Delayed_dataContext {
	var p = new(Delayed_dataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delayed_data
	return p
}

func (*Delayed_dataContext) IsDelayed_dataContext() {}

func NewDelayed_dataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delayed_dataContext {
	var p = new(Delayed_dataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delayed_data

	return p
}

func (s *Delayed_dataContext) GetParser() antlr.Parser { return s.parser }

func (s *Delayed_dataContext) Terminal_identifier() ITerminal_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_identifierContext)
}

func (s *Delayed_dataContext) Left_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, 0)
}

func (s *Delayed_dataContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Delayed_dataContext) Right_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, 0)
}

func (s *Delayed_dataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delayed_dataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delayed_dataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelayed_data(s)
	}
}

func (s *Delayed_dataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelayed_data(s)
	}
}

func (p *VerilogParser) Delayed_data() (localctx IDelayed_dataContext) {
	localctx = NewDelayed_dataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, VerilogParserRULE_delayed_data)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3535)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 389, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3529)
			p.Terminal_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3530)
			p.Terminal_identifier()
		}
		{
			p.SetState(3531)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3532)
			p.Constant_mintypmax_expression()
		}
		{
			p.SetState(3533)
			p.Match(VerilogParserRight_bracket)
		}

	}

	return localctx
}

// IDelayed_referenceContext is an interface to support dynamic dispatch.
type IDelayed_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelayed_referenceContext differentiates from other interfaces.
	IsDelayed_referenceContext()
}

type Delayed_referenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelayed_referenceContext() *Delayed_referenceContext {
	var p = new(Delayed_referenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_delayed_reference
	return p
}

func (*Delayed_referenceContext) IsDelayed_referenceContext() {}

func NewDelayed_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delayed_referenceContext {
	var p = new(Delayed_referenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_delayed_reference

	return p
}

func (s *Delayed_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Delayed_referenceContext) Terminal_identifier() ITerminal_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_identifierContext)
}

func (s *Delayed_referenceContext) Left_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, 0)
}

func (s *Delayed_referenceContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Delayed_referenceContext) Right_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, 0)
}

func (s *Delayed_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delayed_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delayed_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDelayed_reference(s)
	}
}

func (s *Delayed_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDelayed_reference(s)
	}
}

func (p *VerilogParser) Delayed_reference() (localctx IDelayed_referenceContext) {
	localctx = NewDelayed_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, VerilogParserRULE_delayed_reference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3543)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 390, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3537)
			p.Terminal_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3538)
			p.Terminal_identifier()
		}
		{
			p.SetState(3539)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3540)
			p.Constant_mintypmax_expression()
		}
		{
			p.SetState(3541)
			p.Match(VerilogParserRight_bracket)
		}

	}

	return localctx
}

// IEnd_edge_offsetContext is an interface to support dynamic dispatch.
type IEnd_edge_offsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnd_edge_offsetContext differentiates from other interfaces.
	IsEnd_edge_offsetContext()
}

type End_edge_offsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnd_edge_offsetContext() *End_edge_offsetContext {
	var p = new(End_edge_offsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_end_edge_offset
	return p
}

func (*End_edge_offsetContext) IsEnd_edge_offsetContext() {}

func NewEnd_edge_offsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *End_edge_offsetContext {
	var p = new(End_edge_offsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_end_edge_offset

	return p
}

func (s *End_edge_offsetContext) GetParser() antlr.Parser { return s.parser }

func (s *End_edge_offsetContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *End_edge_offsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *End_edge_offsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *End_edge_offsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEnd_edge_offset(s)
	}
}

func (s *End_edge_offsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEnd_edge_offset(s)
	}
}

func (p *VerilogParser) End_edge_offset() (localctx IEnd_edge_offsetContext) {
	localctx = NewEnd_edge_offsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, VerilogParserRULE_end_edge_offset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3545)
		p.Mintypmax_expression()
	}

	return localctx
}

// IEvent_based_flagContext is an interface to support dynamic dispatch.
type IEvent_based_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_based_flagContext differentiates from other interfaces.
	IsEvent_based_flagContext()
}

type Event_based_flagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_based_flagContext() *Event_based_flagContext {
	var p = new(Event_based_flagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_based_flag
	return p
}

func (*Event_based_flagContext) IsEvent_based_flagContext() {}

func NewEvent_based_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_based_flagContext {
	var p = new(Event_based_flagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_based_flag

	return p
}

func (s *Event_based_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_based_flagContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Event_based_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_based_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_based_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_based_flag(s)
	}
}

func (s *Event_based_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_based_flag(s)
	}
}

func (p *VerilogParser) Event_based_flag() (localctx IEvent_based_flagContext) {
	localctx = NewEvent_based_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, VerilogParserRULE_event_based_flag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3547)
		p.Constant_expression()
	}

	return localctx
}

// INotify_regContext is an interface to support dynamic dispatch.
type INotify_regContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotify_regContext differentiates from other interfaces.
	IsNotify_regContext()
}

type Notify_regContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotify_regContext() *Notify_regContext {
	var p = new(Notify_regContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_notify_reg
	return p
}

func (*Notify_regContext) IsNotify_regContext() {}

func NewNotify_regContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Notify_regContext {
	var p = new(Notify_regContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_notify_reg

	return p
}

func (s *Notify_regContext) GetParser() antlr.Parser { return s.parser }

func (s *Notify_regContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Notify_regContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Notify_regContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Notify_regContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNotify_reg(s)
	}
}

func (s *Notify_regContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNotify_reg(s)
	}
}

func (p *VerilogParser) Notify_reg() (localctx INotify_regContext) {
	localctx = NewNotify_regContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, VerilogParserRULE_notify_reg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3549)
		p.Variable_identifier()
	}

	return localctx
}

// IReference_eventContext is an interface to support dynamic dispatch.
type IReference_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReference_eventContext differentiates from other interfaces.
	IsReference_eventContext()
}

type Reference_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReference_eventContext() *Reference_eventContext {
	var p = new(Reference_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_reference_event
	return p
}

func (*Reference_eventContext) IsReference_eventContext() {}

func NewReference_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reference_eventContext {
	var p = new(Reference_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_reference_event

	return p
}

func (s *Reference_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Reference_eventContext) Timing_check_event() ITiming_check_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_eventContext)
}

func (s *Reference_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reference_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reference_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReference_event(s)
	}
}

func (s *Reference_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReference_event(s)
	}
}

func (p *VerilogParser) Reference_event() (localctx IReference_eventContext) {
	localctx = NewReference_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, VerilogParserRULE_reference_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3551)
		p.Timing_check_event()
	}

	return localctx
}

// IRemain_active_flagContext is an interface to support dynamic dispatch.
type IRemain_active_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemain_active_flagContext differentiates from other interfaces.
	IsRemain_active_flagContext()
}

type Remain_active_flagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemain_active_flagContext() *Remain_active_flagContext {
	var p = new(Remain_active_flagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_remain_active_flag
	return p
}

func (*Remain_active_flagContext) IsRemain_active_flagContext() {}

func NewRemain_active_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Remain_active_flagContext {
	var p = new(Remain_active_flagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_remain_active_flag

	return p
}

func (s *Remain_active_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Remain_active_flagContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Remain_active_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Remain_active_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Remain_active_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRemain_active_flag(s)
	}
}

func (s *Remain_active_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRemain_active_flag(s)
	}
}

func (p *VerilogParser) Remain_active_flag() (localctx IRemain_active_flagContext) {
	localctx = NewRemain_active_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, VerilogParserRULE_remain_active_flag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3553)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IStamptime_conditionContext is an interface to support dynamic dispatch.
type IStamptime_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStamptime_conditionContext differentiates from other interfaces.
	IsStamptime_conditionContext()
}

type Stamptime_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStamptime_conditionContext() *Stamptime_conditionContext {
	var p = new(Stamptime_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_stamptime_condition
	return p
}

func (*Stamptime_conditionContext) IsStamptime_conditionContext() {}

func NewStamptime_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stamptime_conditionContext {
	var p = new(Stamptime_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_stamptime_condition

	return p
}

func (s *Stamptime_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Stamptime_conditionContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Stamptime_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stamptime_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stamptime_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStamptime_condition(s)
	}
}

func (s *Stamptime_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStamptime_condition(s)
	}
}

func (p *VerilogParser) Stamptime_condition() (localctx IStamptime_conditionContext) {
	localctx = NewStamptime_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, VerilogParserRULE_stamptime_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3555)
		p.Mintypmax_expression()
	}

	return localctx
}

// IStart_edge_offsetContext is an interface to support dynamic dispatch.
type IStart_edge_offsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStart_edge_offsetContext differentiates from other interfaces.
	IsStart_edge_offsetContext()
}

type Start_edge_offsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStart_edge_offsetContext() *Start_edge_offsetContext {
	var p = new(Start_edge_offsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_start_edge_offset
	return p
}

func (*Start_edge_offsetContext) IsStart_edge_offsetContext() {}

func NewStart_edge_offsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Start_edge_offsetContext {
	var p = new(Start_edge_offsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_start_edge_offset

	return p
}

func (s *Start_edge_offsetContext) GetParser() antlr.Parser { return s.parser }

func (s *Start_edge_offsetContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Start_edge_offsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Start_edge_offsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Start_edge_offsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterStart_edge_offset(s)
	}
}

func (s *Start_edge_offsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitStart_edge_offset(s)
	}
}

func (p *VerilogParser) Start_edge_offset() (localctx IStart_edge_offsetContext) {
	localctx = NewStart_edge_offsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, VerilogParserRULE_start_edge_offset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3557)
		p.Mintypmax_expression()
	}

	return localctx
}

// IThresholdContext is an interface to support dynamic dispatch.
type IThresholdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThresholdContext differentiates from other interfaces.
	IsThresholdContext()
}

type ThresholdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThresholdContext() *ThresholdContext {
	var p = new(ThresholdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_threshold
	return p
}

func (*ThresholdContext) IsThresholdContext() {}

func NewThresholdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThresholdContext {
	var p = new(ThresholdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_threshold

	return p
}

func (s *ThresholdContext) GetParser() antlr.Parser { return s.parser }

func (s *ThresholdContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *ThresholdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThresholdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThresholdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterThreshold(s)
	}
}

func (s *ThresholdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitThreshold(s)
	}
}

func (p *VerilogParser) Threshold() (localctx IThresholdContext) {
	localctx = NewThresholdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, VerilogParserRULE_threshold)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3559)
		p.Constant_expression()
	}

	return localctx
}

// ITiming_check_limitContext is an interface to support dynamic dispatch.
type ITiming_check_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTiming_check_limitContext differentiates from other interfaces.
	IsTiming_check_limitContext()
}

type Timing_check_limitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTiming_check_limitContext() *Timing_check_limitContext {
	var p = new(Timing_check_limitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_timing_check_limit
	return p
}

func (*Timing_check_limitContext) IsTiming_check_limitContext() {}

func NewTiming_check_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timing_check_limitContext {
	var p = new(Timing_check_limitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_timing_check_limit

	return p
}

func (s *Timing_check_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Timing_check_limitContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Timing_check_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timing_check_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timing_check_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTiming_check_limit(s)
	}
}

func (s *Timing_check_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTiming_check_limit(s)
	}
}

func (p *VerilogParser) Timing_check_limit() (localctx ITiming_check_limitContext) {
	localctx = NewTiming_check_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, VerilogParserRULE_timing_check_limit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3561)
		p.Expression()
	}

	return localctx
}

// ITiming_check_eventContext is an interface to support dynamic dispatch.
type ITiming_check_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTiming_check_eventContext differentiates from other interfaces.
	IsTiming_check_eventContext()
}

type Timing_check_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTiming_check_eventContext() *Timing_check_eventContext {
	var p = new(Timing_check_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_timing_check_event
	return p
}

func (*Timing_check_eventContext) IsTiming_check_eventContext() {}

func NewTiming_check_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timing_check_eventContext {
	var p = new(Timing_check_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_timing_check_event

	return p
}

func (s *Timing_check_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Timing_check_eventContext) Specify_terminal_descriptor() ISpecify_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_terminal_descriptorContext)
}

func (s *Timing_check_eventContext) Timing_check_event_control() ITiming_check_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_event_controlContext)
}

func (s *Timing_check_eventContext) AND3() antlr.TerminalNode {
	return s.GetToken(VerilogParserAND3, 0)
}

func (s *Timing_check_eventContext) Timing_check_condition() ITiming_check_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_conditionContext)
}

func (s *Timing_check_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timing_check_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timing_check_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTiming_check_event(s)
	}
}

func (s *Timing_check_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTiming_check_event(s)
	}
}

func (p *VerilogParser) Timing_check_event() (localctx ITiming_check_eventContext) {
	localctx = NewTiming_check_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, VerilogParserRULE_timing_check_event)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3564)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserK_negedge || _la == VerilogParserK_posedge {
		{
			p.SetState(3563)
			p.Timing_check_event_control()
		}

	}
	{
		p.SetState(3566)
		p.Specify_terminal_descriptor()
	}
	p.SetState(3569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserAND3 {
		{
			p.SetState(3567)
			p.Match(VerilogParserAND3)
		}
		{
			p.SetState(3568)
			p.Timing_check_condition()
		}

	}

	return localctx
}

// IControlled_timing_check_eventContext is an interface to support dynamic dispatch.
type IControlled_timing_check_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsControlled_timing_check_eventContext differentiates from other interfaces.
	IsControlled_timing_check_eventContext()
}

type Controlled_timing_check_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControlled_timing_check_eventContext() *Controlled_timing_check_eventContext {
	var p = new(Controlled_timing_check_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_controlled_timing_check_event
	return p
}

func (*Controlled_timing_check_eventContext) IsControlled_timing_check_eventContext() {}

func NewControlled_timing_check_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Controlled_timing_check_eventContext {
	var p = new(Controlled_timing_check_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_controlled_timing_check_event

	return p
}

func (s *Controlled_timing_check_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Controlled_timing_check_eventContext) Timing_check_event_control() ITiming_check_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_event_controlContext)
}

func (s *Controlled_timing_check_eventContext) Specify_terminal_descriptor() ISpecify_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_terminal_descriptorContext)
}

func (s *Controlled_timing_check_eventContext) AND3() antlr.TerminalNode {
	return s.GetToken(VerilogParserAND3, 0)
}

func (s *Controlled_timing_check_eventContext) Timing_check_condition() ITiming_check_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITiming_check_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITiming_check_conditionContext)
}

func (s *Controlled_timing_check_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Controlled_timing_check_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Controlled_timing_check_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterControlled_timing_check_event(s)
	}
}

func (s *Controlled_timing_check_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitControlled_timing_check_event(s)
	}
}

func (p *VerilogParser) Controlled_timing_check_event() (localctx IControlled_timing_check_eventContext) {
	localctx = NewControlled_timing_check_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, VerilogParserRULE_controlled_timing_check_event)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3571)
		p.Timing_check_event_control()
	}
	{
		p.SetState(3572)
		p.Specify_terminal_descriptor()
	}
	p.SetState(3575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserAND3 {
		{
			p.SetState(3573)
			p.Match(VerilogParserAND3)
		}
		{
			p.SetState(3574)
			p.Timing_check_condition()
		}

	}

	return localctx
}

// ITiming_check_event_controlContext is an interface to support dynamic dispatch.
type ITiming_check_event_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTiming_check_event_controlContext differentiates from other interfaces.
	IsTiming_check_event_controlContext()
}

type Timing_check_event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTiming_check_event_controlContext() *Timing_check_event_controlContext {
	var p = new(Timing_check_event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_timing_check_event_control
	return p
}

func (*Timing_check_event_controlContext) IsTiming_check_event_controlContext() {}

func NewTiming_check_event_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timing_check_event_controlContext {
	var p = new(Timing_check_event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_timing_check_event_control

	return p
}

func (s *Timing_check_event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Timing_check_event_controlContext) K_posedge() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_posedge, 0)
}

func (s *Timing_check_event_controlContext) K_negedge() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_negedge, 0)
}

func (s *Timing_check_event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timing_check_event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timing_check_event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTiming_check_event_control(s)
	}
}

func (s *Timing_check_event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTiming_check_event_control(s)
	}
}

func (p *VerilogParser) Timing_check_event_control() (localctx ITiming_check_event_controlContext) {
	localctx = NewTiming_check_event_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, VerilogParserRULE_timing_check_event_control)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3577)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserK_negedge || _la == VerilogParserK_posedge) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISpecify_terminal_descriptorContext is an interface to support dynamic dispatch.
type ISpecify_terminal_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_terminal_descriptorContext differentiates from other interfaces.
	IsSpecify_terminal_descriptorContext()
}

type Specify_terminal_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_terminal_descriptorContext() *Specify_terminal_descriptorContext {
	var p = new(Specify_terminal_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specify_terminal_descriptor
	return p
}

func (*Specify_terminal_descriptorContext) IsSpecify_terminal_descriptorContext() {}

func NewSpecify_terminal_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_terminal_descriptorContext {
	var p = new(Specify_terminal_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specify_terminal_descriptor

	return p
}

func (s *Specify_terminal_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_terminal_descriptorContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Specify_terminal_descriptorContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Specify_terminal_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_terminal_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_terminal_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecify_terminal_descriptor(s)
	}
}

func (s *Specify_terminal_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecify_terminal_descriptor(s)
	}
}

func (p *VerilogParser) Specify_terminal_descriptor() (localctx ISpecify_terminal_descriptorContext) {
	localctx = NewSpecify_terminal_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, VerilogParserRULE_specify_terminal_descriptor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3581)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 394, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3579)
			p.Specify_input_terminal_descriptor()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3580)
			p.Specify_output_terminal_descriptor()
		}

	}

	return localctx
}

// IEdge_control_specifierContext is an interface to support dynamic dispatch.
type IEdge_control_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEdge_control_specifierContext differentiates from other interfaces.
	IsEdge_control_specifierContext()
}

type Edge_control_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdge_control_specifierContext() *Edge_control_specifierContext {
	var p = new(Edge_control_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_edge_control_specifier
	return p
}

func (*Edge_control_specifierContext) IsEdge_control_specifierContext() {}

func NewEdge_control_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Edge_control_specifierContext {
	var p = new(Edge_control_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_edge_control_specifier

	return p
}

func (s *Edge_control_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Edge_control_specifierContext) K_edge() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_edge, 0)
}

func (s *Edge_control_specifierContext) Left_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, 0)
}

func (s *Edge_control_specifierContext) AllEdge_descriptor() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserEdge_descriptor)
}

func (s *Edge_control_specifierContext) Edge_descriptor(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserEdge_descriptor, i)
}

func (s *Edge_control_specifierContext) Right_bracket() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, 0)
}

func (s *Edge_control_specifierContext) Comma() antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, 0)
}

func (s *Edge_control_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Edge_control_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Edge_control_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEdge_control_specifier(s)
	}
}

func (s *Edge_control_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEdge_control_specifier(s)
	}
}

func (p *VerilogParser) Edge_control_specifier() (localctx IEdge_control_specifierContext) {
	localctx = NewEdge_control_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, VerilogParserRULE_edge_control_specifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3583)
		p.Match(VerilogParserK_edge)
	}
	{
		p.SetState(3584)
		p.Match(VerilogParserLeft_bracket)
	}
	{
		p.SetState(3585)
		p.Match(VerilogParserEdge_descriptor)
	}
	p.SetState(3588)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserComma {
		{
			p.SetState(3586)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3587)
			p.Match(VerilogParserEdge_descriptor)
		}

	}
	{
		p.SetState(3590)
		p.Match(VerilogParserRight_bracket)
	}

	return localctx
}

// ITiming_check_conditionContext is an interface to support dynamic dispatch.
type ITiming_check_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTiming_check_conditionContext differentiates from other interfaces.
	IsTiming_check_conditionContext()
}

type Timing_check_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTiming_check_conditionContext() *Timing_check_conditionContext {
	var p = new(Timing_check_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_timing_check_condition
	return p
}

func (*Timing_check_conditionContext) IsTiming_check_conditionContext() {}

func NewTiming_check_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timing_check_conditionContext {
	var p = new(Timing_check_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_timing_check_condition

	return p
}

func (s *Timing_check_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Timing_check_conditionContext) Scalar_timing_check_condition() IScalar_timing_check_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScalar_timing_check_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScalar_timing_check_conditionContext)
}

func (s *Timing_check_conditionContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Timing_check_conditionContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Timing_check_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timing_check_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timing_check_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTiming_check_condition(s)
	}
}

func (s *Timing_check_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTiming_check_condition(s)
	}
}

func (p *VerilogParser) Timing_check_condition() (localctx ITiming_check_conditionContext) {
	localctx = NewTiming_check_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, VerilogParserRULE_timing_check_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3597)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 396, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3592)
			p.Scalar_timing_check_condition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3593)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(3594)
			p.Scalar_timing_check_condition()
		}
		{
			p.SetState(3595)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IScalar_timing_check_conditionContext is an interface to support dynamic dispatch.
type IScalar_timing_check_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalar_timing_check_conditionContext differentiates from other interfaces.
	IsScalar_timing_check_conditionContext()
}

type Scalar_timing_check_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalar_timing_check_conditionContext() *Scalar_timing_check_conditionContext {
	var p = new(Scalar_timing_check_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_scalar_timing_check_condition
	return p
}

func (*Scalar_timing_check_conditionContext) IsScalar_timing_check_conditionContext() {}

func NewScalar_timing_check_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scalar_timing_check_conditionContext {
	var p = new(Scalar_timing_check_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_scalar_timing_check_condition

	return p
}

func (s *Scalar_timing_check_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Scalar_timing_check_conditionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Scalar_timing_check_conditionContext) Tilda() antlr.TerminalNode {
	return s.GetToken(VerilogParserTilda, 0)
}

func (s *Scalar_timing_check_conditionContext) Eq_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq_eq, 0)
}

func (s *Scalar_timing_check_conditionContext) Scalar_constant() IScalar_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScalar_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScalar_constantContext)
}

func (s *Scalar_timing_check_conditionContext) Eq_eq_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq_eq_eq, 0)
}

func (s *Scalar_timing_check_conditionContext) Not_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserNot_eq, 0)
}

func (s *Scalar_timing_check_conditionContext) Not_eq_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserNot_eq_eq, 0)
}

func (s *Scalar_timing_check_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scalar_timing_check_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scalar_timing_check_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterScalar_timing_check_condition(s)
	}
}

func (s *Scalar_timing_check_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitScalar_timing_check_condition(s)
	}
}

func (p *VerilogParser) Scalar_timing_check_condition() (localctx IScalar_timing_check_conditionContext) {
	localctx = NewScalar_timing_check_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, VerilogParserRULE_scalar_timing_check_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3618)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3599)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3600)
			p.Match(VerilogParserTilda)
		}
		{
			p.SetState(3601)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3602)
			p.Expression()
		}
		{
			p.SetState(3603)
			p.Match(VerilogParserEq_eq)
		}
		{
			p.SetState(3604)
			p.Scalar_constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3606)
			p.Expression()
		}
		{
			p.SetState(3607)
			p.Match(VerilogParserEq_eq_eq)
		}
		{
			p.SetState(3608)
			p.Scalar_constant()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3610)
			p.Expression()
		}
		{
			p.SetState(3611)
			p.Match(VerilogParserNot_eq)
		}
		{
			p.SetState(3612)
			p.Scalar_constant()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3614)
			p.Expression()
		}
		{
			p.SetState(3615)
			p.Match(VerilogParserNot_eq_eq)
		}
		{
			p.SetState(3616)
			p.Scalar_constant()
		}

	}

	return localctx
}

// IScalar_constantContext is an interface to support dynamic dispatch.
type IScalar_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalar_constantContext differentiates from other interfaces.
	IsScalar_constantContext()
}

type Scalar_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalar_constantContext() *Scalar_constantContext {
	var p = new(Scalar_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_scalar_constant
	return p
}

func (*Scalar_constantContext) IsScalar_constantContext() {}

func NewScalar_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scalar_constantContext {
	var p = new(Scalar_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_scalar_constant

	return p
}

func (s *Scalar_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Scalar_constantContext) Single_Bit_Zero() antlr.TerminalNode {
	return s.GetToken(VerilogParserSingle_Bit_Zero, 0)
}

func (s *Scalar_constantContext) Single_Bit_One() antlr.TerminalNode {
	return s.GetToken(VerilogParserSingle_Bit_One, 0)
}

func (s *Scalar_constantContext) All_Binary_Zero() antlr.TerminalNode {
	return s.GetToken(VerilogParserAll_Binary_Zero, 0)
}

func (s *Scalar_constantContext) All_Binary_One() antlr.TerminalNode {
	return s.GetToken(VerilogParserAll_Binary_One, 0)
}

func (s *Scalar_constantContext) Zero() antlr.TerminalNode {
	return s.GetToken(VerilogParserZero, 0)
}

func (s *Scalar_constantContext) One() antlr.TerminalNode {
	return s.GetToken(VerilogParserOne, 0)
}

func (s *Scalar_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scalar_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scalar_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterScalar_constant(s)
	}
}

func (s *Scalar_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitScalar_constant(s)
	}
}

func (p *VerilogParser) Scalar_constant() (localctx IScalar_constantContext) {
	localctx = NewScalar_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, VerilogParserRULE_scalar_constant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3620)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(VerilogParserSingle_Bit_Zero-293))|(1<<(VerilogParserSingle_Bit_One-293))|(1<<(VerilogParserAll_Binary_Zero-293))|(1<<(VerilogParserAll_Binary_One-293))|(1<<(VerilogParserZero-293))|(1<<(VerilogParserOne-293)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConcatenationContext is an interface to support dynamic dispatch.
type IConcatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcatenationContext differentiates from other interfaces.
	IsConcatenationContext()
}

type ConcatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcatenationContext() *ConcatenationContext {
	var p = new(ConcatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_concatenation
	return p
}

func (*ConcatenationContext) IsConcatenationContext() {}

func NewConcatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_concatenation

	return p
}

func (s *ConcatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConcatenationContext) Left_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_brace, 0)
}

func (s *ConcatenationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConcatenationContext) Right_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_brace, 0)
}

func (s *ConcatenationContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *ConcatenationContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (p *VerilogParser) Concatenation() (localctx IConcatenationContext) {
	localctx = NewConcatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, VerilogParserRULE_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3622)
		p.Match(VerilogParserLeft_brace)
	}
	{
		p.SetState(3623)
		p.Expression()
	}
	p.SetState(3628)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(3624)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3625)
			p.Expression()
		}

		p.SetState(3630)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3631)
		p.Match(VerilogParserRight_brace)
	}

	return localctx
}

// IConstant_concatenationContext is an interface to support dynamic dispatch.
type IConstant_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_concatenationContext differentiates from other interfaces.
	IsConstant_concatenationContext()
}

type Constant_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_concatenationContext() *Constant_concatenationContext {
	var p = new(Constant_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_concatenation
	return p
}

func (*Constant_concatenationContext) IsConstant_concatenationContext() {}

func NewConstant_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_concatenationContext {
	var p = new(Constant_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_concatenation

	return p
}

func (s *Constant_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_concatenationContext) Left_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_brace, 0)
}

func (s *Constant_concatenationContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_concatenationContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_concatenationContext) Right_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_brace, 0)
}

func (s *Constant_concatenationContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Constant_concatenationContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Constant_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_concatenation(s)
	}
}

func (s *Constant_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_concatenation(s)
	}
}

func (p *VerilogParser) Constant_concatenation() (localctx IConstant_concatenationContext) {
	localctx = NewConstant_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, VerilogParserRULE_constant_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3633)
		p.Match(VerilogParserLeft_brace)
	}
	{
		p.SetState(3634)
		p.Constant_expression()
	}
	p.SetState(3639)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(3635)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3636)
			p.Constant_expression()
		}

		p.SetState(3641)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3642)
		p.Match(VerilogParserRight_brace)
	}

	return localctx
}

// IConstant_multiple_concatenationContext is an interface to support dynamic dispatch.
type IConstant_multiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_multiple_concatenationContext differentiates from other interfaces.
	IsConstant_multiple_concatenationContext()
}

type Constant_multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_multiple_concatenationContext() *Constant_multiple_concatenationContext {
	var p = new(Constant_multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_multiple_concatenation
	return p
}

func (*Constant_multiple_concatenationContext) IsConstant_multiple_concatenationContext() {}

func NewConstant_multiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_multiple_concatenationContext {
	var p = new(Constant_multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_multiple_concatenation

	return p
}

func (s *Constant_multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_multiple_concatenationContext) Left_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_brace, 0)
}

func (s *Constant_multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_multiple_concatenationContext) Constant_concatenation() IConstant_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_concatenationContext)
}

func (s *Constant_multiple_concatenationContext) Right_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_brace, 0)
}

func (s *Constant_multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_multiple_concatenation(s)
	}
}

func (s *Constant_multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_multiple_concatenation(s)
	}
}

func (p *VerilogParser) Constant_multiple_concatenation() (localctx IConstant_multiple_concatenationContext) {
	localctx = NewConstant_multiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, VerilogParserRULE_constant_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3644)
		p.Match(VerilogParserLeft_brace)
	}
	{
		p.SetState(3645)
		p.Constant_expression()
	}
	{
		p.SetState(3646)
		p.Constant_concatenation()
	}
	{
		p.SetState(3647)
		p.Match(VerilogParserRight_brace)
	}

	return localctx
}

// IModule_path_concatenationContext is an interface to support dynamic dispatch.
type IModule_path_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_concatenationContext differentiates from other interfaces.
	IsModule_path_concatenationContext()
}

type Module_path_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_concatenationContext() *Module_path_concatenationContext {
	var p = new(Module_path_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_concatenation
	return p
}

func (*Module_path_concatenationContext) IsModule_path_concatenationContext() {}

func NewModule_path_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_concatenationContext {
	var p = new(Module_path_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_concatenation

	return p
}

func (s *Module_path_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_concatenationContext) Left_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_brace, 0)
}

func (s *Module_path_concatenationContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_concatenationContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_concatenationContext) Right_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_brace, 0)
}

func (s *Module_path_concatenationContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Module_path_concatenationContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Module_path_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_concatenation(s)
	}
}

func (s *Module_path_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_concatenation(s)
	}
}

func (p *VerilogParser) Module_path_concatenation() (localctx IModule_path_concatenationContext) {
	localctx = NewModule_path_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, VerilogParserRULE_module_path_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3649)
		p.Match(VerilogParserLeft_brace)
	}
	{
		p.SetState(3650)
		p.Module_path_expression()
	}
	p.SetState(3655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(3651)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3652)
			p.Module_path_expression()
		}

		p.SetState(3657)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3658)
		p.Match(VerilogParserRight_brace)
	}

	return localctx
}

// IModule_path_multiple_concatenationContext is an interface to support dynamic dispatch.
type IModule_path_multiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_multiple_concatenationContext differentiates from other interfaces.
	IsModule_path_multiple_concatenationContext()
}

type Module_path_multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_multiple_concatenationContext() *Module_path_multiple_concatenationContext {
	var p = new(Module_path_multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_multiple_concatenation
	return p
}

func (*Module_path_multiple_concatenationContext) IsModule_path_multiple_concatenationContext() {}

func NewModule_path_multiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_multiple_concatenationContext {
	var p = new(Module_path_multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_multiple_concatenation

	return p
}

func (s *Module_path_multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_multiple_concatenationContext) Left_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_brace, 0)
}

func (s *Module_path_multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Module_path_multiple_concatenationContext) Module_path_concatenation() IModule_path_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_concatenationContext)
}

func (s *Module_path_multiple_concatenationContext) Right_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_brace, 0)
}

func (s *Module_path_multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_multiple_concatenation(s)
	}
}

func (s *Module_path_multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_multiple_concatenation(s)
	}
}

func (p *VerilogParser) Module_path_multiple_concatenation() (localctx IModule_path_multiple_concatenationContext) {
	localctx = NewModule_path_multiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, VerilogParserRULE_module_path_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3660)
		p.Match(VerilogParserLeft_brace)
	}
	{
		p.SetState(3661)
		p.Constant_expression()
	}
	{
		p.SetState(3662)
		p.Module_path_concatenation()
	}
	{
		p.SetState(3663)
		p.Match(VerilogParserRight_brace)
	}

	return localctx
}

// IMultiple_concatenationContext is an interface to support dynamic dispatch.
type IMultiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiple_concatenationContext differentiates from other interfaces.
	IsMultiple_concatenationContext()
}

type Multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiple_concatenationContext() *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_multiple_concatenation
	return p
}

func (*Multiple_concatenationContext) IsMultiple_concatenationContext() {}

func NewMultiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_multiple_concatenation

	return p
}

func (s *Multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiple_concatenationContext) Left_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_brace, 0)
}

func (s *Multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Multiple_concatenationContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Multiple_concatenationContext) Right_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_brace, 0)
}

func (s *Multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMultiple_concatenation(s)
	}
}

func (s *Multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMultiple_concatenation(s)
	}
}

func (p *VerilogParser) Multiple_concatenation() (localctx IMultiple_concatenationContext) {
	localctx = NewMultiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, VerilogParserRULE_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3665)
		p.Match(VerilogParserLeft_brace)
	}
	{
		p.SetState(3666)
		p.Constant_expression()
	}
	{
		p.SetState(3667)
		p.Concatenation()
	}
	{
		p.SetState(3668)
		p.Match(VerilogParserRight_brace)
	}

	return localctx
}

// INet_concatenationContext is an interface to support dynamic dispatch.
type INet_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_concatenationContext differentiates from other interfaces.
	IsNet_concatenationContext()
}

type Net_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_concatenationContext() *Net_concatenationContext {
	var p = new(Net_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_concatenation
	return p
}

func (*Net_concatenationContext) IsNet_concatenationContext() {}

func NewNet_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_concatenationContext {
	var p = new(Net_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_concatenation

	return p
}

func (s *Net_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_concatenationContext) Left_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_brace, 0)
}

func (s *Net_concatenationContext) AllNet_concatenation_value() []INet_concatenation_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_concatenation_valueContext)(nil)).Elem())
	var tst = make([]INet_concatenation_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_concatenation_valueContext)
		}
	}

	return tst
}

func (s *Net_concatenationContext) Net_concatenation_value(i int) INet_concatenation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_concatenation_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_concatenation_valueContext)
}

func (s *Net_concatenationContext) Right_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_brace, 0)
}

func (s *Net_concatenationContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Net_concatenationContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Net_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_concatenation(s)
	}
}

func (s *Net_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_concatenation(s)
	}
}

func (p *VerilogParser) Net_concatenation() (localctx INet_concatenationContext) {
	localctx = NewNet_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, VerilogParserRULE_net_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3670)
		p.Match(VerilogParserLeft_brace)
	}
	{
		p.SetState(3671)
		p.Net_concatenation_value()
	}
	p.SetState(3676)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(3672)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3673)
			p.Net_concatenation_value()
		}

		p.SetState(3678)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3679)
		p.Match(VerilogParserRight_brace)
	}

	return localctx
}

// INet_concatenation_valueContext is an interface to support dynamic dispatch.
type INet_concatenation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_concatenation_valueContext differentiates from other interfaces.
	IsNet_concatenation_valueContext()
}

type Net_concatenation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_concatenation_valueContext() *Net_concatenation_valueContext {
	var p = new(Net_concatenation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_concatenation_value
	return p
}

func (*Net_concatenation_valueContext) IsNet_concatenation_valueContext() {}

func NewNet_concatenation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_concatenation_valueContext {
	var p = new(Net_concatenation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_concatenation_value

	return p
}

func (s *Net_concatenation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_concatenation_valueContext) Hierarchical_net_identifier() IHierarchical_net_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_net_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_net_identifierContext)
}

func (s *Net_concatenation_valueContext) AllLeft_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_bracket)
}

func (s *Net_concatenation_valueContext) Left_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, i)
}

func (s *Net_concatenation_valueContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Net_concatenation_valueContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_concatenation_valueContext) AllRight_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_bracket)
}

func (s *Net_concatenation_valueContext) Right_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, i)
}

func (s *Net_concatenation_valueContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Net_concatenation_valueContext) Net_concatenation() INet_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_concatenationContext)
}

func (s *Net_concatenation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_concatenation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_concatenation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_concatenation_value(s)
	}
}

func (s *Net_concatenation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_concatenation_value(s)
	}
}

func (p *VerilogParser) Net_concatenation_value() (localctx INet_concatenation_valueContext) {
	localctx = NewNet_concatenation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, VerilogParserRULE_net_concatenation_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3718)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 404, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3681)
			p.Hierarchical_net_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3682)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(3683)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3684)
			p.Expression()
		}
		{
			p.SetState(3685)
			p.Match(VerilogParserRight_bracket)
		}
		p.SetState(3692)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_bracket {
			{
				p.SetState(3686)
				p.Match(VerilogParserLeft_bracket)
			}
			{
				p.SetState(3687)
				p.Expression()
			}
			{
				p.SetState(3688)
				p.Match(VerilogParserRight_bracket)
			}

			p.SetState(3694)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3695)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(3696)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3697)
			p.Expression()
		}
		{
			p.SetState(3698)
			p.Match(VerilogParserRight_bracket)
		}
		p.SetState(3705)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 403, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3699)
					p.Match(VerilogParserLeft_bracket)
				}
				{
					p.SetState(3700)
					p.Expression()
				}
				{
					p.SetState(3701)
					p.Match(VerilogParserRight_bracket)
				}

			}
			p.SetState(3707)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 403, p.GetParserRuleContext())
		}
		{
			p.SetState(3708)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3709)
			p.Range_expression()
		}
		{
			p.SetState(3710)
			p.Match(VerilogParserRight_bracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3712)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(3713)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3714)
			p.Range_expression()
		}
		{
			p.SetState(3715)
			p.Match(VerilogParserRight_bracket)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3717)
			p.Net_concatenation()
		}

	}

	return localctx
}

// IVariable_concatenationContext is an interface to support dynamic dispatch.
type IVariable_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_concatenationContext differentiates from other interfaces.
	IsVariable_concatenationContext()
}

type Variable_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_concatenationContext() *Variable_concatenationContext {
	var p = new(Variable_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_concatenation
	return p
}

func (*Variable_concatenationContext) IsVariable_concatenationContext() {}

func NewVariable_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_concatenationContext {
	var p = new(Variable_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_concatenation

	return p
}

func (s *Variable_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_concatenationContext) Left_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_brace, 0)
}

func (s *Variable_concatenationContext) AllVariable_concatenation_value() []IVariable_concatenation_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_concatenation_valueContext)(nil)).Elem())
	var tst = make([]IVariable_concatenation_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_concatenation_valueContext)
		}
	}

	return tst
}

func (s *Variable_concatenationContext) Variable_concatenation_value(i int) IVariable_concatenation_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenation_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenation_valueContext)
}

func (s *Variable_concatenationContext) Right_brace() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_brace, 0)
}

func (s *Variable_concatenationContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Variable_concatenationContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Variable_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_concatenation(s)
	}
}

func (s *Variable_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_concatenation(s)
	}
}

func (p *VerilogParser) Variable_concatenation() (localctx IVariable_concatenationContext) {
	localctx = NewVariable_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, VerilogParserRULE_variable_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3720)
		p.Match(VerilogParserLeft_brace)
	}
	{
		p.SetState(3721)
		p.Variable_concatenation_value()
	}
	p.SetState(3726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(3722)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(3723)
			p.Variable_concatenation_value()
		}

		p.SetState(3728)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3729)
		p.Match(VerilogParserRight_brace)
	}

	return localctx
}

// IVariable_concatenation_valueContext is an interface to support dynamic dispatch.
type IVariable_concatenation_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_concatenation_valueContext differentiates from other interfaces.
	IsVariable_concatenation_valueContext()
}

type Variable_concatenation_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_concatenation_valueContext() *Variable_concatenation_valueContext {
	var p = new(Variable_concatenation_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_concatenation_value
	return p
}

func (*Variable_concatenation_valueContext) IsVariable_concatenation_valueContext() {}

func NewVariable_concatenation_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_concatenation_valueContext {
	var p = new(Variable_concatenation_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_concatenation_value

	return p
}

func (s *Variable_concatenation_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_concatenation_valueContext) Hierarchical_variable_identifier() IHierarchical_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_identifierContext)
}

func (s *Variable_concatenation_valueContext) AllLeft_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_bracket)
}

func (s *Variable_concatenation_valueContext) Left_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, i)
}

func (s *Variable_concatenation_valueContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Variable_concatenation_valueContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_concatenation_valueContext) AllRight_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_bracket)
}

func (s *Variable_concatenation_valueContext) Right_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, i)
}

func (s *Variable_concatenation_valueContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Variable_concatenation_valueContext) Variable_concatenation() IVariable_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenationContext)
}

func (s *Variable_concatenation_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_concatenation_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_concatenation_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_concatenation_value(s)
	}
}

func (s *Variable_concatenation_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_concatenation_value(s)
	}
}

func (p *VerilogParser) Variable_concatenation_value() (localctx IVariable_concatenation_valueContext) {
	localctx = NewVariable_concatenation_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, VerilogParserRULE_variable_concatenation_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3768)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 408, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3731)
			p.Hierarchical_variable_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3732)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(3733)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3734)
			p.Expression()
		}
		{
			p.SetState(3735)
			p.Match(VerilogParserRight_bracket)
		}
		p.SetState(3742)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_bracket {
			{
				p.SetState(3736)
				p.Match(VerilogParserLeft_bracket)
			}
			{
				p.SetState(3737)
				p.Expression()
			}
			{
				p.SetState(3738)
				p.Match(VerilogParserRight_bracket)
			}

			p.SetState(3744)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3745)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(3746)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3747)
			p.Expression()
		}
		{
			p.SetState(3748)
			p.Match(VerilogParserRight_bracket)
		}
		p.SetState(3755)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 407, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3749)
					p.Match(VerilogParserLeft_bracket)
				}
				{
					p.SetState(3750)
					p.Expression()
				}
				{
					p.SetState(3751)
					p.Match(VerilogParserRight_bracket)
				}

			}
			p.SetState(3757)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 407, p.GetParserRuleContext())
		}
		{
			p.SetState(3758)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3759)
			p.Range_expression()
		}
		{
			p.SetState(3760)
			p.Match(VerilogParserRight_bracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3762)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(3763)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(3764)
			p.Range_expression()
		}
		{
			p.SetState(3765)
			p.Match(VerilogParserRight_bracket)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3767)
			p.Variable_concatenation()
		}

	}

	return localctx
}

// IConstant_function_callContext is an interface to support dynamic dispatch.
type IConstant_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_function_callContext differentiates from other interfaces.
	IsConstant_function_callContext()
}

type Constant_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_function_callContext() *Constant_function_callContext {
	var p = new(Constant_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_function_call
	return p
}

func (*Constant_function_callContext) IsConstant_function_callContext() {}

func NewConstant_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_function_callContext {
	var p = new(Constant_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_function_call

	return p
}

func (s *Constant_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_function_callContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Constant_function_callContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Constant_function_callContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Constant_function_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Constant_function_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Constant_function_callContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_function_callContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_function_callContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Constant_function_callContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Constant_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_function_call(s)
	}
}

func (s *Constant_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_function_call(s)
	}
}

func (p *VerilogParser) Constant_function_call() (localctx IConstant_function_callContext) {
	localctx = NewConstant_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, VerilogParserRULE_constant_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3770)
		p.Function_identifier()
	}
	p.SetState(3774)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 409, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3771)
				p.Attribute_instance()
			}

		}
		p.SetState(3776)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 409, p.GetParserRuleContext())
	}
	{
		p.SetState(3777)
		p.Match(VerilogParserLeft_parenthes)
	}
	p.SetState(3786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
		{
			p.SetState(3778)
			p.Constant_expression()
		}
		p.SetState(3783)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(3779)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(3780)
				p.Constant_expression()
			}

			p.SetState(3785)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3788)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IFunction_callContext is an interface to support dynamic dispatch.
type IFunction_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_callContext differentiates from other interfaces.
	IsFunction_callContext()
}

type Function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_callContext() *Function_callContext {
	var p = new(Function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_call
	return p
}

func (*Function_callContext) IsFunction_callContext() {}

func NewFunction_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_callContext {
	var p = new(Function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_call

	return p
}

func (s *Function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_callContext) Hierarchical_function_identifier() IHierarchical_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_function_identifierContext)
}

func (s *Function_callContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Function_callContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Function_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_callContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Function_callContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Function_callContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Function_callContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_call(s)
	}
}

func (s *Function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_call(s)
	}
}

func (p *VerilogParser) Function_call() (localctx IFunction_callContext) {
	localctx = NewFunction_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, VerilogParserRULE_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3790)
		p.Hierarchical_function_identifier()
	}
	p.SetState(3794)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 412, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3791)
				p.Attribute_instance()
			}

		}
		p.SetState(3796)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 412, p.GetParserRuleContext())
	}
	{
		p.SetState(3797)
		p.Match(VerilogParserLeft_parenthes)
	}
	p.SetState(3806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
		{
			p.SetState(3798)
			p.Expression()
		}
		p.SetState(3803)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(3799)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(3800)
				p.Expression()
			}

			p.SetState(3805)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3808)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// ISystem_function_callContext is an interface to support dynamic dispatch.
type ISystem_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_function_callContext differentiates from other interfaces.
	IsSystem_function_callContext()
}

type System_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_function_callContext() *System_function_callContext {
	var p = new(System_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_function_call
	return p
}

func (*System_function_callContext) IsSystem_function_callContext() {}

func NewSystem_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_function_callContext {
	var p = new(System_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_function_call

	return p
}

func (s *System_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *System_function_callContext) System_function_identifier() ISystem_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_identifierContext)
}

func (s *System_function_callContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *System_function_callContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *System_function_callContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *System_function_callContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *System_function_callContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *System_function_callContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *System_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSystem_function_call(s)
	}
}

func (s *System_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSystem_function_call(s)
	}
}

func (p *VerilogParser) System_function_call() (localctx ISystem_function_callContext) {
	localctx = NewSystem_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, VerilogParserRULE_system_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3810)
		p.System_function_identifier()
	}
	p.SetState(3823)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 417, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3811)
			p.Match(VerilogParserLeft_parenthes)
		}
		p.SetState(3820)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
			{
				p.SetState(3812)
				p.Expression()
			}
			p.SetState(3817)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == VerilogParserComma {
				{
					p.SetState(3813)
					p.Match(VerilogParserComma)
				}
				{
					p.SetState(3814)
					p.Expression()
				}

				p.SetState(3819)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3822)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IGenvar_function_callContext is an interface to support dynamic dispatch.
type IGenvar_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_function_callContext differentiates from other interfaces.
	IsGenvar_function_callContext()
}

type Genvar_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_function_callContext() *Genvar_function_callContext {
	var p = new(Genvar_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_function_call
	return p
}

func (*Genvar_function_callContext) IsGenvar_function_callContext() {}

func NewGenvar_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_function_callContext {
	var p = new(Genvar_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_function_call

	return p
}

func (s *Genvar_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_function_callContext) Genvar_function_identifier() IGenvar_function_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_function_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_function_identifierContext)
}

func (s *Genvar_function_callContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Genvar_function_callContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Genvar_function_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Genvar_function_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Genvar_function_callContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Genvar_function_callContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Genvar_function_callContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Genvar_function_callContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Genvar_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_function_call(s)
	}
}

func (s *Genvar_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_function_call(s)
	}
}

func (p *VerilogParser) Genvar_function_call() (localctx IGenvar_function_callContext) {
	localctx = NewGenvar_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, VerilogParserRULE_genvar_function_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3825)
		p.Genvar_function_identifier()
	}
	p.SetState(3829)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 418, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3826)
				p.Attribute_instance()
			}

		}
		p.SetState(3831)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 418, p.GetParserRuleContext())
	}
	{
		p.SetState(3832)
		p.Match(VerilogParserLeft_parenthes)
	}
	p.SetState(3841)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218))|(1<<(VerilogParserPlus-218)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(VerilogParserMinus-250))|(1<<(VerilogParserExclamation_mark-250))|(1<<(VerilogParserLeft_parenthes-250))|(1<<(VerilogParserLeft_brace-250))|(1<<(VerilogParserAND-250))|(1<<(VerilogParserVertical_line-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(VerilogParserTilda-283))|(1<<(VerilogParserHat-283))|(1<<(VerilogParserReal_number-283))|(1<<(VerilogParserDecimal_number-283))|(1<<(VerilogParserBinary_number-283))|(1<<(VerilogParserOctal_number-283))|(1<<(VerilogParserHex_number-283))|(1<<(VerilogParserEscaped_identifier-283))|(1<<(VerilogParserSimple_identifier-283))|(1<<(VerilogParserString_const-283)))) != 0) {
		{
			p.SetState(3833)
			p.Constant_expression()
		}
		p.SetState(3838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserComma {
			{
				p.SetState(3834)
				p.Match(VerilogParserComma)
			}
			{
				p.SetState(3835)
				p.Constant_expression()
			}

			p.SetState(3840)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3843)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IBase_expressionContext is an interface to support dynamic dispatch.
type IBase_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_expressionContext differentiates from other interfaces.
	IsBase_expressionContext()
}

type Base_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_expressionContext() *Base_expressionContext {
	var p = new(Base_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_base_expression
	return p
}

func (*Base_expressionContext) IsBase_expressionContext() {}

func NewBase_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_expressionContext {
	var p = new(Base_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_base_expression

	return p
}

func (s *Base_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Base_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBase_expression(s)
	}
}

func (s *Base_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBase_expression(s)
	}
}

func (p *VerilogParser) Base_expression() (localctx IBase_expressionContext) {
	localctx = NewBase_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, VerilogParserRULE_base_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3845)
		p.Expression()
	}

	return localctx
}

// IConstant_base_expressionContext is an interface to support dynamic dispatch.
type IConstant_base_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_base_expressionContext differentiates from other interfaces.
	IsConstant_base_expressionContext()
}

type Constant_base_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_base_expressionContext() *Constant_base_expressionContext {
	var p = new(Constant_base_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_base_expression
	return p
}

func (*Constant_base_expressionContext) IsConstant_base_expressionContext() {}

func NewConstant_base_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_base_expressionContext {
	var p = new(Constant_base_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_base_expression

	return p
}

func (s *Constant_base_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_base_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_base_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_base_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_base_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_base_expression(s)
	}
}

func (s *Constant_base_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_base_expression(s)
	}
}

func (p *VerilogParser) Constant_base_expression() (localctx IConstant_base_expressionContext) {
	localctx = NewConstant_base_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, VerilogParserRULE_constant_base_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3847)
		p.Constant_expression()
	}

	return localctx
}

// IConstant_expressionContext is an interface to support dynamic dispatch.
type IConstant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_expressionContext differentiates from other interfaces.
	IsConstant_expressionContext()
}

type Constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_expressionContext() *Constant_expressionContext {
	var p = new(Constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_expression
	return p
}

func (*Constant_expressionContext) IsConstant_expressionContext() {}

func NewConstant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_expressionContext {
	var p = new(Constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_expression

	return p
}

func (s *Constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_expression(s)
	}
}

func (s *Constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_expression(s)
	}
}

func (p *VerilogParser) Constant_expression() (localctx IConstant_expressionContext) {
	localctx = NewConstant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, VerilogParserRULE_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3849)
		p.Expression()
	}

	return localctx
}

// IConstant_mintypmax_expressionContext is an interface to support dynamic dispatch.
type IConstant_mintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_mintypmax_expressionContext differentiates from other interfaces.
	IsConstant_mintypmax_expressionContext()
}

type Constant_mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_mintypmax_expressionContext() *Constant_mintypmax_expressionContext {
	var p = new(Constant_mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_mintypmax_expression
	return p
}

func (*Constant_mintypmax_expressionContext) IsConstant_mintypmax_expressionContext() {}

func NewConstant_mintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_mintypmax_expressionContext {
	var p = new(Constant_mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_mintypmax_expression

	return p
}

func (s *Constant_mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_mintypmax_expressionContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_mintypmax_expressionContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_mintypmax_expressionContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserColon)
}

func (s *Constant_mintypmax_expressionContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, i)
}

func (s *Constant_mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_mintypmax_expression(s)
	}
}

func (s *Constant_mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_mintypmax_expression(s)
	}
}

func (p *VerilogParser) Constant_mintypmax_expression() (localctx IConstant_mintypmax_expressionContext) {
	localctx = NewConstant_mintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, VerilogParserRULE_constant_mintypmax_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3858)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 421, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3851)
			p.Constant_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3852)
			p.Constant_expression()
		}
		{
			p.SetState(3853)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3854)
			p.Constant_expression()
		}
		{
			p.SetState(3855)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3856)
			p.Constant_expression()
		}

	}

	return localctx
}

// IConstant_range_expressionContext is an interface to support dynamic dispatch.
type IConstant_range_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_range_expressionContext differentiates from other interfaces.
	IsConstant_range_expressionContext()
}

type Constant_range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_range_expressionContext() *Constant_range_expressionContext {
	var p = new(Constant_range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_range_expression
	return p
}

func (*Constant_range_expressionContext) IsConstant_range_expressionContext() {}

func NewConstant_range_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_range_expressionContext {
	var p = new(Constant_range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_range_expression

	return p
}

func (s *Constant_range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_range_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_range_expressionContext) Msb_constant_expression() IMsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMsb_constant_expressionContext)
}

func (s *Constant_range_expressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Constant_range_expressionContext) Lsb_constant_expression() ILsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsb_constant_expressionContext)
}

func (s *Constant_range_expressionContext) Constant_base_expression() IConstant_base_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_base_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_base_expressionContext)
}

func (s *Constant_range_expressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(VerilogParserPlus, 0)
}

func (s *Constant_range_expressionContext) Width_constant_expression() IWidth_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWidth_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWidth_constant_expressionContext)
}

func (s *Constant_range_expressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(VerilogParserMinus, 0)
}

func (s *Constant_range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_range_expression(s)
	}
}

func (s *Constant_range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_range_expression(s)
	}
}

func (p *VerilogParser) Constant_range_expression() (localctx IConstant_range_expressionContext) {
	localctx = NewConstant_range_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, VerilogParserRULE_constant_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3875)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 422, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3860)
			p.Constant_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3861)
			p.Msb_constant_expression()
		}
		{
			p.SetState(3862)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3863)
			p.Lsb_constant_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3865)
			p.Constant_base_expression()
		}
		{
			p.SetState(3866)
			p.Match(VerilogParserPlus)
		}
		{
			p.SetState(3867)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3868)
			p.Width_constant_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3870)
			p.Constant_base_expression()
		}
		{
			p.SetState(3871)
			p.Match(VerilogParserMinus)
		}
		{
			p.SetState(3872)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3873)
			p.Width_constant_expression()
		}

	}

	return localctx
}

// IDimension_constant_expressionContext is an interface to support dynamic dispatch.
type IDimension_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimension_constant_expressionContext differentiates from other interfaces.
	IsDimension_constant_expressionContext()
}

type Dimension_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimension_constant_expressionContext() *Dimension_constant_expressionContext {
	var p = new(Dimension_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_dimension_constant_expression
	return p
}

func (*Dimension_constant_expressionContext) IsDimension_constant_expressionContext() {}

func NewDimension_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dimension_constant_expressionContext {
	var p = new(Dimension_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_dimension_constant_expression

	return p
}

func (s *Dimension_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Dimension_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Dimension_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dimension_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dimension_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterDimension_constant_expression(s)
	}
}

func (s *Dimension_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitDimension_constant_expression(s)
	}
}

func (p *VerilogParser) Dimension_constant_expression() (localctx IDimension_constant_expressionContext) {
	localctx = NewDimension_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, VerilogParserRULE_dimension_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3877)
		p.Constant_expression()
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *ExpressionContext) AllBinary_operator() []IBinary_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem())
	var tst = make([]IBinary_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinary_operatorContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Binary_operator(i int) IBinary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinary_operatorContext)
}

func (s *ExpressionContext) AllQuestion_mark() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserQuestion_mark)
}

func (s *ExpressionContext) Question_mark(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserQuestion_mark, i)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserColon)
}

func (s *ExpressionContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, i)
}

func (s *ExpressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *VerilogParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, VerilogParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3879)
		p.Term()
	}
	p.SetState(3902)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 426, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3900)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case VerilogParserPlus, VerilogParserMinus, VerilogParserLeft_angle_bracket, VerilogParserRight_angle_bracket, VerilogParserSlash, VerilogParserEq_eq, VerilogParserEq_eq_eq, VerilogParserNot_eq, VerilogParserNot_eq_eq, VerilogParserLeft_angle_eq, VerilogParserAsterisk, VerilogParserPercent, VerilogParserAND, VerilogParserVertical_line, VerilogParserTilda, VerilogParserHat:
				{
					p.SetState(3880)
					p.Binary_operator()
				}
				p.SetState(3884)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 423, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3881)
							p.Attribute_instance()
						}

					}
					p.SetState(3886)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 423, p.GetParserRuleContext())
				}
				{
					p.SetState(3887)
					p.Term()
				}

			case VerilogParserQuestion_mark:
				{
					p.SetState(3889)
					p.Match(VerilogParserQuestion_mark)
				}
				p.SetState(3893)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 424, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3890)
							p.Attribute_instance()
						}

					}
					p.SetState(3895)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 424, p.GetParserRuleContext())
				}
				{
					p.SetState(3896)
					p.Expression()
				}
				{
					p.SetState(3897)
					p.Match(VerilogParserColon)
				}
				{
					p.SetState(3898)
					p.Term()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(3904)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 426, p.GetParserRuleContext())
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *TermContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *TermContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *TermContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *TermContext) String_const() antlr.TerminalNode {
	return s.GetToken(VerilogParserString_const, 0)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *VerilogParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, VerilogParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3916)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserPlus, VerilogParserMinus, VerilogParserExclamation_mark, VerilogParserAND, VerilogParserVertical_line, VerilogParserTilda, VerilogParserHat:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3905)
			p.Unary_operator()
		}
		p.SetState(3909)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 427, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3906)
					p.Attribute_instance()
				}

			}
			p.SetState(3911)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 427, p.GetParserRuleContext())
		}
		{
			p.SetState(3912)
			p.Primary()
		}

	case VerilogParserK_FUNC_q_initialize, VerilogParserK_FUNC_q_remove, VerilogParserK_FUNC_q_full, VerilogParserK_FUNC_q_exam, VerilogParserK_FUNC_q_add, VerilogParserK_FUNC_realtime, VerilogParserK_FUNC_stime, VerilogParserK_FUNC_time, VerilogParserK_FUNC_shortrealtobits, VerilogParserK_FUNC_bitstoshortreal, VerilogParserK_FUNC_realtobits, VerilogParserK_FUNC_bitstoreal, VerilogParserK_FUNC_unsigned, VerilogParserK_FUNC_signed, VerilogParserK_FUNC_rtoi, VerilogParserK_FUNC_itor, VerilogParserK_FUNC_cast, VerilogParserK_FUNC_random, VerilogParserK_FUNC_dist_exponential, VerilogParserK_FUNC_dist_chi_square, VerilogParserK_FUNC_dist_uniform, VerilogParserK_FUNC_dist_poisson, VerilogParserK_FUNC_dist_normal, VerilogParserK_FUNC_dist_erlang, VerilogParserK_FUNC_dist_t, VerilogParserK_FUNC_test_plusargs, VerilogParserK_FUNC_value_plusargs, VerilogParserLeft_parenthes, VerilogParserLeft_brace, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3914)
			p.Primary()
		}

	case VerilogParserString_const:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3915)
			p.Match(VerilogParserString_const)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILsb_constant_expressionContext is an interface to support dynamic dispatch.
type ILsb_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLsb_constant_expressionContext differentiates from other interfaces.
	IsLsb_constant_expressionContext()
}

type Lsb_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLsb_constant_expressionContext() *Lsb_constant_expressionContext {
	var p = new(Lsb_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_lsb_constant_expression
	return p
}

func (*Lsb_constant_expressionContext) IsLsb_constant_expressionContext() {}

func NewLsb_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lsb_constant_expressionContext {
	var p = new(Lsb_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_lsb_constant_expression

	return p
}

func (s *Lsb_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Lsb_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Lsb_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lsb_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lsb_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLsb_constant_expression(s)
	}
}

func (s *Lsb_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLsb_constant_expression(s)
	}
}

func (p *VerilogParser) Lsb_constant_expression() (localctx ILsb_constant_expressionContext) {
	localctx = NewLsb_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, VerilogParserRULE_lsb_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3918)
		p.Constant_expression()
	}

	return localctx
}

// IMintypmax_expressionContext is an interface to support dynamic dispatch.
type IMintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMintypmax_expressionContext differentiates from other interfaces.
	IsMintypmax_expressionContext()
}

type Mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMintypmax_expressionContext() *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_mintypmax_expression
	return p
}

func (*Mintypmax_expressionContext) IsMintypmax_expressionContext() {}

func NewMintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_mintypmax_expression

	return p
}

func (s *Mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Mintypmax_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Mintypmax_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Mintypmax_expressionContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserColon)
}

func (s *Mintypmax_expressionContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, i)
}

func (s *Mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMintypmax_expression(s)
	}
}

func (s *Mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMintypmax_expression(s)
	}
}

func (p *VerilogParser) Mintypmax_expression() (localctx IMintypmax_expressionContext) {
	localctx = NewMintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, VerilogParserRULE_mintypmax_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3920)
		p.Expression()
	}
	p.SetState(3926)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserColon {
		{
			p.SetState(3921)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3922)
			p.Expression()
		}
		{
			p.SetState(3923)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3924)
			p.Expression()
		}

	}

	return localctx
}

// IModule_path_conditional_expressionContext is an interface to support dynamic dispatch.
type IModule_path_conditional_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_conditional_expressionContext differentiates from other interfaces.
	IsModule_path_conditional_expressionContext()
}

type Module_path_conditional_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_conditional_expressionContext() *Module_path_conditional_expressionContext {
	var p = new(Module_path_conditional_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_conditional_expression
	return p
}

func (*Module_path_conditional_expressionContext) IsModule_path_conditional_expressionContext() {}

func NewModule_path_conditional_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_conditional_expressionContext {
	var p = new(Module_path_conditional_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_conditional_expression

	return p
}

func (s *Module_path_conditional_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_conditional_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_conditional_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_conditional_expressionContext) Question_mark() antlr.TerminalNode {
	return s.GetToken(VerilogParserQuestion_mark, 0)
}

func (s *Module_path_conditional_expressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Module_path_conditional_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_path_conditional_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_path_conditional_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_conditional_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_conditional_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_conditional_expression(s)
	}
}

func (s *Module_path_conditional_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_conditional_expression(s)
	}
}

func (p *VerilogParser) Module_path_conditional_expression() (localctx IModule_path_conditional_expressionContext) {
	localctx = NewModule_path_conditional_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, VerilogParserRULE_module_path_conditional_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3928)
		p.Module_path_expression()
	}
	{
		p.SetState(3929)
		p.Match(VerilogParserQuestion_mark)
	}
	p.SetState(3933)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 430, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3930)
				p.Attribute_instance()
			}

		}
		p.SetState(3935)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 430, p.GetParserRuleContext())
	}
	{
		p.SetState(3936)
		p.Module_path_expression()
	}
	{
		p.SetState(3937)
		p.Match(VerilogParserColon)
	}
	{
		p.SetState(3938)
		p.Module_path_expression()
	}

	return localctx
}

// IModule_path_expressionContext is an interface to support dynamic dispatch.
type IModule_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_expressionContext differentiates from other interfaces.
	IsModule_path_expressionContext()
}

type Module_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_expressionContext() *Module_path_expressionContext {
	var p = new(Module_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_expression
	return p
}

func (*Module_path_expressionContext) IsModule_path_expressionContext() {}

func NewModule_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_expressionContext {
	var p = new(Module_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_expression

	return p
}

func (s *Module_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_expressionContext) Module_path_primary() IModule_path_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_primaryContext)
}

func (s *Module_path_expressionContext) Unary_module_path_operator() IUnary_module_path_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_module_path_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_module_path_operatorContext)
}

func (s *Module_path_expressionContext) AllBinary_module_path_operator() []IBinary_module_path_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBinary_module_path_operatorContext)(nil)).Elem())
	var tst = make([]IBinary_module_path_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBinary_module_path_operatorContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Binary_module_path_operator(i int) IBinary_module_path_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_module_path_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBinary_module_path_operatorContext)
}

func (s *Module_path_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_expressionContext) AllQuestion_mark() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserQuestion_mark)
}

func (s *Module_path_expressionContext) Question_mark(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserQuestion_mark, i)
}

func (s *Module_path_expressionContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserColon)
}

func (s *Module_path_expressionContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, i)
}

func (s *Module_path_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_expression(s)
	}
}

func (s *Module_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_expression(s)
	}
}

func (p *VerilogParser) Module_path_expression() (localctx IModule_path_expressionContext) {
	localctx = NewModule_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, VerilogParserRULE_module_path_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3950)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserK_FUNC_q_initialize, VerilogParserK_FUNC_q_remove, VerilogParserK_FUNC_q_full, VerilogParserK_FUNC_q_exam, VerilogParserK_FUNC_q_add, VerilogParserK_FUNC_realtime, VerilogParserK_FUNC_stime, VerilogParserK_FUNC_time, VerilogParserK_FUNC_shortrealtobits, VerilogParserK_FUNC_bitstoshortreal, VerilogParserK_FUNC_realtobits, VerilogParserK_FUNC_bitstoreal, VerilogParserK_FUNC_unsigned, VerilogParserK_FUNC_signed, VerilogParserK_FUNC_rtoi, VerilogParserK_FUNC_itor, VerilogParserK_FUNC_cast, VerilogParserK_FUNC_random, VerilogParserK_FUNC_dist_exponential, VerilogParserK_FUNC_dist_chi_square, VerilogParserK_FUNC_dist_uniform, VerilogParserK_FUNC_dist_poisson, VerilogParserK_FUNC_dist_normal, VerilogParserK_FUNC_dist_erlang, VerilogParserK_FUNC_dist_t, VerilogParserK_FUNC_test_plusargs, VerilogParserK_FUNC_value_plusargs, VerilogParserLeft_parenthes, VerilogParserLeft_brace, VerilogParserReal_number, VerilogParserDecimal_number, VerilogParserBinary_number, VerilogParserOctal_number, VerilogParserHex_number, VerilogParserEscaped_identifier, VerilogParserSimple_identifier:
		{
			p.SetState(3940)
			p.Module_path_primary()
		}

	case VerilogParserExclamation_mark, VerilogParserAND, VerilogParserVertical_line, VerilogParserTilda, VerilogParserHat:
		{
			p.SetState(3941)
			p.Unary_module_path_operator()
		}
		p.SetState(3945)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 431, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3942)
					p.Attribute_instance()
				}

			}
			p.SetState(3947)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 431, p.GetParserRuleContext())
		}
		{
			p.SetState(3948)
			p.Module_path_primary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3974)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 436, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3972)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case VerilogParserEq_eq, VerilogParserNot_eq, VerilogParserAND, VerilogParserVertical_line, VerilogParserTilda, VerilogParserHat:
				{
					p.SetState(3952)
					p.Binary_module_path_operator()
				}
				p.SetState(3956)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 433, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3953)
							p.Attribute_instance()
						}

					}
					p.SetState(3958)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 433, p.GetParserRuleContext())
				}
				{
					p.SetState(3959)
					p.Module_path_expression()
				}

			case VerilogParserQuestion_mark:
				{
					p.SetState(3961)
					p.Match(VerilogParserQuestion_mark)
				}
				p.SetState(3965)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 434, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3962)
							p.Attribute_instance()
						}

					}
					p.SetState(3967)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 434, p.GetParserRuleContext())
				}
				{
					p.SetState(3968)
					p.Module_path_expression()
				}
				{
					p.SetState(3969)
					p.Match(VerilogParserColon)
				}
				{
					p.SetState(3970)
					p.Module_path_expression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(3976)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 436, p.GetParserRuleContext())
	}

	return localctx
}

// IModule_path_mintypmax_expressionContext is an interface to support dynamic dispatch.
type IModule_path_mintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_mintypmax_expressionContext differentiates from other interfaces.
	IsModule_path_mintypmax_expressionContext()
}

type Module_path_mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_mintypmax_expressionContext() *Module_path_mintypmax_expressionContext {
	var p = new(Module_path_mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_mintypmax_expression
	return p
}

func (*Module_path_mintypmax_expressionContext) IsModule_path_mintypmax_expressionContext() {}

func NewModule_path_mintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_mintypmax_expressionContext {
	var p = new(Module_path_mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_mintypmax_expression

	return p
}

func (s *Module_path_mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_mintypmax_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_mintypmax_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_mintypmax_expressionContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserColon)
}

func (s *Module_path_mintypmax_expressionContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, i)
}

func (s *Module_path_mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_mintypmax_expression(s)
	}
}

func (s *Module_path_mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_mintypmax_expression(s)
	}
}

func (p *VerilogParser) Module_path_mintypmax_expression() (localctx IModule_path_mintypmax_expressionContext) {
	localctx = NewModule_path_mintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, VerilogParserRULE_module_path_mintypmax_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3977)
		p.Module_path_expression()
	}
	p.SetState(3983)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserColon {
		{
			p.SetState(3978)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3979)
			p.Module_path_expression()
		}
		{
			p.SetState(3980)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3981)
			p.Module_path_expression()
		}

	}

	return localctx
}

// IMsb_constant_expressionContext is an interface to support dynamic dispatch.
type IMsb_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMsb_constant_expressionContext differentiates from other interfaces.
	IsMsb_constant_expressionContext()
}

type Msb_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMsb_constant_expressionContext() *Msb_constant_expressionContext {
	var p = new(Msb_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_msb_constant_expression
	return p
}

func (*Msb_constant_expressionContext) IsMsb_constant_expressionContext() {}

func NewMsb_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Msb_constant_expressionContext {
	var p = new(Msb_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_msb_constant_expression

	return p
}

func (s *Msb_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Msb_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Msb_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Msb_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Msb_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMsb_constant_expression(s)
	}
}

func (s *Msb_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMsb_constant_expression(s)
	}
}

func (p *VerilogParser) Msb_constant_expression() (localctx IMsb_constant_expressionContext) {
	localctx = NewMsb_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, VerilogParserRULE_msb_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3985)
		p.Constant_expression()
	}

	return localctx
}

// IRange_expressionContext is an interface to support dynamic dispatch.
type IRange_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_expressionContext differentiates from other interfaces.
	IsRange_expressionContext()
}

type Range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_expressionContext() *Range_expressionContext {
	var p = new(Range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_range_expression
	return p
}

func (*Range_expressionContext) IsRange_expressionContext() {}

func NewRange_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_expressionContext {
	var p = new(Range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_range_expression

	return p
}

func (s *Range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Range_expressionContext) Msb_constant_expression() IMsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMsb_constant_expressionContext)
}

func (s *Range_expressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(VerilogParserColon, 0)
}

func (s *Range_expressionContext) Lsb_constant_expression() ILsb_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILsb_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILsb_constant_expressionContext)
}

func (s *Range_expressionContext) Base_expression() IBase_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_expressionContext)
}

func (s *Range_expressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(VerilogParserPlus, 0)
}

func (s *Range_expressionContext) Width_constant_expression() IWidth_constant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWidth_constant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWidth_constant_expressionContext)
}

func (s *Range_expressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(VerilogParserMinus, 0)
}

func (s *Range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterRange_expression(s)
	}
}

func (s *Range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitRange_expression(s)
	}
}

func (p *VerilogParser) Range_expression() (localctx IRange_expressionContext) {
	localctx = NewRange_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, VerilogParserRULE_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4002)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 438, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3987)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3988)
			p.Msb_constant_expression()
		}
		{
			p.SetState(3989)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3990)
			p.Lsb_constant_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3992)
			p.Base_expression()
		}
		{
			p.SetState(3993)
			p.Match(VerilogParserPlus)
		}
		{
			p.SetState(3994)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(3995)
			p.Width_constant_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3997)
			p.Base_expression()
		}
		{
			p.SetState(3998)
			p.Match(VerilogParserMinus)
		}
		{
			p.SetState(3999)
			p.Match(VerilogParserColon)
		}
		{
			p.SetState(4000)
			p.Width_constant_expression()
		}

	}

	return localctx
}

// IWidth_constant_expressionContext is an interface to support dynamic dispatch.
type IWidth_constant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWidth_constant_expressionContext differentiates from other interfaces.
	IsWidth_constant_expressionContext()
}

type Width_constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWidth_constant_expressionContext() *Width_constant_expressionContext {
	var p = new(Width_constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_width_constant_expression
	return p
}

func (*Width_constant_expressionContext) IsWidth_constant_expressionContext() {}

func NewWidth_constant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Width_constant_expressionContext {
	var p = new(Width_constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_width_constant_expression

	return p
}

func (s *Width_constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Width_constant_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Width_constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Width_constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Width_constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterWidth_constant_expression(s)
	}
}

func (s *Width_constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitWidth_constant_expression(s)
	}
}

func (p *VerilogParser) Width_constant_expression() (localctx IWidth_constant_expressionContext) {
	localctx = NewWidth_constant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, VerilogParserRULE_width_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4004)
		p.Constant_expression()
	}

	return localctx
}

// IConstant_primaryContext is an interface to support dynamic dispatch.
type IConstant_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_primaryContext differentiates from other interfaces.
	IsConstant_primaryContext()
}

type Constant_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_primaryContext() *Constant_primaryContext {
	var p = new(Constant_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_constant_primary
	return p
}

func (*Constant_primaryContext) IsConstant_primaryContext() {}

func NewConstant_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_primaryContext {
	var p = new(Constant_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_constant_primary

	return p
}

func (s *Constant_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_primaryContext) Constant_concatenation() IConstant_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_concatenationContext)
}

func (s *Constant_primaryContext) Constant_function_call() IConstant_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_function_callContext)
}

func (s *Constant_primaryContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Constant_primaryContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Constant_primaryContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Constant_primaryContext) Constant_multiple_concatenation() IConstant_multiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_multiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_multiple_concatenationContext)
}

func (s *Constant_primaryContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Constant_primaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Constant_primaryContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Constant_primaryContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Constant_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConstant_primary(s)
	}
}

func (s *Constant_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConstant_primary(s)
	}
}

func (p *VerilogParser) Constant_primary() (localctx IConstant_primaryContext) {
	localctx = NewConstant_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, VerilogParserRULE_constant_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4017)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 439, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4006)
			p.Constant_concatenation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4007)
			p.Constant_function_call()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4008)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(4009)
			p.Constant_mintypmax_expression()
		}
		{
			p.SetState(4010)
			p.Match(VerilogParserRight_parenthes)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4012)
			p.Constant_multiple_concatenation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4013)
			p.Genvar_identifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4014)
			p.Number()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4015)
			p.Parameter_identifier()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4016)
			p.Specparam_identifier()
		}

	}

	return localctx
}

// IModule_path_primaryContext is an interface to support dynamic dispatch.
type IModule_path_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_primaryContext differentiates from other interfaces.
	IsModule_path_primaryContext()
}

type Module_path_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_primaryContext() *Module_path_primaryContext {
	var p = new(Module_path_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_path_primary
	return p
}

func (*Module_path_primaryContext) IsModule_path_primaryContext() {}

func NewModule_path_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_primaryContext {
	var p = new(Module_path_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_path_primary

	return p
}

func (s *Module_path_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_primaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Module_path_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_path_primaryContext) Module_path_concatenation() IModule_path_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_concatenationContext)
}

func (s *Module_path_primaryContext) Module_path_multiple_concatenation() IModule_path_multiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_multiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_multiple_concatenationContext)
}

func (s *Module_path_primaryContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *Module_path_primaryContext) System_function_call() ISystem_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_callContext)
}

func (s *Module_path_primaryContext) Constant_function_call() IConstant_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_function_callContext)
}

func (s *Module_path_primaryContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Module_path_primaryContext) Module_path_mintypmax_expression() IModule_path_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_mintypmax_expressionContext)
}

func (s *Module_path_primaryContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Module_path_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_path_primary(s)
	}
}

func (s *Module_path_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_path_primary(s)
	}
}

func (p *VerilogParser) Module_path_primary() (localctx IModule_path_primaryContext) {
	localctx = NewModule_path_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, VerilogParserRULE_module_path_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4030)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 440, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4019)
			p.Number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4020)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4021)
			p.Module_path_concatenation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4022)
			p.Module_path_multiple_concatenation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4023)
			p.Function_call()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4024)
			p.System_function_call()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4025)
			p.Constant_function_call()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4026)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(4027)
			p.Module_path_mintypmax_expression()
		}
		{
			p.SetState(4028)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *PrimaryContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *PrimaryContext) AllLeft_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_bracket)
}

func (s *PrimaryContext) Left_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, i)
}

func (s *PrimaryContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PrimaryContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) AllRight_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_bracket)
}

func (s *PrimaryContext) Right_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, i)
}

func (s *PrimaryContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *PrimaryContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *PrimaryContext) Multiple_concatenation() IMultiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiple_concatenationContext)
}

func (s *PrimaryContext) Function_call() IFunction_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_callContext)
}

func (s *PrimaryContext) System_function_call() ISystem_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_function_callContext)
}

func (s *PrimaryContext) Constant_function_call() IConstant_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_function_callContext)
}

func (s *PrimaryContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *PrimaryContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *PrimaryContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *VerilogParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, VerilogParserRULE_primary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(4070)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 443, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4032)
			p.Number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4033)
			p.Hierarchical_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4034)
			p.Hierarchical_identifier()
		}
		p.SetState(4039)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == VerilogParserLeft_bracket {
			{
				p.SetState(4035)
				p.Match(VerilogParserLeft_bracket)
			}
			{
				p.SetState(4036)
				p.Expression()
			}
			{
				p.SetState(4037)
				p.Match(VerilogParserRight_bracket)
			}

			p.SetState(4041)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4043)
			p.Hierarchical_identifier()
		}
		p.SetState(4048)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4044)
					p.Match(VerilogParserLeft_bracket)
				}
				{
					p.SetState(4045)
					p.Expression()
				}
				{
					p.SetState(4046)
					p.Match(VerilogParserRight_bracket)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(4050)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 442, p.GetParserRuleContext())
		}
		{
			p.SetState(4052)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4053)
			p.Range_expression()
		}
		{
			p.SetState(4054)
			p.Match(VerilogParserRight_bracket)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4056)
			p.Hierarchical_identifier()
		}
		{
			p.SetState(4057)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4058)
			p.Range_expression()
		}
		{
			p.SetState(4059)
			p.Match(VerilogParserRight_bracket)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4061)
			p.Concatenation()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4062)
			p.Multiple_concatenation()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4063)
			p.Function_call()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4064)
			p.System_function_call()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4065)
			p.Constant_function_call()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4066)
			p.Match(VerilogParserLeft_parenthes)
		}
		{
			p.SetState(4067)
			p.Mintypmax_expression()
		}
		{
			p.SetState(4068)
			p.Match(VerilogParserRight_parenthes)
		}

	}

	return localctx
}

// INet_lvalueContext is an interface to support dynamic dispatch.
type INet_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_lvalueContext differentiates from other interfaces.
	IsNet_lvalueContext()
}

type Net_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_lvalueContext() *Net_lvalueContext {
	var p = new(Net_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_lvalue
	return p
}

func (*Net_lvalueContext) IsNet_lvalueContext() {}

func NewNet_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_lvalueContext {
	var p = new(Net_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_lvalue

	return p
}

func (s *Net_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_lvalueContext) Hierarchical_net_identifier() IHierarchical_net_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_net_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_net_identifierContext)
}

func (s *Net_lvalueContext) AllLeft_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_bracket)
}

func (s *Net_lvalueContext) Left_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, i)
}

func (s *Net_lvalueContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Net_lvalueContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Net_lvalueContext) AllRight_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_bracket)
}

func (s *Net_lvalueContext) Right_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, i)
}

func (s *Net_lvalueContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Net_lvalueContext) Net_concatenation() INet_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_concatenationContext)
}

func (s *Net_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_lvalue(s)
	}
}

func (s *Net_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_lvalue(s)
	}
}

func (p *VerilogParser) Net_lvalue() (localctx INet_lvalueContext) {
	localctx = NewNet_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, VerilogParserRULE_net_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(4109)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 446, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4072)
			p.Hierarchical_net_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4073)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(4074)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4075)
			p.Constant_expression()
		}
		{
			p.SetState(4076)
			p.Match(VerilogParserRight_bracket)
		}
		p.SetState(4083)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_bracket {
			{
				p.SetState(4077)
				p.Match(VerilogParserLeft_bracket)
			}
			{
				p.SetState(4078)
				p.Constant_expression()
			}
			{
				p.SetState(4079)
				p.Match(VerilogParserRight_bracket)
			}

			p.SetState(4085)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4086)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(4087)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4088)
			p.Constant_expression()
		}
		{
			p.SetState(4089)
			p.Match(VerilogParserRight_bracket)
		}
		p.SetState(4096)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 445, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4090)
					p.Match(VerilogParserLeft_bracket)
				}
				{
					p.SetState(4091)
					p.Constant_expression()
				}
				{
					p.SetState(4092)
					p.Match(VerilogParserRight_bracket)
				}

			}
			p.SetState(4098)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 445, p.GetParserRuleContext())
		}
		{
			p.SetState(4099)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4100)
			p.Constant_range_expression()
		}
		{
			p.SetState(4101)
			p.Match(VerilogParserRight_bracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4103)
			p.Hierarchical_net_identifier()
		}
		{
			p.SetState(4104)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4105)
			p.Constant_range_expression()
		}
		{
			p.SetState(4106)
			p.Match(VerilogParserRight_bracket)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4108)
			p.Net_concatenation()
		}

	}

	return localctx
}

// IVariable_lvalueContext is an interface to support dynamic dispatch.
type IVariable_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_lvalueContext differentiates from other interfaces.
	IsVariable_lvalueContext()
}

type Variable_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_lvalueContext() *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_lvalue
	return p
}

func (*Variable_lvalueContext) IsVariable_lvalueContext() {}

func NewVariable_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_lvalue

	return p
}

func (s *Variable_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_lvalueContext) Hierarchical_variable_identifier() IHierarchical_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_identifierContext)
}

func (s *Variable_lvalueContext) AllLeft_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_bracket)
}

func (s *Variable_lvalueContext) Left_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, i)
}

func (s *Variable_lvalueContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Variable_lvalueContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_lvalueContext) AllRight_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_bracket)
}

func (s *Variable_lvalueContext) Right_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, i)
}

func (s *Variable_lvalueContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Variable_lvalueContext) Variable_concatenation() IVariable_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_concatenationContext)
}

func (s *Variable_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_lvalue(s)
	}
}

func (s *Variable_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_lvalue(s)
	}
}

func (p *VerilogParser) Variable_lvalue() (localctx IVariable_lvalueContext) {
	localctx = NewVariable_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, VerilogParserRULE_variable_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(4148)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 449, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4111)
			p.Hierarchical_variable_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4112)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(4113)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4114)
			p.Expression()
		}
		{
			p.SetState(4115)
			p.Match(VerilogParserRight_bracket)
		}
		p.SetState(4122)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == VerilogParserLeft_bracket {
			{
				p.SetState(4116)
				p.Match(VerilogParserLeft_bracket)
			}
			{
				p.SetState(4117)
				p.Expression()
			}
			{
				p.SetState(4118)
				p.Match(VerilogParserRight_bracket)
			}

			p.SetState(4124)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4125)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(4126)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4127)
			p.Expression()
		}
		{
			p.SetState(4128)
			p.Match(VerilogParserRight_bracket)
		}
		p.SetState(4135)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 448, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4129)
					p.Match(VerilogParserLeft_bracket)
				}
				{
					p.SetState(4130)
					p.Expression()
				}
				{
					p.SetState(4131)
					p.Match(VerilogParserRight_bracket)
				}

			}
			p.SetState(4137)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 448, p.GetParserRuleContext())
		}
		{
			p.SetState(4138)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4139)
			p.Range_expression()
		}
		{
			p.SetState(4140)
			p.Match(VerilogParserRight_bracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4142)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(4143)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4144)
			p.Range_expression()
		}
		{
			p.SetState(4145)
			p.Match(VerilogParserRight_bracket)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4147)
			p.Variable_concatenation()
		}

	}

	return localctx
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_operatorContext) Plus() antlr.TerminalNode {
	return s.GetToken(VerilogParserPlus, 0)
}

func (s *Unary_operatorContext) Minus() antlr.TerminalNode {
	return s.GetToken(VerilogParserMinus, 0)
}

func (s *Unary_operatorContext) Exclamation_mark() antlr.TerminalNode {
	return s.GetToken(VerilogParserExclamation_mark, 0)
}

func (s *Unary_operatorContext) Tilda() antlr.TerminalNode {
	return s.GetToken(VerilogParserTilda, 0)
}

func (s *Unary_operatorContext) AND() antlr.TerminalNode {
	return s.GetToken(VerilogParserAND, 0)
}

func (s *Unary_operatorContext) Vertical_line() antlr.TerminalNode {
	return s.GetToken(VerilogParserVertical_line, 0)
}

func (s *Unary_operatorContext) Hat() antlr.TerminalNode {
	return s.GetToken(VerilogParserHat, 0)
}

func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (p *VerilogParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, VerilogParserRULE_unary_operator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4165)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 450, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4150)
			p.Match(VerilogParserPlus)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4151)
			p.Match(VerilogParserMinus)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4152)
			p.Match(VerilogParserExclamation_mark)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4153)
			p.Match(VerilogParserTilda)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4154)
			p.Match(VerilogParserAND)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4155)
			p.Match(VerilogParserTilda)
		}
		{
			p.SetState(4156)
			p.Match(VerilogParserAND)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4157)
			p.Match(VerilogParserVertical_line)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4158)
			p.Match(VerilogParserTilda)
		}
		{
			p.SetState(4159)
			p.Match(VerilogParserVertical_line)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4160)
			p.Match(VerilogParserHat)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4161)
			p.Match(VerilogParserTilda)
		}
		{
			p.SetState(4162)
			p.Match(VerilogParserHat)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4163)
			p.Match(VerilogParserHat)
		}
		{
			p.SetState(4164)
			p.Match(VerilogParserTilda)
		}

	}

	return localctx
}

// IBinary_operatorContext is an interface to support dynamic dispatch.
type IBinary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_operatorContext differentiates from other interfaces.
	IsBinary_operatorContext()
}

type Binary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_operatorContext() *Binary_operatorContext {
	var p = new(Binary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_binary_operator
	return p
}

func (*Binary_operatorContext) IsBinary_operatorContext() {}

func NewBinary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_operatorContext {
	var p = new(Binary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_binary_operator

	return p
}

func (s *Binary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Binary_operatorContext) Plus() antlr.TerminalNode {
	return s.GetToken(VerilogParserPlus, 0)
}

func (s *Binary_operatorContext) Minus() antlr.TerminalNode {
	return s.GetToken(VerilogParserMinus, 0)
}

func (s *Binary_operatorContext) AllAsterisk() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserAsterisk)
}

func (s *Binary_operatorContext) Asterisk(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserAsterisk, i)
}

func (s *Binary_operatorContext) Slash() antlr.TerminalNode {
	return s.GetToken(VerilogParserSlash, 0)
}

func (s *Binary_operatorContext) Percent() antlr.TerminalNode {
	return s.GetToken(VerilogParserPercent, 0)
}

func (s *Binary_operatorContext) Eq_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq_eq, 0)
}

func (s *Binary_operatorContext) Not_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserNot_eq, 0)
}

func (s *Binary_operatorContext) Eq_eq_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq_eq_eq, 0)
}

func (s *Binary_operatorContext) Not_eq_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserNot_eq_eq, 0)
}

func (s *Binary_operatorContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserAND)
}

func (s *Binary_operatorContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserAND, i)
}

func (s *Binary_operatorContext) AllVertical_line() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserVertical_line)
}

func (s *Binary_operatorContext) Vertical_line(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserVertical_line, i)
}

func (s *Binary_operatorContext) AllLeft_angle_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_angle_bracket)
}

func (s *Binary_operatorContext) Left_angle_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_angle_bracket, i)
}

func (s *Binary_operatorContext) Left_angle_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_angle_eq, 0)
}

func (s *Binary_operatorContext) AllRight_angle_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_angle_bracket)
}

func (s *Binary_operatorContext) Right_angle_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_angle_bracket, i)
}

func (s *Binary_operatorContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Binary_operatorContext) Hat() antlr.TerminalNode {
	return s.GetToken(VerilogParserHat, 0)
}

func (s *Binary_operatorContext) Tilda() antlr.TerminalNode {
	return s.GetToken(VerilogParserTilda, 0)
}

func (s *Binary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBinary_operator(s)
	}
}

func (s *Binary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBinary_operator(s)
	}
}

func (p *VerilogParser) Binary_operator() (localctx IBinary_operatorContext) {
	localctx = NewBinary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, VerilogParserRULE_binary_operator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4204)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 451, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4167)
			p.Match(VerilogParserPlus)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4168)
			p.Match(VerilogParserMinus)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4169)
			p.Match(VerilogParserAsterisk)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4170)
			p.Match(VerilogParserSlash)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4171)
			p.Match(VerilogParserPercent)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4172)
			p.Match(VerilogParserEq_eq)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4173)
			p.Match(VerilogParserNot_eq)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4174)
			p.Match(VerilogParserEq_eq_eq)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4175)
			p.Match(VerilogParserNot_eq_eq)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4176)
			p.Match(VerilogParserAND)
		}
		{
			p.SetState(4177)
			p.Match(VerilogParserAND)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4178)
			p.Match(VerilogParserVertical_line)
		}
		{
			p.SetState(4179)
			p.Match(VerilogParserVertical_line)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4180)
			p.Match(VerilogParserAsterisk)
		}
		{
			p.SetState(4181)
			p.Match(VerilogParserAsterisk)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4182)
			p.Match(VerilogParserLeft_angle_bracket)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4183)
			p.Match(VerilogParserLeft_angle_eq)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4184)
			p.Match(VerilogParserRight_angle_bracket)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(4185)
			p.Match(VerilogParserRight_angle_bracket)
		}
		{
			p.SetState(4186)
			p.Match(VerilogParserEq)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(4187)
			p.Match(VerilogParserAND)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(4188)
			p.Match(VerilogParserVertical_line)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(4189)
			p.Match(VerilogParserHat)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(4190)
			p.Match(VerilogParserHat)
		}
		{
			p.SetState(4191)
			p.Match(VerilogParserTilda)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(4192)
			p.Match(VerilogParserTilda)
		}
		{
			p.SetState(4193)
			p.Match(VerilogParserHat)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(4194)
			p.Match(VerilogParserRight_angle_bracket)
		}
		{
			p.SetState(4195)
			p.Match(VerilogParserRight_angle_bracket)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(4196)
			p.Match(VerilogParserLeft_angle_bracket)
		}
		{
			p.SetState(4197)
			p.Match(VerilogParserLeft_angle_bracket)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(4198)
			p.Match(VerilogParserRight_angle_bracket)
		}
		{
			p.SetState(4199)
			p.Match(VerilogParserRight_angle_bracket)
		}
		{
			p.SetState(4200)
			p.Match(VerilogParserRight_angle_bracket)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(4201)
			p.Match(VerilogParserLeft_angle_bracket)
		}
		{
			p.SetState(4202)
			p.Match(VerilogParserLeft_angle_bracket)
		}
		{
			p.SetState(4203)
			p.Match(VerilogParserLeft_angle_bracket)
		}

	}

	return localctx
}

// IUnary_module_path_operatorContext is an interface to support dynamic dispatch.
type IUnary_module_path_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_module_path_operatorContext differentiates from other interfaces.
	IsUnary_module_path_operatorContext()
}

type Unary_module_path_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_module_path_operatorContext() *Unary_module_path_operatorContext {
	var p = new(Unary_module_path_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_unary_module_path_operator
	return p
}

func (*Unary_module_path_operatorContext) IsUnary_module_path_operatorContext() {}

func NewUnary_module_path_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_module_path_operatorContext {
	var p = new(Unary_module_path_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_unary_module_path_operator

	return p
}

func (s *Unary_module_path_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_module_path_operatorContext) Exclamation_mark() antlr.TerminalNode {
	return s.GetToken(VerilogParserExclamation_mark, 0)
}

func (s *Unary_module_path_operatorContext) Tilda() antlr.TerminalNode {
	return s.GetToken(VerilogParserTilda, 0)
}

func (s *Unary_module_path_operatorContext) AND() antlr.TerminalNode {
	return s.GetToken(VerilogParserAND, 0)
}

func (s *Unary_module_path_operatorContext) Vertical_line() antlr.TerminalNode {
	return s.GetToken(VerilogParserVertical_line, 0)
}

func (s *Unary_module_path_operatorContext) Hat() antlr.TerminalNode {
	return s.GetToken(VerilogParserHat, 0)
}

func (s *Unary_module_path_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_module_path_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_module_path_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUnary_module_path_operator(s)
	}
}

func (s *Unary_module_path_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUnary_module_path_operator(s)
	}
}

func (p *VerilogParser) Unary_module_path_operator() (localctx IUnary_module_path_operatorContext) {
	localctx = NewUnary_module_path_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, VerilogParserRULE_unary_module_path_operator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4219)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 452, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4206)
			p.Match(VerilogParserExclamation_mark)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4207)
			p.Match(VerilogParserTilda)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4208)
			p.Match(VerilogParserAND)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4209)
			p.Match(VerilogParserTilda)
		}
		{
			p.SetState(4210)
			p.Match(VerilogParserAND)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4211)
			p.Match(VerilogParserVertical_line)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4212)
			p.Match(VerilogParserTilda)
		}
		{
			p.SetState(4213)
			p.Match(VerilogParserVertical_line)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4214)
			p.Match(VerilogParserHat)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4215)
			p.Match(VerilogParserTilda)
		}
		{
			p.SetState(4216)
			p.Match(VerilogParserHat)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4217)
			p.Match(VerilogParserHat)
		}
		{
			p.SetState(4218)
			p.Match(VerilogParserTilda)
		}

	}

	return localctx
}

// IBinary_module_path_operatorContext is an interface to support dynamic dispatch.
type IBinary_module_path_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_module_path_operatorContext differentiates from other interfaces.
	IsBinary_module_path_operatorContext()
}

type Binary_module_path_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_module_path_operatorContext() *Binary_module_path_operatorContext {
	var p = new(Binary_module_path_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_binary_module_path_operator
	return p
}

func (*Binary_module_path_operatorContext) IsBinary_module_path_operatorContext() {}

func NewBinary_module_path_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_module_path_operatorContext {
	var p = new(Binary_module_path_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_binary_module_path_operator

	return p
}

func (s *Binary_module_path_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Binary_module_path_operatorContext) Eq_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq_eq, 0)
}

func (s *Binary_module_path_operatorContext) Not_eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserNot_eq, 0)
}

func (s *Binary_module_path_operatorContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserAND)
}

func (s *Binary_module_path_operatorContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserAND, i)
}

func (s *Binary_module_path_operatorContext) AllVertical_line() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserVertical_line)
}

func (s *Binary_module_path_operatorContext) Vertical_line(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserVertical_line, i)
}

func (s *Binary_module_path_operatorContext) Hat() antlr.TerminalNode {
	return s.GetToken(VerilogParserHat, 0)
}

func (s *Binary_module_path_operatorContext) Tilda() antlr.TerminalNode {
	return s.GetToken(VerilogParserTilda, 0)
}

func (s *Binary_module_path_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_module_path_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_module_path_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBinary_module_path_operator(s)
	}
}

func (s *Binary_module_path_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBinary_module_path_operator(s)
	}
}

func (p *VerilogParser) Binary_module_path_operator() (localctx IBinary_module_path_operatorContext) {
	localctx = NewBinary_module_path_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, VerilogParserRULE_binary_module_path_operator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4234)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 453, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4221)
			p.Match(VerilogParserEq_eq)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4222)
			p.Match(VerilogParserNot_eq)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4223)
			p.Match(VerilogParserAND)
		}
		{
			p.SetState(4224)
			p.Match(VerilogParserAND)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4225)
			p.Match(VerilogParserVertical_line)
		}
		{
			p.SetState(4226)
			p.Match(VerilogParserVertical_line)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4227)
			p.Match(VerilogParserAND)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4228)
			p.Match(VerilogParserVertical_line)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4229)
			p.Match(VerilogParserHat)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4230)
			p.Match(VerilogParserHat)
		}
		{
			p.SetState(4231)
			p.Match(VerilogParserTilda)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4232)
			p.Match(VerilogParserTilda)
		}
		{
			p.SetState(4233)
			p.Match(VerilogParserHat)
		}

	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Decimal_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserDecimal_number, 0)
}

func (s *NumberContext) Octal_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserOctal_number, 0)
}

func (s *NumberContext) Binary_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserBinary_number, 0)
}

func (s *NumberContext) Hex_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserHex_number, 0)
}

func (s *NumberContext) Real_number() antlr.TerminalNode {
	return s.GetToken(VerilogParserReal_number, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *VerilogParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, VerilogParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4236)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-288)&-(0x1f+1)) == 0 && ((1<<uint((_la-288)))&((1<<(VerilogParserReal_number-288))|(1<<(VerilogParserDecimal_number-288))|(1<<(VerilogParserBinary_number-288))|(1<<(VerilogParserOctal_number-288))|(1<<(VerilogParserHex_number-288)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAttribute_instanceContext is an interface to support dynamic dispatch.
type IAttribute_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_instanceContext differentiates from other interfaces.
	IsAttribute_instanceContext()
}

type Attribute_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_instanceContext() *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_attribute_instance
	return p
}

func (*Attribute_instanceContext) IsAttribute_instanceContext() {}

func NewAttribute_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_attribute_instance

	return p
}

func (s *Attribute_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_instanceContext) Left_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_parenthes, 0)
}

func (s *Attribute_instanceContext) AllAsterisk() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserAsterisk)
}

func (s *Attribute_instanceContext) Asterisk(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserAsterisk, i)
}

func (s *Attribute_instanceContext) AllAttr_spec() []IAttr_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttr_specContext)(nil)).Elem())
	var tst = make([]IAttr_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttr_specContext)
		}
	}

	return tst
}

func (s *Attribute_instanceContext) Attr_spec(i int) IAttr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttr_specContext)
}

func (s *Attribute_instanceContext) Right_parenthes() antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_parenthes, 0)
}

func (s *Attribute_instanceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserComma)
}

func (s *Attribute_instanceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserComma, i)
}

func (s *Attribute_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterAttribute_instance(s)
	}
}

func (s *Attribute_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitAttribute_instance(s)
	}
}

func (p *VerilogParser) Attribute_instance() (localctx IAttribute_instanceContext) {
	localctx = NewAttribute_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, VerilogParserRULE_attribute_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4238)
		p.Match(VerilogParserLeft_parenthes)
	}
	{
		p.SetState(4239)
		p.Match(VerilogParserAsterisk)
	}
	{
		p.SetState(4240)
		p.Attr_spec()
	}
	p.SetState(4245)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserComma {
		{
			p.SetState(4241)
			p.Match(VerilogParserComma)
		}
		{
			p.SetState(4242)
			p.Attr_spec()
		}

		p.SetState(4247)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4248)
		p.Match(VerilogParserAsterisk)
	}
	{
		p.SetState(4249)
		p.Match(VerilogParserRight_parenthes)
	}

	return localctx
}

// IAttr_specContext is an interface to support dynamic dispatch.
type IAttr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_specContext differentiates from other interfaces.
	IsAttr_specContext()
}

type Attr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_specContext() *Attr_specContext {
	var p = new(Attr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_attr_spec
	return p
}

func (*Attr_specContext) IsAttr_specContext() {}

func NewAttr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_specContext {
	var p = new(Attr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_attr_spec

	return p
}

func (s *Attr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_specContext) Attr_name() IAttr_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_nameContext)
}

func (s *Attr_specContext) Eq() antlr.TerminalNode {
	return s.GetToken(VerilogParserEq, 0)
}

func (s *Attr_specContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Attr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterAttr_spec(s)
	}
}

func (s *Attr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitAttr_spec(s)
	}
}

func (p *VerilogParser) Attr_spec() (localctx IAttr_specContext) {
	localctx = NewAttr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, VerilogParserRULE_attr_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4256)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 455, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4251)
			p.Attr_name()
		}
		{
			p.SetState(4252)
			p.Match(VerilogParserEq)
		}
		{
			p.SetState(4253)
			p.Constant_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4255)
			p.Attr_name()
		}

	}

	return localctx
}

// IAttr_nameContext is an interface to support dynamic dispatch.
type IAttr_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_nameContext differentiates from other interfaces.
	IsAttr_nameContext()
}

type Attr_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_nameContext() *Attr_nameContext {
	var p = new(Attr_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_attr_name
	return p
}

func (*Attr_nameContext) IsAttr_nameContext() {}

func NewAttr_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_nameContext {
	var p = new(Attr_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_attr_name

	return p
}

func (s *Attr_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Attr_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterAttr_name(s)
	}
}

func (s *Attr_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitAttr_name(s)
	}
}

func (p *VerilogParser) Attr_name() (localctx IAttr_nameContext) {
	localctx = NewAttr_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, VerilogParserRULE_attr_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4258)
		p.Identifier()
	}

	return localctx
}

// IArrayed_identifierContext is an interface to support dynamic dispatch.
type IArrayed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayed_identifierContext differentiates from other interfaces.
	IsArrayed_identifierContext()
}

type Arrayed_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayed_identifierContext() *Arrayed_identifierContext {
	var p = new(Arrayed_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_arrayed_identifier
	return p
}

func (*Arrayed_identifierContext) IsArrayed_identifierContext() {}

func NewArrayed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arrayed_identifierContext {
	var p = new(Arrayed_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_arrayed_identifier

	return p
}

func (s *Arrayed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Arrayed_identifierContext) Simple_arrayed_identifier() ISimple_arrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_arrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_arrayed_identifierContext)
}

func (s *Arrayed_identifierContext) Escaped_arrayed_identifier() IEscaped_arrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscaped_arrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEscaped_arrayed_identifierContext)
}

func (s *Arrayed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arrayed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arrayed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterArrayed_identifier(s)
	}
}

func (s *Arrayed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitArrayed_identifier(s)
	}
}

func (p *VerilogParser) Arrayed_identifier() (localctx IArrayed_identifierContext) {
	localctx = NewArrayed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, VerilogParserRULE_arrayed_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4262)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4260)
			p.Simple_arrayed_identifier()
		}

	case VerilogParserEscaped_identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4261)
			p.Escaped_arrayed_identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBlock_identifierContext is an interface to support dynamic dispatch.
type IBlock_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_identifierContext differentiates from other interfaces.
	IsBlock_identifierContext()
}

type Block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_identifierContext() *Block_identifierContext {
	var p = new(Block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_block_identifier
	return p
}

func (*Block_identifierContext) IsBlock_identifierContext() {}

func NewBlock_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_identifierContext {
	var p = new(Block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_block_identifier

	return p
}

func (s *Block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterBlock_identifier(s)
	}
}

func (s *Block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitBlock_identifier(s)
	}
}

func (p *VerilogParser) Block_identifier() (localctx IBlock_identifierContext) {
	localctx = NewBlock_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, VerilogParserRULE_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4264)
		p.Identifier()
	}

	return localctx
}

// ICell_identifierContext is an interface to support dynamic dispatch.
type ICell_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_identifierContext differentiates from other interfaces.
	IsCell_identifierContext()
}

type Cell_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_identifierContext() *Cell_identifierContext {
	var p = new(Cell_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_cell_identifier
	return p
}

func (*Cell_identifierContext) IsCell_identifierContext() {}

func NewCell_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_identifierContext {
	var p = new(Cell_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_cell_identifier

	return p
}

func (s *Cell_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cell_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterCell_identifier(s)
	}
}

func (s *Cell_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitCell_identifier(s)
	}
}

func (p *VerilogParser) Cell_identifier() (localctx ICell_identifierContext) {
	localctx = NewCell_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, VerilogParserRULE_cell_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4266)
		p.Identifier()
	}

	return localctx
}

// IConfig_identifierContext is an interface to support dynamic dispatch.
type IConfig_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_identifierContext differentiates from other interfaces.
	IsConfig_identifierContext()
}

type Config_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_identifierContext() *Config_identifierContext {
	var p = new(Config_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_config_identifier
	return p
}

func (*Config_identifierContext) IsConfig_identifierContext() {}

func NewConfig_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_identifierContext {
	var p = new(Config_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_config_identifier

	return p
}

func (s *Config_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Config_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterConfig_identifier(s)
	}
}

func (s *Config_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitConfig_identifier(s)
	}
}

func (p *VerilogParser) Config_identifier() (localctx IConfig_identifierContext) {
	localctx = NewConfig_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, VerilogParserRULE_config_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4268)
		p.Identifier()
	}

	return localctx
}

// IEscaped_arrayed_identifierContext is an interface to support dynamic dispatch.
type IEscaped_arrayed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscaped_arrayed_identifierContext differentiates from other interfaces.
	IsEscaped_arrayed_identifierContext()
}

type Escaped_arrayed_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscaped_arrayed_identifierContext() *Escaped_arrayed_identifierContext {
	var p = new(Escaped_arrayed_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_escaped_arrayed_identifier
	return p
}

func (*Escaped_arrayed_identifierContext) IsEscaped_arrayed_identifierContext() {}

func NewEscaped_arrayed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Escaped_arrayed_identifierContext {
	var p = new(Escaped_arrayed_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_escaped_arrayed_identifier

	return p
}

func (s *Escaped_arrayed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Escaped_arrayed_identifierContext) Escaped_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserEscaped_identifier, 0)
}

func (s *Escaped_arrayed_identifierContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Escaped_arrayed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Escaped_arrayed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Escaped_arrayed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEscaped_arrayed_identifier(s)
	}
}

func (s *Escaped_arrayed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEscaped_arrayed_identifier(s)
	}
}

func (p *VerilogParser) Escaped_arrayed_identifier() (localctx IEscaped_arrayed_identifierContext) {
	localctx = NewEscaped_arrayed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, VerilogParserRULE_escaped_arrayed_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4270)
		p.Match(VerilogParserEscaped_identifier)
	}
	p.SetState(4272)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 457, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4271)
			p.Range_()
		}

	}

	return localctx
}

// IEscaped_hierarchical_identifierContext is an interface to support dynamic dispatch.
type IEscaped_hierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscaped_hierarchical_identifierContext differentiates from other interfaces.
	IsEscaped_hierarchical_identifierContext()
}

type Escaped_hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscaped_hierarchical_identifierContext() *Escaped_hierarchical_identifierContext {
	var p = new(Escaped_hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_escaped_hierarchical_identifier
	return p
}

func (*Escaped_hierarchical_identifierContext) IsEscaped_hierarchical_identifierContext() {}

func NewEscaped_hierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Escaped_hierarchical_identifierContext {
	var p = new(Escaped_hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_escaped_hierarchical_identifier

	return p
}

func (s *Escaped_hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Escaped_hierarchical_identifierContext) AllEscaped_hierarchical_branch() []IEscaped_hierarchical_branchContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscaped_hierarchical_branchContext)(nil)).Elem())
	var tst = make([]IEscaped_hierarchical_branchContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscaped_hierarchical_branchContext)
		}
	}

	return tst
}

func (s *Escaped_hierarchical_identifierContext) Escaped_hierarchical_branch(i int) IEscaped_hierarchical_branchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscaped_hierarchical_branchContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscaped_hierarchical_branchContext)
}

func (s *Escaped_hierarchical_identifierContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDot)
}

func (s *Escaped_hierarchical_identifierContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, i)
}

func (s *Escaped_hierarchical_identifierContext) AllSimple_hierarchical_branch() []ISimple_hierarchical_branchContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_hierarchical_branchContext)(nil)).Elem())
	var tst = make([]ISimple_hierarchical_branchContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_hierarchical_branchContext)
		}
	}

	return tst
}

func (s *Escaped_hierarchical_identifierContext) Simple_hierarchical_branch(i int) ISimple_hierarchical_branchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_hierarchical_branchContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_hierarchical_branchContext)
}

func (s *Escaped_hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Escaped_hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Escaped_hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEscaped_hierarchical_identifier(s)
	}
}

func (s *Escaped_hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEscaped_hierarchical_identifier(s)
	}
}

func (p *VerilogParser) Escaped_hierarchical_identifier() (localctx IEscaped_hierarchical_identifierContext) {
	localctx = NewEscaped_hierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, VerilogParserRULE_escaped_hierarchical_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4274)
		p.Escaped_hierarchical_branch()
	}
	p.SetState(4281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == VerilogParserDot {
		p.SetState(4279)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 458, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4275)
				p.Match(VerilogParserDot)
			}
			{
				p.SetState(4276)
				p.Simple_hierarchical_branch()
			}

		case 2:
			{
				p.SetState(4277)
				p.Match(VerilogParserDot)
			}
			{
				p.SetState(4278)
				p.Escaped_hierarchical_branch()
			}

		}

		p.SetState(4283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEvent_identifierContext is an interface to support dynamic dispatch.
type IEvent_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_identifierContext differentiates from other interfaces.
	IsEvent_identifierContext()
}

type Event_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_identifierContext() *Event_identifierContext {
	var p = new(Event_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_event_identifier
	return p
}

func (*Event_identifierContext) IsEvent_identifierContext() {}

func NewEvent_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_identifierContext {
	var p = new(Event_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_event_identifier

	return p
}

func (s *Event_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Event_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEvent_identifier(s)
	}
}

func (s *Event_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEvent_identifier(s)
	}
}

func (p *VerilogParser) Event_identifier() (localctx IEvent_identifierContext) {
	localctx = NewEvent_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, VerilogParserRULE_event_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4284)
		p.Identifier()
	}

	return localctx
}

// IFunction_identifierContext is an interface to support dynamic dispatch.
type IFunction_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_identifierContext differentiates from other interfaces.
	IsFunction_identifierContext()
}

type Function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_identifierContext() *Function_identifierContext {
	var p = new(Function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_function_identifier
	return p
}

func (*Function_identifierContext) IsFunction_identifierContext() {}

func NewFunction_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_identifierContext {
	var p = new(Function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_function_identifier

	return p
}

func (s *Function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterFunction_identifier(s)
	}
}

func (s *Function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitFunction_identifier(s)
	}
}

func (p *VerilogParser) Function_identifier() (localctx IFunction_identifierContext) {
	localctx = NewFunction_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, VerilogParserRULE_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4286)
		p.Identifier()
	}

	return localctx
}

// IGate_instance_identifierContext is an interface to support dynamic dispatch.
type IGate_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGate_instance_identifierContext differentiates from other interfaces.
	IsGate_instance_identifierContext()
}

type Gate_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGate_instance_identifierContext() *Gate_instance_identifierContext {
	var p = new(Gate_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_gate_instance_identifier
	return p
}

func (*Gate_instance_identifierContext) IsGate_instance_identifierContext() {}

func NewGate_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Gate_instance_identifierContext {
	var p = new(Gate_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_gate_instance_identifier

	return p
}

func (s *Gate_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Gate_instance_identifierContext) Arrayed_identifier() IArrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_identifierContext)
}

func (s *Gate_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Gate_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Gate_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGate_instance_identifier(s)
	}
}

func (s *Gate_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGate_instance_identifier(s)
	}
}

func (p *VerilogParser) Gate_instance_identifier() (localctx IGate_instance_identifierContext) {
	localctx = NewGate_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, VerilogParserRULE_gate_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4288)
		p.Arrayed_identifier()
	}

	return localctx
}

// IGenerate_block_identifierContext is an interface to support dynamic dispatch.
type IGenerate_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_block_identifierContext differentiates from other interfaces.
	IsGenerate_block_identifierContext()
}

type Generate_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_block_identifierContext() *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_generate_block_identifier
	return p
}

func (*Generate_block_identifierContext) IsGenerate_block_identifierContext() {}

func NewGenerate_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_generate_block_identifier

	return p
}

func (s *Generate_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Generate_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenerate_block_identifier(s)
	}
}

func (s *Generate_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenerate_block_identifier(s)
	}
}

func (p *VerilogParser) Generate_block_identifier() (localctx IGenerate_block_identifierContext) {
	localctx = NewGenerate_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, VerilogParserRULE_generate_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4290)
		p.Identifier()
	}

	return localctx
}

// IGenvar_function_identifierContext is an interface to support dynamic dispatch.
type IGenvar_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_function_identifierContext differentiates from other interfaces.
	IsGenvar_function_identifierContext()
}

type Genvar_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_function_identifierContext() *Genvar_function_identifierContext {
	var p = new(Genvar_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_function_identifier
	return p
}

func (*Genvar_function_identifierContext) IsGenvar_function_identifierContext() {}

func NewGenvar_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_function_identifierContext {
	var p = new(Genvar_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_function_identifier

	return p
}

func (s *Genvar_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_function_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Genvar_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_function_identifier(s)
	}
}

func (s *Genvar_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_function_identifier(s)
	}
}

func (p *VerilogParser) Genvar_function_identifier() (localctx IGenvar_function_identifierContext) {
	localctx = NewGenvar_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, VerilogParserRULE_genvar_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4292)
		p.Identifier()
	}

	return localctx
}

// IGenvar_identifierContext is an interface to support dynamic dispatch.
type IGenvar_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_identifierContext differentiates from other interfaces.
	IsGenvar_identifierContext()
}

type Genvar_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_identifierContext() *Genvar_identifierContext {
	var p = new(Genvar_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_genvar_identifier
	return p
}

func (*Genvar_identifierContext) IsGenvar_identifierContext() {}

func NewGenvar_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_identifierContext {
	var p = new(Genvar_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_genvar_identifier

	return p
}

func (s *Genvar_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Genvar_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterGenvar_identifier(s)
	}
}

func (s *Genvar_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitGenvar_identifier(s)
	}
}

func (p *VerilogParser) Genvar_identifier() (localctx IGenvar_identifierContext) {
	localctx = NewGenvar_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, VerilogParserRULE_genvar_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4294)
		p.Identifier()
	}

	return localctx
}

// IHierarchical_block_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_block_identifierContext differentiates from other interfaces.
	IsHierarchical_block_identifierContext()
}

type Hierarchical_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_block_identifierContext() *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_block_identifier
	return p
}

func (*Hierarchical_block_identifierContext) IsHierarchical_block_identifierContext() {}

func NewHierarchical_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_block_identifier

	return p
}

func (s *Hierarchical_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_block_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_block_identifier(s)
	}
}

func (s *Hierarchical_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_block_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_block_identifier() (localctx IHierarchical_block_identifierContext) {
	localctx = NewHierarchical_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, VerilogParserRULE_hierarchical_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4296)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_event_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_event_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_event_identifierContext differentiates from other interfaces.
	IsHierarchical_event_identifierContext()
}

type Hierarchical_event_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_event_identifierContext() *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_event_identifier
	return p
}

func (*Hierarchical_event_identifierContext) IsHierarchical_event_identifierContext() {}

func NewHierarchical_event_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_event_identifier

	return p
}

func (s *Hierarchical_event_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_event_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_event_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_event_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_event_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_event_identifier(s)
	}
}

func (s *Hierarchical_event_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_event_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_event_identifier() (localctx IHierarchical_event_identifierContext) {
	localctx = NewHierarchical_event_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, VerilogParserRULE_hierarchical_event_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4298)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_function_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_function_identifierContext differentiates from other interfaces.
	IsHierarchical_function_identifierContext()
}

type Hierarchical_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_function_identifierContext() *Hierarchical_function_identifierContext {
	var p = new(Hierarchical_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_function_identifier
	return p
}

func (*Hierarchical_function_identifierContext) IsHierarchical_function_identifierContext() {}

func NewHierarchical_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_function_identifierContext {
	var p = new(Hierarchical_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_function_identifier

	return p
}

func (s *Hierarchical_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_function_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_function_identifier(s)
	}
}

func (s *Hierarchical_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_function_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_function_identifier() (localctx IHierarchical_function_identifierContext) {
	localctx = NewHierarchical_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, VerilogParserRULE_hierarchical_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4300)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_identifierContext differentiates from other interfaces.
	IsHierarchical_identifierContext()
}

type Hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_identifierContext() *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_identifier
	return p
}

func (*Hierarchical_identifierContext) IsHierarchical_identifierContext() {}

func NewHierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_identifier

	return p
}

func (s *Hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_identifierContext) Simple_hierarchical_identifier() ISimple_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_hierarchical_identifierContext)
}

func (s *Hierarchical_identifierContext) Escaped_hierarchical_identifier() IEscaped_hierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscaped_hierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEscaped_hierarchical_identifierContext)
}

func (s *Hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_identifier(s)
	}
}

func (s *Hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_identifier() (localctx IHierarchical_identifierContext) {
	localctx = NewHierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, VerilogParserRULE_hierarchical_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4304)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case VerilogParserSimple_identifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4302)
			p.Simple_hierarchical_identifier()
		}

	case VerilogParserEscaped_identifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4303)
			p.Escaped_hierarchical_identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHierarchical_net_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_net_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_net_identifierContext differentiates from other interfaces.
	IsHierarchical_net_identifierContext()
}

type Hierarchical_net_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_net_identifierContext() *Hierarchical_net_identifierContext {
	var p = new(Hierarchical_net_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_net_identifier
	return p
}

func (*Hierarchical_net_identifierContext) IsHierarchical_net_identifierContext() {}

func NewHierarchical_net_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_net_identifierContext {
	var p = new(Hierarchical_net_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_net_identifier

	return p
}

func (s *Hierarchical_net_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_net_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_net_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_net_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_net_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_net_identifier(s)
	}
}

func (s *Hierarchical_net_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_net_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_net_identifier() (localctx IHierarchical_net_identifierContext) {
	localctx = NewHierarchical_net_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, VerilogParserRULE_hierarchical_net_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4306)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_variable_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_variable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_variable_identifierContext differentiates from other interfaces.
	IsHierarchical_variable_identifierContext()
}

type Hierarchical_variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_variable_identifierContext() *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_variable_identifier
	return p
}

func (*Hierarchical_variable_identifierContext) IsHierarchical_variable_identifierContext() {}

func NewHierarchical_variable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_variable_identifier

	return p
}

func (s *Hierarchical_variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_variable_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_variable_identifier(s)
	}
}

func (s *Hierarchical_variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_variable_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_variable_identifier() (localctx IHierarchical_variable_identifierContext) {
	localctx = NewHierarchical_variable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, VerilogParserRULE_hierarchical_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4308)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_task_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_task_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_task_identifierContext differentiates from other interfaces.
	IsHierarchical_task_identifierContext()
}

type Hierarchical_task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_task_identifierContext() *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_hierarchical_task_identifier
	return p
}

func (*Hierarchical_task_identifierContext) IsHierarchical_task_identifierContext() {}

func NewHierarchical_task_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_hierarchical_task_identifier

	return p
}

func (s *Hierarchical_task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_task_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterHierarchical_task_identifier(s)
	}
}

func (s *Hierarchical_task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitHierarchical_task_identifier(s)
	}
}

func (p *VerilogParser) Hierarchical_task_identifier() (localctx IHierarchical_task_identifierContext) {
	localctx = NewHierarchical_task_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, VerilogParserRULE_hierarchical_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4310)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Simple_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserSimple_identifier, 0)
}

func (s *IdentifierContext) Escaped_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserEscaped_identifier, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *VerilogParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, VerilogParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4312)
		_la = p.GetTokenStream().LA(1)

		if !(_la == VerilogParserEscaped_identifier || _la == VerilogParserSimple_identifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInout_port_identifierContext is an interface to support dynamic dispatch.
type IInout_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_port_identifierContext differentiates from other interfaces.
	IsInout_port_identifierContext()
}

type Inout_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_port_identifierContext() *Inout_port_identifierContext {
	var p = new(Inout_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_inout_port_identifier
	return p
}

func (*Inout_port_identifierContext) IsInout_port_identifierContext() {}

func NewInout_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_port_identifierContext {
	var p = new(Inout_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_inout_port_identifier

	return p
}

func (s *Inout_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Inout_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInout_port_identifier(s)
	}
}

func (s *Inout_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInout_port_identifier(s)
	}
}

func (p *VerilogParser) Inout_port_identifier() (localctx IInout_port_identifierContext) {
	localctx = NewInout_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, VerilogParserRULE_inout_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4314)
		p.Identifier()
	}

	return localctx
}

// IInput_port_identifierContext is an interface to support dynamic dispatch.
type IInput_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_port_identifierContext differentiates from other interfaces.
	IsInput_port_identifierContext()
}

type Input_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_port_identifierContext() *Input_port_identifierContext {
	var p = new(Input_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_input_port_identifier
	return p
}

func (*Input_port_identifierContext) IsInput_port_identifierContext() {}

func NewInput_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_port_identifierContext {
	var p = new(Input_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_input_port_identifier

	return p
}

func (s *Input_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Input_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInput_port_identifier(s)
	}
}

func (s *Input_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInput_port_identifier(s)
	}
}

func (p *VerilogParser) Input_port_identifier() (localctx IInput_port_identifierContext) {
	localctx = NewInput_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, VerilogParserRULE_input_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4316)
		p.Identifier()
	}

	return localctx
}

// IInstance_identifierContext is an interface to support dynamic dispatch.
type IInstance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_identifierContext differentiates from other interfaces.
	IsInstance_identifierContext()
}

type Instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_identifierContext() *Instance_identifierContext {
	var p = new(Instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_instance_identifier
	return p
}

func (*Instance_identifierContext) IsInstance_identifierContext() {}

func NewInstance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_identifierContext {
	var p = new(Instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_instance_identifier

	return p
}

func (s *Instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterInstance_identifier(s)
	}
}

func (s *Instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitInstance_identifier(s)
	}
}

func (p *VerilogParser) Instance_identifier() (localctx IInstance_identifierContext) {
	localctx = NewInstance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, VerilogParserRULE_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4318)
		p.Identifier()
	}

	return localctx
}

// ILibrary_identifierContext is an interface to support dynamic dispatch.
type ILibrary_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_identifierContext differentiates from other interfaces.
	IsLibrary_identifierContext()
}

type Library_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_identifierContext() *Library_identifierContext {
	var p = new(Library_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_library_identifier
	return p
}

func (*Library_identifierContext) IsLibrary_identifierContext() {}

func NewLibrary_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_identifierContext {
	var p = new(Library_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_library_identifier

	return p
}

func (s *Library_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Library_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterLibrary_identifier(s)
	}
}

func (s *Library_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitLibrary_identifier(s)
	}
}

func (p *VerilogParser) Library_identifier() (localctx ILibrary_identifierContext) {
	localctx = NewLibrary_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, VerilogParserRULE_library_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4320)
		p.Identifier()
	}

	return localctx
}

// IMemory_identifierContext is an interface to support dynamic dispatch.
type IMemory_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemory_identifierContext differentiates from other interfaces.
	IsMemory_identifierContext()
}

type Memory_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemory_identifierContext() *Memory_identifierContext {
	var p = new(Memory_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_memory_identifier
	return p
}

func (*Memory_identifierContext) IsMemory_identifierContext() {}

func NewMemory_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Memory_identifierContext {
	var p = new(Memory_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_memory_identifier

	return p
}

func (s *Memory_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Memory_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Memory_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Memory_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Memory_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterMemory_identifier(s)
	}
}

func (s *Memory_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitMemory_identifier(s)
	}
}

func (p *VerilogParser) Memory_identifier() (localctx IMemory_identifierContext) {
	localctx = NewMemory_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, VerilogParserRULE_memory_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4322)
		p.Identifier()
	}

	return localctx
}

// IModule_identifierContext is an interface to support dynamic dispatch.
type IModule_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_identifierContext differentiates from other interfaces.
	IsModule_identifierContext()
}

type Module_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_identifierContext() *Module_identifierContext {
	var p = new(Module_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_identifier
	return p
}

func (*Module_identifierContext) IsModule_identifierContext() {}

func NewModule_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_identifierContext {
	var p = new(Module_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_identifier

	return p
}

func (s *Module_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_identifier(s)
	}
}

func (s *Module_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_identifier(s)
	}
}

func (p *VerilogParser) Module_identifier() (localctx IModule_identifierContext) {
	localctx = NewModule_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, VerilogParserRULE_module_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4324)
		p.Identifier()
	}

	return localctx
}

// IModule_instance_identifierContext is an interface to support dynamic dispatch.
type IModule_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instance_identifierContext differentiates from other interfaces.
	IsModule_instance_identifierContext()
}

type Module_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instance_identifierContext() *Module_instance_identifierContext {
	var p = new(Module_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_module_instance_identifier
	return p
}

func (*Module_instance_identifierContext) IsModule_instance_identifierContext() {}

func NewModule_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instance_identifierContext {
	var p = new(Module_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_module_instance_identifier

	return p
}

func (s *Module_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instance_identifierContext) Arrayed_identifier() IArrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_identifierContext)
}

func (s *Module_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterModule_instance_identifier(s)
	}
}

func (s *Module_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitModule_instance_identifier(s)
	}
}

func (p *VerilogParser) Module_instance_identifier() (localctx IModule_instance_identifierContext) {
	localctx = NewModule_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, VerilogParserRULE_module_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4326)
		p.Arrayed_identifier()
	}

	return localctx
}

// INet_identifierContext is an interface to support dynamic dispatch.
type INet_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_identifierContext differentiates from other interfaces.
	IsNet_identifierContext()
}

type Net_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_identifierContext() *Net_identifierContext {
	var p = new(Net_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_net_identifier
	return p
}

func (*Net_identifierContext) IsNet_identifierContext() {}

func NewNet_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_identifierContext {
	var p = new(Net_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_net_identifier

	return p
}

func (s *Net_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Net_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterNet_identifier(s)
	}
}

func (s *Net_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitNet_identifier(s)
	}
}

func (p *VerilogParser) Net_identifier() (localctx INet_identifierContext) {
	localctx = NewNet_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, VerilogParserRULE_net_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4328)
		p.Identifier()
	}

	return localctx
}

// IOutput_port_identifierContext is an interface to support dynamic dispatch.
type IOutput_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_port_identifierContext differentiates from other interfaces.
	IsOutput_port_identifierContext()
}

type Output_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_port_identifierContext() *Output_port_identifierContext {
	var p = new(Output_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_output_port_identifier
	return p
}

func (*Output_port_identifierContext) IsOutput_port_identifierContext() {}

func NewOutput_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_port_identifierContext {
	var p = new(Output_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_output_port_identifier

	return p
}

func (s *Output_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Output_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterOutput_port_identifier(s)
	}
}

func (s *Output_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitOutput_port_identifier(s)
	}
}

func (p *VerilogParser) Output_port_identifier() (localctx IOutput_port_identifierContext) {
	localctx = NewOutput_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, VerilogParserRULE_output_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4330)
		p.Identifier()
	}

	return localctx
}

// IParameter_identifierContext is an interface to support dynamic dispatch.
type IParameter_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_identifierContext differentiates from other interfaces.
	IsParameter_identifierContext()
}

type Parameter_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_identifierContext() *Parameter_identifierContext {
	var p = new(Parameter_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_parameter_identifier
	return p
}

func (*Parameter_identifierContext) IsParameter_identifierContext() {}

func NewParameter_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_identifierContext {
	var p = new(Parameter_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_parameter_identifier

	return p
}

func (s *Parameter_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Parameter_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterParameter_identifier(s)
	}
}

func (s *Parameter_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitParameter_identifier(s)
	}
}

func (p *VerilogParser) Parameter_identifier() (localctx IParameter_identifierContext) {
	localctx = NewParameter_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, VerilogParserRULE_parameter_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4332)
		p.Identifier()
	}

	return localctx
}

// IPort_identifierContext is an interface to support dynamic dispatch.
type IPort_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_identifierContext differentiates from other interfaces.
	IsPort_identifierContext()
}

type Port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_identifierContext() *Port_identifierContext {
	var p = new(Port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_port_identifier
	return p
}

func (*Port_identifierContext) IsPort_identifierContext() {}

func NewPort_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_identifierContext {
	var p = new(Port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_port_identifier

	return p
}

func (s *Port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterPort_identifier(s)
	}
}

func (s *Port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitPort_identifier(s)
	}
}

func (p *VerilogParser) Port_identifier() (localctx IPort_identifierContext) {
	localctx = NewPort_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, VerilogParserRULE_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4334)
		p.Identifier()
	}

	return localctx
}

// IReal_identifierContext is an interface to support dynamic dispatch.
type IReal_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_identifierContext differentiates from other interfaces.
	IsReal_identifierContext()
}

type Real_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_identifierContext() *Real_identifierContext {
	var p = new(Real_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_real_identifier
	return p
}

func (*Real_identifierContext) IsReal_identifierContext() {}

func NewReal_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_identifierContext {
	var p = new(Real_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_real_identifier

	return p
}

func (s *Real_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Real_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterReal_identifier(s)
	}
}

func (s *Real_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitReal_identifier(s)
	}
}

func (p *VerilogParser) Real_identifier() (localctx IReal_identifierContext) {
	localctx = NewReal_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, VerilogParserRULE_real_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4336)
		p.Identifier()
	}

	return localctx
}

// ISimple_arrayed_identifierContext is an interface to support dynamic dispatch.
type ISimple_arrayed_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_arrayed_identifierContext differentiates from other interfaces.
	IsSimple_arrayed_identifierContext()
}

type Simple_arrayed_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_arrayed_identifierContext() *Simple_arrayed_identifierContext {
	var p = new(Simple_arrayed_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_simple_arrayed_identifier
	return p
}

func (*Simple_arrayed_identifierContext) IsSimple_arrayed_identifierContext() {}

func NewSimple_arrayed_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_arrayed_identifierContext {
	var p = new(Simple_arrayed_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_simple_arrayed_identifier

	return p
}

func (s *Simple_arrayed_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_arrayed_identifierContext) Simple_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserSimple_identifier, 0)
}

func (s *Simple_arrayed_identifierContext) Range_() IRange_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_Context)
}

func (s *Simple_arrayed_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_arrayed_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_arrayed_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSimple_arrayed_identifier(s)
	}
}

func (s *Simple_arrayed_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSimple_arrayed_identifier(s)
	}
}

func (p *VerilogParser) Simple_arrayed_identifier() (localctx ISimple_arrayed_identifierContext) {
	localctx = NewSimple_arrayed_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, VerilogParserRULE_simple_arrayed_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4338)
		p.Match(VerilogParserSimple_identifier)
	}
	p.SetState(4340)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 461, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4339)
			p.Range_()
		}

	}

	return localctx
}

// ISimple_hierarchical_identifierContext is an interface to support dynamic dispatch.
type ISimple_hierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_hierarchical_identifierContext differentiates from other interfaces.
	IsSimple_hierarchical_identifierContext()
}

type Simple_hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_hierarchical_identifierContext() *Simple_hierarchical_identifierContext {
	var p = new(Simple_hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_simple_hierarchical_identifier
	return p
}

func (*Simple_hierarchical_identifierContext) IsSimple_hierarchical_identifierContext() {}

func NewSimple_hierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_hierarchical_identifierContext {
	var p = new(Simple_hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_simple_hierarchical_identifier

	return p
}

func (s *Simple_hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_hierarchical_identifierContext) Simple_hierarchical_branch() ISimple_hierarchical_branchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_hierarchical_branchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_hierarchical_branchContext)
}

func (s *Simple_hierarchical_identifierContext) Dot() antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, 0)
}

func (s *Simple_hierarchical_identifierContext) Escaped_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserEscaped_identifier, 0)
}

func (s *Simple_hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSimple_hierarchical_identifier(s)
	}
}

func (s *Simple_hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSimple_hierarchical_identifier(s)
	}
}

func (p *VerilogParser) Simple_hierarchical_identifier() (localctx ISimple_hierarchical_identifierContext) {
	localctx = NewSimple_hierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, VerilogParserRULE_simple_hierarchical_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4342)
		p.Simple_hierarchical_branch()
	}
	p.SetState(4345)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == VerilogParserDot {
		{
			p.SetState(4343)
			p.Match(VerilogParserDot)
		}
		{
			p.SetState(4344)
			p.Match(VerilogParserEscaped_identifier)
		}

	}

	return localctx
}

// ISpecparam_identifierContext is an interface to support dynamic dispatch.
type ISpecparam_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_identifierContext differentiates from other interfaces.
	IsSpecparam_identifierContext()
}

type Specparam_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_identifierContext() *Specparam_identifierContext {
	var p = new(Specparam_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_specparam_identifier
	return p
}

func (*Specparam_identifierContext) IsSpecparam_identifierContext() {}

func NewSpecparam_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_identifierContext {
	var p = new(Specparam_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_specparam_identifier

	return p
}

func (s *Specparam_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Specparam_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSpecparam_identifier(s)
	}
}

func (s *Specparam_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSpecparam_identifier(s)
	}
}

func (p *VerilogParser) Specparam_identifier() (localctx ISpecparam_identifierContext) {
	localctx = NewSpecparam_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, VerilogParserRULE_specparam_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4347)
		p.Identifier()
	}

	return localctx
}

// ISystem_function_identifierContext is an interface to support dynamic dispatch.
type ISystem_function_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_function_identifierContext differentiates from other interfaces.
	IsSystem_function_identifierContext()
}

type System_function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_function_identifierContext() *System_function_identifierContext {
	var p = new(System_function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_function_identifier
	return p
}

func (*System_function_identifierContext) IsSystem_function_identifierContext() {}

func NewSystem_function_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_function_identifierContext {
	var p = new(System_function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_function_identifier

	return p
}

func (s *System_function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *System_function_identifierContext) K_FUNC_q_initialize() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_q_initialize, 0)
}

func (s *System_function_identifierContext) K_FUNC_q_full() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_q_full, 0)
}

func (s *System_function_identifierContext) K_FUNC_q_remove() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_q_remove, 0)
}

func (s *System_function_identifierContext) K_FUNC_q_exam() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_q_exam, 0)
}

func (s *System_function_identifierContext) K_FUNC_q_add() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_q_add, 0)
}

func (s *System_function_identifierContext) K_FUNC_realtime() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_realtime, 0)
}

func (s *System_function_identifierContext) K_FUNC_stime() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_stime, 0)
}

func (s *System_function_identifierContext) K_FUNC_time() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_time, 0)
}

func (s *System_function_identifierContext) K_FUNC_shortrealtobits() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_shortrealtobits, 0)
}

func (s *System_function_identifierContext) K_FUNC_bitstoshortreal() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_bitstoshortreal, 0)
}

func (s *System_function_identifierContext) K_FUNC_realtobits() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_realtobits, 0)
}

func (s *System_function_identifierContext) K_FUNC_bitstoreal() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_bitstoreal, 0)
}

func (s *System_function_identifierContext) K_FUNC_unsigned() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_unsigned, 0)
}

func (s *System_function_identifierContext) K_FUNC_signed() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_signed, 0)
}

func (s *System_function_identifierContext) K_FUNC_rtoi() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_rtoi, 0)
}

func (s *System_function_identifierContext) K_FUNC_itor() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_itor, 0)
}

func (s *System_function_identifierContext) K_FUNC_cast() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_cast, 0)
}

func (s *System_function_identifierContext) K_FUNC_random() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_random, 0)
}

func (s *System_function_identifierContext) K_FUNC_dist_exponential() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_dist_exponential, 0)
}

func (s *System_function_identifierContext) K_FUNC_dist_chi_square() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_dist_chi_square, 0)
}

func (s *System_function_identifierContext) K_FUNC_dist_uniform() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_dist_uniform, 0)
}

func (s *System_function_identifierContext) K_FUNC_dist_poisson() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_dist_poisson, 0)
}

func (s *System_function_identifierContext) K_FUNC_dist_normal() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_dist_normal, 0)
}

func (s *System_function_identifierContext) K_FUNC_dist_erlang() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_dist_erlang, 0)
}

func (s *System_function_identifierContext) K_FUNC_dist_t() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_dist_t, 0)
}

func (s *System_function_identifierContext) K_FUNC_test_plusargs() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_test_plusargs, 0)
}

func (s *System_function_identifierContext) K_FUNC_value_plusargs() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_FUNC_value_plusargs, 0)
}

func (s *System_function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSystem_function_identifier(s)
	}
}

func (s *System_function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSystem_function_identifier(s)
	}
}

func (p *VerilogParser) System_function_identifier() (localctx ISystem_function_identifierContext) {
	localctx = NewSystem_function_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, VerilogParserRULE_system_function_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4349)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-218)&-(0x1f+1)) == 0 && ((1<<uint((_la-218)))&((1<<(VerilogParserK_FUNC_q_initialize-218))|(1<<(VerilogParserK_FUNC_q_remove-218))|(1<<(VerilogParserK_FUNC_q_full-218))|(1<<(VerilogParserK_FUNC_q_exam-218))|(1<<(VerilogParserK_FUNC_q_add-218))|(1<<(VerilogParserK_FUNC_realtime-218))|(1<<(VerilogParserK_FUNC_stime-218))|(1<<(VerilogParserK_FUNC_time-218))|(1<<(VerilogParserK_FUNC_shortrealtobits-218))|(1<<(VerilogParserK_FUNC_bitstoshortreal-218))|(1<<(VerilogParserK_FUNC_realtobits-218))|(1<<(VerilogParserK_FUNC_bitstoreal-218))|(1<<(VerilogParserK_FUNC_unsigned-218))|(1<<(VerilogParserK_FUNC_signed-218))|(1<<(VerilogParserK_FUNC_rtoi-218))|(1<<(VerilogParserK_FUNC_itor-218))|(1<<(VerilogParserK_FUNC_cast-218))|(1<<(VerilogParserK_FUNC_random-218))|(1<<(VerilogParserK_FUNC_dist_exponential-218))|(1<<(VerilogParserK_FUNC_dist_chi_square-218))|(1<<(VerilogParserK_FUNC_dist_uniform-218))|(1<<(VerilogParserK_FUNC_dist_poisson-218))|(1<<(VerilogParserK_FUNC_dist_normal-218))|(1<<(VerilogParserK_FUNC_dist_erlang-218))|(1<<(VerilogParserK_FUNC_dist_t-218))|(1<<(VerilogParserK_FUNC_test_plusargs-218))|(1<<(VerilogParserK_FUNC_value_plusargs-218)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISystem_task_identifierContext is an interface to support dynamic dispatch.
type ISystem_task_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_task_identifierContext differentiates from other interfaces.
	IsSystem_task_identifierContext()
}

type System_task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_task_identifierContext() *System_task_identifierContext {
	var p = new(System_task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_system_task_identifier
	return p
}

func (*System_task_identifierContext) IsSystem_task_identifierContext() {}

func NewSystem_task_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_task_identifierContext {
	var p = new(System_task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_system_task_identifier

	return p
}

func (s *System_task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *System_task_identifierContext) K_TASK_monitoroff() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_monitoroff, 0)
}

func (s *System_task_identifierContext) K_TASK_monitoron() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_monitoron, 0)
}

func (s *System_task_identifierContext) K_TASK_fmonitorh() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fmonitorh, 0)
}

func (s *System_task_identifierContext) K_TASK_monitorb() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_monitorb, 0)
}

func (s *System_task_identifierContext) K_TASK_displayo() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_displayo, 0)
}

func (s *System_task_identifierContext) K_TASK_displayh() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_displayh, 0)
}

func (s *System_task_identifierContext) K_TASK_displayb() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_displayb, 0)
}

func (s *System_task_identifierContext) K_TASK_strobeo() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_strobeo, 0)
}

func (s *System_task_identifierContext) K_TASK_strobeh() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_strobeh, 0)
}

func (s *System_task_identifierContext) K_TASK_strobeb() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_strobeb, 0)
}

func (s *System_task_identifierContext) K_TASK_monitor() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_monitor, 0)
}

func (s *System_task_identifierContext) K_TASK_display() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_display, 0)
}

func (s *System_task_identifierContext) K_TASK_writeo() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_writeo, 0)
}

func (s *System_task_identifierContext) K_TASK_writeh() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_writeh, 0)
}

func (s *System_task_identifierContext) K_TASK_fwriteb() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fwriteb, 0)
}

func (s *System_task_identifierContext) K_TASK_strobe() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_strobe, 0)
}

func (s *System_task_identifierContext) K_TASK_write() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_write, 0)
}

func (s *System_task_identifierContext) K_TASK_fmonitoro() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fmonitoro, 0)
}

func (s *System_task_identifierContext) K_TASK_fmonitorb() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fmonitorb, 0)
}

func (s *System_task_identifierContext) K_TASK_fdisplayo() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fdisplayo, 0)
}

func (s *System_task_identifierContext) K_TASK_fdisplayh() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fdisplayh, 0)
}

func (s *System_task_identifierContext) K_TASK_fdisplayb() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fdisplayb, 0)
}

func (s *System_task_identifierContext) K_TASK_fmonitor() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fmonitor, 0)
}

func (s *System_task_identifierContext) K_TASK_fdisplay() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fdisplay, 0)
}

func (s *System_task_identifierContext) K_TASK_fstrobeo() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fstrobeo, 0)
}

func (s *System_task_identifierContext) K_TASK_fstrobeh() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fstrobeh, 0)
}

func (s *System_task_identifierContext) K_TASK_fstrobeb() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fstrobeb, 0)
}

func (s *System_task_identifierContext) K_TASK_sformatf() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sformatf, 0)
}

func (s *System_task_identifierContext) K_TASK_swriteo() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_swriteo, 0)
}

func (s *System_task_identifierContext) K_TASK_swriteh() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_swriteh, 0)
}

func (s *System_task_identifierContext) K_TASK_swriteb() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_swriteb, 0)
}

func (s *System_task_identifierContext) K_TASK_sformat() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sformat, 0)
}

func (s *System_task_identifierContext) K_TASK_fwriteo() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fwriteo, 0)
}

func (s *System_task_identifierContext) K_TASK_fwriteh() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fwriteh, 0)
}

func (s *System_task_identifierContext) K_TASK_fstrobe() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fstrobe, 0)
}

func (s *System_task_identifierContext) K_TASK_ungetc() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_ungetc, 0)
}

func (s *System_task_identifierContext) K_TASK_swrite() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_swrite, 0)
}

func (s *System_task_identifierContext) K_TASK_sscanf() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sscanf, 0)
}

func (s *System_task_identifierContext) K_TASK_rewind() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_rewind, 0)
}

func (s *System_task_identifierContext) K_TASK_fwrite() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fwrite, 0)
}

func (s *System_task_identifierContext) K_TASK_fscanf() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fscanf, 0)
}

func (s *System_task_identifierContext) K_TASK_fflush() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fflush, 0)
}

func (s *System_task_identifierContext) K_TASK_ferror() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_ferror, 0)
}

func (s *System_task_identifierContext) K_TASK_fclose() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fclose, 0)
}

func (s *System_task_identifierContext) K_TASK_ftell() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_ftell, 0)
}

func (s *System_task_identifierContext) K_TASK_fseek() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fseek, 0)
}

func (s *System_task_identifierContext) K_TASK_fopen() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fopen, 0)
}

func (s *System_task_identifierContext) K_TASK_fread() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fread, 0)
}

func (s *System_task_identifierContext) K_TASK_fgets() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fgets, 0)
}

func (s *System_task_identifierContext) K_TASK_fgetc() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_fgetc, 0)
}

func (s *System_task_identifierContext) K_TASK_feof() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_feof, 0)
}

func (s *System_task_identifierContext) K_TASK_printtimescale() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_printtimescale, 0)
}

func (s *System_task_identifierContext) K_TASK_timeformat() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_timeformat, 0)
}

func (s *System_task_identifierContext) K_TASK_finish() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_finish, 0)
}

func (s *System_task_identifierContext) K_TASK_stop() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_stop, 0)
}

func (s *System_task_identifierContext) K_TASK_async_nand_plane() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_async_nand_plane, 0)
}

func (s *System_task_identifierContext) K_TASK_async_nand_array() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_async_nand_array, 0)
}

func (s *System_task_identifierContext) K_TASK_async_nor_plane() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_async_nor_plane, 0)
}

func (s *System_task_identifierContext) K_TASK_async_nor_array() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_async_nor_array, 0)
}

func (s *System_task_identifierContext) K_TASK_async_and_plane() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_async_and_plane, 0)
}

func (s *System_task_identifierContext) K_TASK_async_and_array() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_async_and_array, 0)
}

func (s *System_task_identifierContext) K_TASK_sync_nand_plane() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sync_nand_plane, 0)
}

func (s *System_task_identifierContext) K_TASK_sync_nand_array() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sync_nand_array, 0)
}

func (s *System_task_identifierContext) K_TASK_sync_nor_plane() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sync_nor_plane, 0)
}

func (s *System_task_identifierContext) K_TASK_sync_nor_array() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sync_nor_array, 0)
}

func (s *System_task_identifierContext) K_TASK_sync_and_plane() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sync_and_plane, 0)
}

func (s *System_task_identifierContext) K_TASK_sync_and_array() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sync_and_array, 0)
}

func (s *System_task_identifierContext) K_TASK_async_or_plane() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_async_or_plane, 0)
}

func (s *System_task_identifierContext) K_TASK_async_or_array() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_async_or_array, 0)
}

func (s *System_task_identifierContext) K_TASK_sync_or_plane() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sync_or_plane, 0)
}

func (s *System_task_identifierContext) K_TASK_sync_or_array() antlr.TerminalNode {
	return s.GetToken(VerilogParserK_TASK_sync_or_array, 0)
}

func (s *System_task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSystem_task_identifier(s)
	}
}

func (s *System_task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSystem_task_identifier(s)
	}
}

func (p *VerilogParser) System_task_identifier() (localctx ISystem_task_identifierContext) {
	localctx = NewSystem_task_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, VerilogParserRULE_system_task_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4351)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-144)&-(0x1f+1)) == 0 && ((1<<uint((_la-144)))&((1<<(VerilogParserK_TASK_monitoroff-144))|(1<<(VerilogParserK_TASK_monitoron-144))|(1<<(VerilogParserK_TASK_monitorb-144))|(1<<(VerilogParserK_TASK_displayo-144))|(1<<(VerilogParserK_TASK_displayh-144))|(1<<(VerilogParserK_TASK_displayb-144))|(1<<(VerilogParserK_TASK_strobeo-144))|(1<<(VerilogParserK_TASK_strobeh-144))|(1<<(VerilogParserK_TASK_strobeb-144))|(1<<(VerilogParserK_TASK_monitor-144))|(1<<(VerilogParserK_TASK_display-144))|(1<<(VerilogParserK_TASK_writeo-144))|(1<<(VerilogParserK_TASK_writeh-144))|(1<<(VerilogParserK_TASK_strobe-144))|(1<<(VerilogParserK_TASK_write-144))|(1<<(VerilogParserK_TASK_fmonitoro-144))|(1<<(VerilogParserK_TASK_fmonitorh-144))|(1<<(VerilogParserK_TASK_fmonitorb-144))|(1<<(VerilogParserK_TASK_fdisplayo-144))|(1<<(VerilogParserK_TASK_fdisplayh-144))|(1<<(VerilogParserK_TASK_fdisplayb-144))|(1<<(VerilogParserK_TASK_fmonitor-144))|(1<<(VerilogParserK_TASK_fdisplay-144))|(1<<(VerilogParserK_TASK_fstrobeo-144))|(1<<(VerilogParserK_TASK_fstrobeh-144))|(1<<(VerilogParserK_TASK_fstrobeb-144))|(1<<(VerilogParserK_TASK_sformatf-144))|(1<<(VerilogParserK_TASK_swriteo-144))|(1<<(VerilogParserK_TASK_swriteh-144)))) != 0) || (((_la-176)&-(0x1f+1)) == 0 && ((1<<uint((_la-176)))&((1<<(VerilogParserK_TASK_swriteb-176))|(1<<(VerilogParserK_TASK_sformat-176))|(1<<(VerilogParserK_TASK_fwriteo-176))|(1<<(VerilogParserK_TASK_fwriteh-176))|(1<<(VerilogParserK_TASK_fwriteb-176))|(1<<(VerilogParserK_TASK_fstrobe-176))|(1<<(VerilogParserK_TASK_ungetc-176))|(1<<(VerilogParserK_TASK_swrite-176))|(1<<(VerilogParserK_TASK_sscanf-176))|(1<<(VerilogParserK_TASK_rewind-176))|(1<<(VerilogParserK_TASK_fwrite-176))|(1<<(VerilogParserK_TASK_fscanf-176))|(1<<(VerilogParserK_TASK_fflush-176))|(1<<(VerilogParserK_TASK_ferror-176))|(1<<(VerilogParserK_TASK_fclose-176))|(1<<(VerilogParserK_TASK_ftell-176))|(1<<(VerilogParserK_TASK_fseek-176))|(1<<(VerilogParserK_TASK_fopen-176))|(1<<(VerilogParserK_TASK_fread-176))|(1<<(VerilogParserK_TASK_fgets-176))|(1<<(VerilogParserK_TASK_fgetc-176))|(1<<(VerilogParserK_TASK_feof-176))|(1<<(VerilogParserK_TASK_printtimescale-176))|(1<<(VerilogParserK_TASK_timeformat-176))|(1<<(VerilogParserK_TASK_finish-176))|(1<<(VerilogParserK_TASK_stop-176))|(1<<(VerilogParserK_TASK_async_nand_plane-176))|(1<<(VerilogParserK_TASK_async_nand_array-176))|(1<<(VerilogParserK_TASK_async_nor_plane-176))|(1<<(VerilogParserK_TASK_async_nor_array-176))|(1<<(VerilogParserK_TASK_async_and_plane-176))|(1<<(VerilogParserK_TASK_async_and_array-176)))) != 0) || (((_la-208)&-(0x1f+1)) == 0 && ((1<<uint((_la-208)))&((1<<(VerilogParserK_TASK_sync_nand_plane-208))|(1<<(VerilogParserK_TASK_sync_nand_array-208))|(1<<(VerilogParserK_TASK_sync_nor_plane-208))|(1<<(VerilogParserK_TASK_sync_nor_array-208))|(1<<(VerilogParserK_TASK_sync_and_plane-208))|(1<<(VerilogParserK_TASK_sync_and_array-208))|(1<<(VerilogParserK_TASK_async_or_plane-208))|(1<<(VerilogParserK_TASK_async_or_array-208))|(1<<(VerilogParserK_TASK_sync_or_plane-208))|(1<<(VerilogParserK_TASK_sync_or_array-208)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITask_identifierContext is an interface to support dynamic dispatch.
type ITask_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_identifierContext differentiates from other interfaces.
	IsTask_identifierContext()
}

type Task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_identifierContext() *Task_identifierContext {
	var p = new(Task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_task_identifier
	return p
}

func (*Task_identifierContext) IsTask_identifierContext() {}

func NewTask_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_identifierContext {
	var p = new(Task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_task_identifier

	return p
}

func (s *Task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTask_identifier(s)
	}
}

func (s *Task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTask_identifier(s)
	}
}

func (p *VerilogParser) Task_identifier() (localctx ITask_identifierContext) {
	localctx = NewTask_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, VerilogParserRULE_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4353)
		p.Identifier()
	}

	return localctx
}

// ITerminal_identifierContext is an interface to support dynamic dispatch.
type ITerminal_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminal_identifierContext differentiates from other interfaces.
	IsTerminal_identifierContext()
}

type Terminal_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminal_identifierContext() *Terminal_identifierContext {
	var p = new(Terminal_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_terminal_identifier
	return p
}

func (*Terminal_identifierContext) IsTerminal_identifierContext() {}

func NewTerminal_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Terminal_identifierContext {
	var p = new(Terminal_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_terminal_identifier

	return p
}

func (s *Terminal_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Terminal_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Terminal_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Terminal_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Terminal_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTerminal_identifier(s)
	}
}

func (s *Terminal_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTerminal_identifier(s)
	}
}

func (p *VerilogParser) Terminal_identifier() (localctx ITerminal_identifierContext) {
	localctx = NewTerminal_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, VerilogParserRULE_terminal_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4355)
		p.Identifier()
	}

	return localctx
}

// IText_macro_identifierContext is an interface to support dynamic dispatch.
type IText_macro_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_macro_identifierContext differentiates from other interfaces.
	IsText_macro_identifierContext()
}

type Text_macro_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_macro_identifierContext() *Text_macro_identifierContext {
	var p = new(Text_macro_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_text_macro_identifier
	return p
}

func (*Text_macro_identifierContext) IsText_macro_identifierContext() {}

func NewText_macro_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_macro_identifierContext {
	var p = new(Text_macro_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_text_macro_identifier

	return p
}

func (s *Text_macro_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_macro_identifierContext) Simple_identifier() antlr.TerminalNode {
	return s.GetToken(VerilogParserSimple_identifier, 0)
}

func (s *Text_macro_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_macro_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_macro_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterText_macro_identifier(s)
	}
}

func (s *Text_macro_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitText_macro_identifier(s)
	}
}

func (p *VerilogParser) Text_macro_identifier() (localctx IText_macro_identifierContext) {
	localctx = NewText_macro_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, VerilogParserRULE_text_macro_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4357)
		p.Match(VerilogParserSimple_identifier)
	}

	return localctx
}

// ITopmodule_identifierContext is an interface to support dynamic dispatch.
type ITopmodule_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopmodule_identifierContext differentiates from other interfaces.
	IsTopmodule_identifierContext()
}

type Topmodule_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopmodule_identifierContext() *Topmodule_identifierContext {
	var p = new(Topmodule_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_topmodule_identifier
	return p
}

func (*Topmodule_identifierContext) IsTopmodule_identifierContext() {}

func NewTopmodule_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topmodule_identifierContext {
	var p = new(Topmodule_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_topmodule_identifier

	return p
}

func (s *Topmodule_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Topmodule_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Topmodule_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topmodule_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topmodule_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterTopmodule_identifier(s)
	}
}

func (s *Topmodule_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitTopmodule_identifier(s)
	}
}

func (p *VerilogParser) Topmodule_identifier() (localctx ITopmodule_identifierContext) {
	localctx = NewTopmodule_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, VerilogParserRULE_topmodule_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4359)
		p.Identifier()
	}

	return localctx
}

// IUdp_identifierContext is an interface to support dynamic dispatch.
type IUdp_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUdp_identifierContext differentiates from other interfaces.
	IsUdp_identifierContext()
}

type Udp_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdp_identifierContext() *Udp_identifierContext {
	var p = new(Udp_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_udp_identifier
	return p
}

func (*Udp_identifierContext) IsUdp_identifierContext() {}

func NewUdp_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Udp_identifierContext {
	var p = new(Udp_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_udp_identifier

	return p
}

func (s *Udp_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Udp_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Udp_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Udp_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Udp_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUdp_identifier(s)
	}
}

func (s *Udp_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUdp_identifier(s)
	}
}

func (p *VerilogParser) Udp_identifier() (localctx IUdp_identifierContext) {
	localctx = NewUdp_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, VerilogParserRULE_udp_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4361)
		p.Identifier()
	}

	return localctx
}

// IUdp_instance_identifierContext is an interface to support dynamic dispatch.
type IUdp_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUdp_instance_identifierContext differentiates from other interfaces.
	IsUdp_instance_identifierContext()
}

type Udp_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdp_instance_identifierContext() *Udp_instance_identifierContext {
	var p = new(Udp_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_udp_instance_identifier
	return p
}

func (*Udp_instance_identifierContext) IsUdp_instance_identifierContext() {}

func NewUdp_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Udp_instance_identifierContext {
	var p = new(Udp_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_udp_instance_identifier

	return p
}

func (s *Udp_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Udp_instance_identifierContext) Arrayed_identifier() IArrayed_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayed_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayed_identifierContext)
}

func (s *Udp_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Udp_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Udp_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterUdp_instance_identifier(s)
	}
}

func (s *Udp_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitUdp_instance_identifier(s)
	}
}

func (p *VerilogParser) Udp_instance_identifier() (localctx IUdp_instance_identifierContext) {
	localctx = NewUdp_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, VerilogParserRULE_udp_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4363)
		p.Arrayed_identifier()
	}

	return localctx
}

// IVariable_identifierContext is an interface to support dynamic dispatch.
type IVariable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_identifierContext differentiates from other interfaces.
	IsVariable_identifierContext()
}

type Variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_identifierContext() *Variable_identifierContext {
	var p = new(Variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_variable_identifier
	return p
}

func (*Variable_identifierContext) IsVariable_identifierContext() {}

func NewVariable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_identifierContext {
	var p = new(Variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_variable_identifier

	return p
}

func (s *Variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterVariable_identifier(s)
	}
}

func (s *Variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitVariable_identifier(s)
	}
}

func (p *VerilogParser) Variable_identifier() (localctx IVariable_identifierContext) {
	localctx = NewVariable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, VerilogParserRULE_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4365)
		p.Identifier()
	}

	return localctx
}

// ISimple_hierarchical_branchContext is an interface to support dynamic dispatch.
type ISimple_hierarchical_branchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_hierarchical_branchContext differentiates from other interfaces.
	IsSimple_hierarchical_branchContext()
}

type Simple_hierarchical_branchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_hierarchical_branchContext() *Simple_hierarchical_branchContext {
	var p = new(Simple_hierarchical_branchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_simple_hierarchical_branch
	return p
}

func (*Simple_hierarchical_branchContext) IsSimple_hierarchical_branchContext() {}

func NewSimple_hierarchical_branchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_hierarchical_branchContext {
	var p = new(Simple_hierarchical_branchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_simple_hierarchical_branch

	return p
}

func (s *Simple_hierarchical_branchContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_hierarchical_branchContext) AllSimple_identifier() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserSimple_identifier)
}

func (s *Simple_hierarchical_branchContext) Simple_identifier(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserSimple_identifier, i)
}

func (s *Simple_hierarchical_branchContext) AllLeft_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_bracket)
}

func (s *Simple_hierarchical_branchContext) Left_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, i)
}

func (s *Simple_hierarchical_branchContext) AllDecimal_number() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDecimal_number)
}

func (s *Simple_hierarchical_branchContext) Decimal_number(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDecimal_number, i)
}

func (s *Simple_hierarchical_branchContext) AllRight_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_bracket)
}

func (s *Simple_hierarchical_branchContext) Right_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, i)
}

func (s *Simple_hierarchical_branchContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDot)
}

func (s *Simple_hierarchical_branchContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, i)
}

func (s *Simple_hierarchical_branchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_hierarchical_branchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_hierarchical_branchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterSimple_hierarchical_branch(s)
	}
}

func (s *Simple_hierarchical_branchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitSimple_hierarchical_branch(s)
	}
}

func (p *VerilogParser) Simple_hierarchical_branch() (localctx ISimple_hierarchical_branchContext) {
	localctx = NewSimple_hierarchical_branchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, VerilogParserRULE_simple_hierarchical_branch)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4367)
		p.Match(VerilogParserSimple_identifier)
	}
	p.SetState(4371)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 463, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4368)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4369)
			p.Match(VerilogParserDecimal_number)
		}
		{
			p.SetState(4370)
			p.Match(VerilogParserRight_bracket)
		}

	}
	p.SetState(4382)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4373)
				p.Match(VerilogParserDot)
			}
			{
				p.SetState(4374)
				p.Match(VerilogParserSimple_identifier)
			}
			p.SetState(4378)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 464, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4375)
					p.Match(VerilogParserLeft_bracket)
				}
				{
					p.SetState(4376)
					p.Match(VerilogParserDecimal_number)
				}
				{
					p.SetState(4377)
					p.Match(VerilogParserRight_bracket)
				}

			}

		}
		p.SetState(4384)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext())
	}

	return localctx
}

// IEscaped_hierarchical_branchContext is an interface to support dynamic dispatch.
type IEscaped_hierarchical_branchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscaped_hierarchical_branchContext differentiates from other interfaces.
	IsEscaped_hierarchical_branchContext()
}

type Escaped_hierarchical_branchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscaped_hierarchical_branchContext() *Escaped_hierarchical_branchContext {
	var p = new(Escaped_hierarchical_branchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = VerilogParserRULE_escaped_hierarchical_branch
	return p
}

func (*Escaped_hierarchical_branchContext) IsEscaped_hierarchical_branchContext() {}

func NewEscaped_hierarchical_branchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Escaped_hierarchical_branchContext {
	var p = new(Escaped_hierarchical_branchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = VerilogParserRULE_escaped_hierarchical_branch

	return p
}

func (s *Escaped_hierarchical_branchContext) GetParser() antlr.Parser { return s.parser }

func (s *Escaped_hierarchical_branchContext) AllEscaped_identifier() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserEscaped_identifier)
}

func (s *Escaped_hierarchical_branchContext) Escaped_identifier(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserEscaped_identifier, i)
}

func (s *Escaped_hierarchical_branchContext) AllLeft_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserLeft_bracket)
}

func (s *Escaped_hierarchical_branchContext) Left_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserLeft_bracket, i)
}

func (s *Escaped_hierarchical_branchContext) AllDecimal_number() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDecimal_number)
}

func (s *Escaped_hierarchical_branchContext) Decimal_number(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDecimal_number, i)
}

func (s *Escaped_hierarchical_branchContext) AllRight_bracket() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserRight_bracket)
}

func (s *Escaped_hierarchical_branchContext) Right_bracket(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserRight_bracket, i)
}

func (s *Escaped_hierarchical_branchContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(VerilogParserDot)
}

func (s *Escaped_hierarchical_branchContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(VerilogParserDot, i)
}

func (s *Escaped_hierarchical_branchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Escaped_hierarchical_branchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Escaped_hierarchical_branchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.EnterEscaped_hierarchical_branch(s)
	}
}

func (s *Escaped_hierarchical_branchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(VerilogParserListener); ok {
		listenerT.ExitEscaped_hierarchical_branch(s)
	}
}

func (p *VerilogParser) Escaped_hierarchical_branch() (localctx IEscaped_hierarchical_branchContext) {
	localctx = NewEscaped_hierarchical_branchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, VerilogParserRULE_escaped_hierarchical_branch)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4385)
		p.Match(VerilogParserEscaped_identifier)
	}
	p.SetState(4389)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4386)
			p.Match(VerilogParserLeft_bracket)
		}
		{
			p.SetState(4387)
			p.Match(VerilogParserDecimal_number)
		}
		{
			p.SetState(4388)
			p.Match(VerilogParserRight_bracket)
		}

	}
	p.SetState(4400)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 468, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4391)
				p.Match(VerilogParserDot)
			}
			{
				p.SetState(4392)
				p.Match(VerilogParserEscaped_identifier)
			}
			p.SetState(4396)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 467, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4393)
					p.Match(VerilogParserLeft_bracket)
				}
				{
					p.SetState(4394)
					p.Match(VerilogParserDecimal_number)
				}
				{
					p.SetState(4395)
					p.Match(VerilogParserRight_bracket)
				}

			}

		}
		p.SetState(4402)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 468, p.GetParserRuleContext())
	}

	return localctx
}
